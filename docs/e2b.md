


## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.








## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


#### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


#### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


#### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


#### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


#### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


#### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


#### stop

```python
async def stop()
```

Stop watching the directory.




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


#### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### stdout

```python
@property
def stdout()
```

Command stdout output.


#### stderr

```python
@property
def stderr()
```

Command stderr output.


#### error

```python
@property
def error()
```

Command execution error message.


#### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


#### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


#### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes






## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


#### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


#### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


#### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


#### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


#### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


#### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


#### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


#### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


#### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


#### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info



# Authentication in CLI

You must authenticate with E2B CLI before using it. Run the following command to sign in into your E2B account:

<CodeGroup isTerminalCommand>
```bash
e2b auth login
```
</CodeGroup>

# List running sandboxes

You can list all running sandboxes using the following command:

<CodeGroup isTerminalCommand>
```bash
e2b sandbox list
```
</CodeGroup>


# E2B CLI

E2B CLI is a command line tool that allows you to list, kill running sandboxes, and manage [sandbox templates](/docs/sandbox-templates).

## Installation

You can install E2B CLI using the following command:

<CodeGroup isTerminalCommand>
```bash
npm i -g @e2b/cli
```
</CodeGroup>


# Shutdown running sandboxes

You can shutdown single or all running sandboxes with the E2B CLI.

## Shutdown single sandbox

To shutdown a single sandbox, run the following command:

<CodeGroup isTerminalCommand>
```bash
e2b sandbox kill <sandbox-id>
```
</CodeGroup>

## Shutdown all sandboxes

To shutdown all running sandboxes, run the following command:

<CodeGroup isTerminalCommand>
```bash
e2b sandbox kill --all
```
</CodeGroup>


import Image from 'next/image'
import imgChart from '@/images/analyze-data-chart.png'

# Analyze data with AI

You can use E2B Sandbox to run AI-generated code to analyze data. Here's how the AI data analysis workflow usually looks like:
1. Your user has a dataset in CSV format or other formats.
2. You prompt the LLM to generate code (usually Python) based on the user's data.
3. The sandbox runs the AI-generated code and returns the results.
4. You display the results to the user.

---

## Example: Analyze CSV file with E2B and Claude 3.5 Sonnet
This short example will show you how to use E2B Sandbox to run AI-generated code to analyze CSV data.

### Table of Contents
1. [Install dependencies](#1-install-dependencies)
2. [Set your API keys](#2-set-your-api-keys)
3. [Download example CSV file](#3-download-example-csv-file)
4. [Initialize the sandbox and upload the dataset to the sandbox](#4-initialize-the-sandbox-and-upload-the-dataset-to-the-sandbox)
5. [Prepare the method for running AI-generated code](#5-prepare-the-method-for-running-ai-generated-code)
6. [Prepare the prompt and initialize Anthropic client](#6-prepare-the-prompt-and-initialize-anthropic-client)
7. [Connect the sandbox to the LLM with tool calling](#7-connect-the-sandbox-to-the-llm-with-tool-calling)
8. [Parse the LLM response and run the AI-generated code in the sandbox](#8-parse-the-llm-response-and-run-the-ai-generated-code-in-the-sandbox)
9. [Save the generated chart](#9-save-the-generated-chart)
10. [Run the code](#10-run-the-code)
11. [Full final code](#11-full-final-code)

### 1. Install dependencies
Install the E2B SDK and Claude SDK to your project by running the following command in your terminal.

<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter @anthropic-ai/sdk dotenv
```
```bash {{ language: 'python' }}
pip install e2b-code-interpreter anthropic python-dotenv
```
</CodeGroup>

### 2. Set your API keys
1. Get your E2B API key from [E2B Dashboard](/dashboard?tab=keys).
2. Get your Claude API key from [Claude API Dashboard](https://console.anthropic.com/settings/keys).
3. Paste the keys into your `.env` file.

<CodeGroup title=".env">
```bash
E2B_API_KEY=e2b_***
ANTHROPIC_API_KEY=sk-ant-***
```
</CodeGroup>

### 3. Download example CSV file
{/* We'll be using the publicly available [AirBnB NYC dataset](https://www.kaggle.com/datasets/dgomonov/new-york-city-airbnb-open-data). */}

We'll be using the publicly available [dataset of about 10,000 movies](https://www.kaggle.com/datasets/muqarrishzaib/tmdb-10000-movies-dataset).
1. Click the "Download" button at the top of the page.
2. Select "Download as zip (2 MB)".
3. Unzip the file and you should see `dataset.csv` file. Move it to the root of your project.


### 4. Initialize the sandbox and upload the dataset to the sandbox
We'll upload the dataset from the third step to the sandbox and save it as `dataset.csv` file.

<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
import 'dotenv/config'
import fs from 'fs'
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox
const sbx = await Sandbox.create()

// Upload the dataset to the sandbox
const content = fs.readFileSync('dataset.csv')
const datasetPathInSandbox = await sbx.files.write('dataset.csv', content)
```
```python {{ language: 'python', description: 'main.py' }}
from dotenv import load_dotenv
load_dotenv()
from e2b_code_interpreter import Sandbox

# Create sandbox
sbx = Sandbox()

# Upload the dataset to the sandbox
dataset_path_in_sandbox = ""
with open("dataset.csv", "rb") as f:
    dataset_path_in_sandbox = sbx.files.write("dataset.csv", f)

```
</CodeGroup>

### 5. Prepare the method for running AI-generated code
Add the following code to the file. Here we're adding the method for code execution.

<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
// ... code from the previous step

async function runAIGeneratedCode(aiGeneratedCode: string) {
  console.log('Running the code in the sandbox....')
  const execution = await sbx.runCode(aiGeneratedCode)
  console.log('Code execution finished!')
  console.log(execution)
}
```
```python {{ language: 'python', description: 'main.py' }}
# ... code from the previous step

def run_ai_generated_code(ai_generated_code: str):
    print('Running the code in the sandbox....')
    execution = sbx.run_code(ai_generated_code)
    print('Code execution finished!')
    print(execution)
```
</CodeGroup>

### 6. Prepare the prompt and initialize Anthropic client
The prompt we'll be using describes the dataset and the analysis we want to perform like this:
    1. Describe the columns in the CSV dataset.
    2. Ask the LLM what we want to analyze - here we want to analyze the vote average over time. We're asking for a chart as the output.
    3. Instruct the LLM to generate Python code for the data analysis.

<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
import Anthropic from '@anthropic-ai/sdk'

const prompt = `
I have a CSV file about movies. It has about 10k rows. It's saved in the sandbox at ${dataset_path_in_sandbox.path}.
These are the columns:
- 'id': number, id of the movie
- 'original_language': string like "eng", "es", "ko", etc
- 'original_title': string that's name of the movie in the original language
- 'overview': string about the movie
- 'popularity': float, from 0 to 9137.939. It's not normalized at all and there are outliers
- 'release_date': date in the format yyyy-mm-dd
- 'title': string that's the name of the movie in english
- 'vote_average': float number between 0 and 10 that's representing viewers voting average
- 'vote_count': int for how many viewers voted

I want to better understand how the vote average has changed over the years. Write Python code that analyzes the dataset based on my request and produces right chart accordingly`

const anthropic = new Anthropic()
console.log('Waiting for the model response...')
const msg = await anthropic.messages.create({
  model: 'claude-3-5-sonnet-20240620',
  max_tokens: 1024,
  messages: [{ role: 'user', content: prompt }],
})
```

```python {{ language: 'python', description: 'main.py' }}
from anthropic import Anthropic

prompt = '''
I have a CSV file about movies. It has about 10k rows. It's saved in the sandbox at {datasetPathInSandbox.path}.
These are the columns:
- 'id': number, id of the movie
- 'original_language': string like "eng", "es", "ko", etc
- 'original_title': string that's name of the movie in the original language
- 'overview': string about the movie
- 'popularity': float, from 0 to 9137.939. It's not normalized at all and there are outliers
- 'release_date': date in the format yyyy-mm-dd
- 'title': string that's the name of the movie in english
- 'vote_average': float number between 0 and 10 that's representing viewers voting average
- 'vote_count': int for how many viewers voted

I want to better understand how the vote average has changed over the years. Write Python code that analyzes the dataset based on my request and produces right chart accordingly'''

anthropic = Anthropic()
msg = anthropic.messages.create(
  model='claude-3-5-sonnet-20240620',
  max_tokens=1024,
  messages=[
    {"role": "user", "content": prompt}
  ]
)
```
</CodeGroup>

### 7. Connect the sandbox to the LLM with tool calling
We'll use Claude's ability to [use tools (function calling)](https://docs.anthropic.com/en/docs/build-with-claude/tool-use) to run the code in the sandbox.

The way we'll do it is by connecting the method for running AI-generated code we created in the previous step to the Claude model.

Update the initialization of the Anthropic client to include the tool use like this:
<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
const msg = await anthropic.messages.create({
  model: 'claude-3-5-sonnet-20240620',
  max_tokens: 1024,
  messages: [{ role: 'user', content: prompt }],
  tools: [ // $HighlightLine
     { // $HighlightLine
      name: 'run_python_code', // $HighlightLine
      description: 'Run Python code', // $HighlightLine
      input_schema: { // $HighlightLine
        type: 'object', // $HighlightLine
        properties: { // $HighlightLine
          code: { // $HighlightLine
            type: 'string', // $HighlightLine
            description: 'The Python code to run', // $HighlightLine
          }, // $HighlightLine
        }, // $HighlightLine
        required: ['code'], // $HighlightLine
      }, // $HighlightLine
    }, // $HighlightLine
  ], // $HighlightLine
})
```
```python {{ language: 'python', description: 'main.py' }}
msg = anthropic.messages.create(
  model='claude-3-5-sonnet-20240620',
  max_tokens=1024,
  messages=[
    {"role": "user", "content": prompt}
  ],
  tools=[ # $HighlightLine
    { # $HighlightLine
      "name": "run_python_code", # $HighlightLine
      "description": "Run Python code", # $HighlightLine
      "input_schema": { # $HighlightLine
        "type": "object", # $HighlightLine
        "properties": { # $HighlightLine
          "code": { "type": "string", "description": "The Python code to run" }, # $HighlightLine
        }, # $HighlightLine
        "required": ["code"], # $HighlightLine
      }, # $HighlightLine
    }, # $HighlightLine
  ], # $HighlightLine
)
```
</CodeGroup>

### 8. Parse the LLM response and run the AI-generated code in the sandbox
Now we'll parse the `msg` object to get the code from the LLM's response based on the tool we created in the previous step.
Once we have the code, we'll pass it to the `runAIGeneratedCode` method in JavaScript or `run_ai_generated_code` method in Python we created in the previous step to run the code in the sandbox.

<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
// ... code from the previous steps

interface CodeRunToolInput {
  code: string
}

for (const contentBlock of msg.content) {
  if (contentBlock.type === 'tool_use') {
    if (contentBlock.name === 'run_python_code') {
      const code = (contentBlock.input as CodeRunToolInput).code
      console.log('Will run following code in the sandbox', code)
      // Execute the code in the sandbox
      await runAIGeneratedCode(code)
    }
  }
}
```
```python {{ language: 'python', description: 'main.py' }}
for content_block in msg.content:
    if content_block.type == 'tool_use':
        if content_block.name == 'run_python_code':
            code = content_block.input['code']
            print('Will run following code in the sandbox', code)
            # Execute the code in the sandbox
            run_ai_generated_code(code)
```
</CodeGroup>

### 9. Save the generated chart
When running code in the sandbox for data analysis, you can get different types of results.
Including stdout, stderr, charts, tables, text, runtime errors, and more.

In this example we're specifically asking for a chart so we'll be looking for the chart in the results.

Let's update the `runAIGeneratedCode` method in JavaScript and `run_ai_generated_code` method in Python to check for the chart in the results and save it to the file.
<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
async function runAIGeneratedCode(aiGeneratedCode: string) {
  console.log('Running the code in the sandbox....')
  const execution = await sbx.runCode(aiGeneratedCode)
  console.log('Code execution finished!')

  // First let's check if the code ran successfully.
  if (execution.error) { // $HighlightLine
    console.error('AI-generated code had an error.') // $HighlightLine
    console.log(execution.error.name) // $HighlightLine
    console.log(execution.error.value) // $HighlightLine
    console.log(execution.error.traceback) // $HighlightLine
    process.exit(1) // $HighlightLine
  } // $HighlightLine

  // Iterate over all the results and specifically check for png files that will represent the chart.
  let resultIdx = 0 // $HighlightLine
  for (const result of execution.results) { // $HighlightLine
    if (result.png) { // $HighlightLine
      // Save the png to a file
      // The png is in base64 format.
      fs.writeFileSync(`chart-${resultIdx}.png`, result.png, { encoding: 'base64' }) // $HighlightLine
      console.log(`Chart saved to chart-${resultIdx}.png`) // $HighlightLine
      resultIdx++ // $HighlightLine
    } // $HighlightLine
  } // $HighlightLine
}
```
```python {{ language: 'python', description: 'main.py' }}
def run_ai_generated_code(ai_generated_code: str):
    print('Running the code in the sandbox....')
    execution = sbx.run_code(ai_generated_code)
    print('Code execution finished!')

    # First let's check if the code ran successfully.
    if execution.error: # $HighlightLine
        print('AI-generated code had an error.') # $HighlightLine
        print(execution.error.name) # $HighlightLine
        print(execution.error.value) # $HighlightLine
        print(execution.error.traceback) # $HighlightLine
        sys.exit(1) # $HighlightLine

    # Iterate over all the results and specifically check for png files that will represent the chart.
    result_idx = 0 # $HighlightLine
    for result in execution.results: # $HighlightLine
        if result.png: # $HighlightLine
            # Save the png to a file
            # The png is in base64 format.
            with open(f'chart-{result_idx}.png', 'wb') as f: # $HighlightLine
                f.write(base64.b64decode(result.png)) # $HighlightLine
            print(f'Chart saved to chart-{result_idx}.png') # $HighlightLine
            result_idx += 1 # $HighlightLine
```
</CodeGroup>

### 10. Run the code
Now you can run the whole code to see the results.

<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npx tsx index.ts
```
```bash {{ language: 'python' }}
python main.py
```
</CodeGroup>

You should see the chart in the root of your project that will look similar to this:

<Image
  src={imgChart}
  className="rounded w-full"
  alt="Chart visualizing voting average of our dataset over time"
  unoptimized
/>

### Full final code
Check the full code in JavaScript and Python below:
<CodeGroup>
```js {{ language: 'js', description: 'index.ts' }}
import 'dotenv/config'
import fs from 'fs'
import Anthropic from '@anthropic-ai/sdk'
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox
const sbx = await Sandbox.create()

// Upload the dataset to the sandbox
const content = fs.readFileSync('dataset.csv')
const datasetPathInSandbox = await sbx.files.write('/home/user/dataset.csv', content)

async function runAIGeneratedCode(aiGeneratedCode: string) {
  const execution = await sbx.runCode(aiGeneratedCode)
  if (execution.error) {
    console.error('AI-generated code had an error.')
    console.log(execution.error.name)
    console.log(execution.error.value)
    console.log(execution.error.traceback)
    process.exit(1)
  }
  // Iterate over all the results and specifically check for png files that will represent the chart.
  let resultIdx = 0
  for (const result of execution.results) {
    if (result.png) {
      // Save the png to a file
      // The png is in base64 format.
      fs.writeFileSync(`chart-${resultIdx}.png`, result.png, { encoding: 'base64' })
      console.log('Chart saved to chart-${resultIdx}.png')
      resultIdx++
    }
  }
}

const prompt = `
I have a CSV file about movies. It has about 10k rows. It's saved in the sandbox at ${datasetPathInSandbox.path}.
These are the columns:
- 'id': number, id of the movie
- 'original_language': string like "eng", "es", "ko", etc
- 'original_title': string that's name of the movie in the original language
- 'overview': string about the movie
- 'popularity': float, from 0 to 9137.939. It's not normalized at all and there are outliers
- 'release_date': date in the format yyyy-mm-dd
- 'title': string that's the name of the movie in english
- 'vote_average': float number between 0 and 10 that's representing viewers voting average
- 'vote_count': int for how many viewers voted

I want to better understand how the vote average has changed over the years. Write Python code that analyzes the dataset based on my request and produces right chart accordingly`

const anthropic = new Anthropic()
console.log('Waiting for the model response...')
const msg = await anthropic.messages.create({
  model: 'claude-3-5-sonnet-20240620',
  max_tokens: 1024,
  messages: [{ role: 'user', content: prompt }],
  tools: [
    {
      name: 'run_python_code',
      description: 'Run Python code',
      input_schema: {
        type: 'object',
        properties: {
          code: {
            type: 'string',
            description: 'The Python code to run',
          },
        },
        required: ['code'],
      },
    },
  ],
})

interface CodeRunToolInput {
  code: string
}

for (const contentBlock of msg.content) {
  if (contentBlock.type === 'tool_use') {
    if (contentBlock.name === 'run_python_code') {
      const code = (contentBlock.input as CodeRunToolInput).code
      console.log('Will run following code in the sandbox', code)
      // Execute the code in the sandbox
      await runAIGeneratedCode(code)
    }
  }
}
```
```python {{ language: 'python', description: 'main.py' }}
import sys
import base64
from dotenv import load_dotenv
load_dotenv()
from e2b_code_interpreter import Sandbox
from anthropic import Anthropic

# Create sandbox
sbx = Sandbox()

# Upload the dataset to the sandbox
with open("../dataset.csv", "rb") as f:
    dataset_path_in_sandbox = sbx.files.write("dataset.csv", f)


def run_ai_generated_code(ai_generated_code: str):
    print('Running the code in the sandbox....')
    execution = sbx.run_code(ai_generated_code)
    print('Code execution finished!')

    # First let's check if the code ran successfully.
    if execution.error:
        print('AI-generated code had an error.')
        print(execution.error.name)
        print(execution.error.value)
        print(execution.error.traceback)
        sys.exit(1)

    # Iterate over all the results and specifically check for png files that will represent the chart.
    result_idx = 0
    for result in execution.results:
        if result.png:
            # Save the png to a file
            # The png is in base64 format.
            with open(f'chart-{result_idx}.png', 'wb') as f:
                f.write(base64.b64decode(result.png))
            print(f'Chart saved to chart-{result_idx}.png')
            result_idx += 1

prompt = f"""
I have a CSV file about movies. It has about 10k rows. It's saved in the sandbox at {dataset_path_in_sandbox.path}.
These are the columns:
- 'id': number, id of the movie
- 'original_language': string like "eng", "es", "ko", etc
- 'original_title': string that's name of the movie in the original language
- 'overview': string about the movie
- 'popularity': float, from 0 to 9137.939. It's not normalized at all and there are outliers
- 'release_date': date in the format yyyy-mm-dd
- 'title': string that's the name of the movie in english
- 'vote_average': float number between 0 and 10 that's representing viewers voting average
- 'vote_count': int for how many viewers voted

I want to better understand how the vote average has changed over the years.
Write Python code that analyzes the dataset based on my request and produces right chart accordingly"""

anthropic = Anthropic()
print("Waiting for model response...")
msg = anthropic.messages.create(
  model='claude-3-5-sonnet-20240620',
  max_tokens=1024,
  messages=[
    {"role": "user", "content": prompt}
  ],
  tools=[
    {
      "name": "run_python_code",
      "description": "Run Python code",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": { "type": "string", "description": "The Python code to run" },
        },
        "required": ["code"]
      }
    }
  ]
)

for content_block in msg.content:
    if content_block.type == "tool_use":
        if content_block.name == "run_python_code":
            code = content_block.input["code"]
            print("Will run following code in the sandbox", code)
            # Execute the code in the sandbox
            run_ai_generated_code(code)

```
</CodeGroup>


# Pre-installed libraries
The sandbox comes with a [set of pre-installed Python libraries](https://github.com/e2b-dev/code-interpreter/blob/main/template/requirements.txt) for data analysis
but you can [install additional packages](/docs/quickstart/install-custom-packages):
- `aiohttp` (v3.9.3)
- `beautifulsoup4` (v4.12.3)
- `bokeh` (v3.3.4)
- `gensim` (v4.3.2)
- `imageio` (v2.34.0)
- `joblib` (v1.3.2)
- `librosa` (v0.10.1)
- `matplotlib` (v3.8.3)
- `nltk` (v3.8.1)
- `numpy` (v1.26.4)
- `opencv-python` (v4.9.0.80)
- `openpyxl` (v3.1.2)
- `pandas` (v1.5.3)
- `plotly` (v5.19.0)
- `pytest` (v8.1.0)
- `python`-docx (v1.1.0)
- `pytz` (v2024.1)
- `requests` (v2.26.0)
- `scikit-image` (v0.22.0)
- `scikit-learn` (v1.4.1.post1)
- `scipy` (v1.12.0)
- `seaborn` (v0.13.2)
- `soundfile` (v0.12.1)
- `spacy` (v3.7.4)
- `textblob` (v0.18.0)
- `tornado` (v6.4)
- `urllib3` (v1.26.7)
- `xarray` (v2024.2.0)
- `xlrd` (v2.0.1)
- `sympy` (v1.12)


# Interactive charts

E2B also allows you to create interactive charts with custom styling.

E2B automatically detects charts when executing Python code with `runCode()` in JavaScript or `run_code()` in Python. The Python code must include Matplotlib charts.

When a chart is detected, E2B sends the data of the chart back to the client. You can access the chart in the `execution.results` array where each item is a `Result` object with the `chart` property.

<Note>
Try out [AI Data Analyst](https://github.com/e2b-dev/ai-analyst/) - a Next.js app that uses E2B to create interactive charts.
</Note>

Here's a simple example of bar chart:
<CodeGroup>
```js
import { Sandbox, BarChart } from '@e2b/code-interpreter'

const code = `
import matplotlib.pyplot as plt

# Prepare data
authors = ['Author A', 'Author B', 'Author C', 'Author D']
sales = [100, 200, 300, 400]

# Create and customize the bar chart
plt.figure(figsize=(10, 6))
plt.bar(authors, sales, label='Books Sold', color='blue')
plt.xlabel('Authors')
plt.ylabel('Number of Books Sold')
plt.title('Book Sales by Authors')

# Display the chart
plt.tight_layout()
plt.show()
`

const sandbox = await Sandbox.create()
const result = await sandbox.runCode(code)
const chart = result.results[0].chart as BarChart

console.log('Type:', chart.type)
console.log('Title:', chart.title)
console.log('X Label:', chart.x_label)
console.log('Y Label:', chart.y_label)
console.log('X Unit:', chart.x_unit)
console.log('Y Unit:', chart.y_unit)
console.log('Elements:', chart.elements)
```
```python
from e2b_code_interpreter import Sandbox

code = """
import matplotlib.pyplot as plt

# Prepare data
authors = ['Author A', 'Author B', 'Author C', 'Author D']
sales = [100, 200, 300, 400]

# Create and customize the bar char
plt.figure(figsize=(10, 6))
plt.bar(authors, sales, label='Books Sold', color='blue')
plt.xlabel('Authors')
plt.ylabel('Number of Books Sold')
plt.title('Book Sales by Authors')

# Display the chart
plt.tight_layout()
plt.show()
"""

sandbox = Sandbox()
execution = sandbox.run_code(code)
chart = execution.results[0].chart

print('Type:', chart.type)
print('Title:', chart.title)
print('X Label:', chart.x_label)
print('Y Label:', chart.y_label)
print('X Unit:', chart.x_unit)
print('Y Unit:', chart.y_unit)
print('Elements:')
for element in chart.elements:
    print('\n  Label:', element.label)
    print('  Value:', element.value)
    print('  Group:', element.group)
```
</CodeGroup>


The code above will output the following:
<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
Type: bar
Title: Book Sales by Authors
X Label: Authors
Y Label: Number of Books Sold
X Unit: null
Y Unit: null
Elements: [
  {
    label: "Author A",
    group: "Books Sold",
    value: 100,
  }, {
    label: "Author B",
    group: "Books Sold",
    value: 200,
  }, {
    label: "Author C",
    group: "Books Sold",
    value: 300,
  }, {
    label: "Author D",
    group: "Books Sold",
    value: 400,
  }
]
```
```bash {{ language: 'python' }}
Type: ChartType.BAR
Title: Book Sales by Authors
X Label: Authors
Y Label: Number of Books Sold
X Unit: None
Y Unit: None
Elements:

  Label: Author A
  Value: 100.0
  Group: Books Sold

  Label: Author B
  Value: 200.0
  Group: Books Sold

  Label: Author C
  Value: 300.0
  Group: Books Sold

  Label: Author D
  Value: 400.0
  Group: Books Sold
```
</CodeGroup>

You can send this data to your frontend to create an interactive chart with your favorite charting library.

---

## Supported intertactive charts
The following charts are currently supported:
- Line chart
- Bar chart
- Scatter plot
- Pie chart
- Box and whisker plot


{/* The following charts are currently supported:
- [Line chart](#line-chart)
- [Bar chart](#bar-chart)
- [Scatter plot](#scatter-plot)
- [Pie chart](#pie-chart)
- [Box and whisker plot](#box-and-whisker-plot)


## Line chart

## Bar chart

## Scatter plot

## Pie chart

## Box and whisker plot */}

# Create charts & visualizations
E2B Sandbox allows you to create charts and visualizations by executing Python code inside the sandbox with `runCode()` method in JavaScript and `run_code()` method in Python.

These charts and visualizations can be [static](/docs/code-interpreting/create-charts-visualizations/static-charts) or [interactive](/docs/code-interpreting/create-charts-visualizations/interactive-charts) plots.

{/* <Note>
Learn more about different types of results that E2B Sandbox can return [(TODO: link)here](/docs/code-interpreting/results).
</Note> */}



import Image from 'next/image'
import imgStaticChart from '@/images/static-chart.png'

# Static charts

Every time you run Python code with `runCode()` in JavaScript or `run_code()` method in Python, the code is executed in a headless Jupyter server inside the sandbox.

E2B automatically detects any plots created with Matplotlib and sends them back to the client as images encoded in the base64 format.
These images are directly accesible on the `result` items in the `execution.results` array.

Here's how to retrieve a static chart from the executed Python code that contains a Matplotlib plot.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
import fs from 'fs'

const codeToRun = `
import matplotlib.pyplot as plt

plt.plot([1, 2, 3, 4])
plt.ylabel('some numbers')
plt.show()
`
const sandbox = await Sandbox.create()

// Run the code inside the sandbox
const execution = await sandbox.runCode(codeToRun)

 // There's only one result in this case - the plot displayed with `plt.show()`
const firstResult = execution.results[0]

if (firstResult.png) {
  // Save the png to a file. The png is in base64 format.
  fs.writeFileSync('chart.png', firstResult.png, { encoding: 'base64' })
  console.log('Chart saved as chart.png')
}
```
```python
import base64
from e2b_code_interpreter import Sandbox

code_to_run = """
import matplotlib.pyplot as plt

plt.plot([1, 2, 3, 4])
plt.ylabel('some numbers')
plt.show()
"""

sandbox = Sandbox()

# Run the code inside the sandbox
execution = sandbox.run_code(code_to_run)

# There's only one result in this case - the plot displayed with `plt.show()`
first_result = execution.results[0]

if first_result.png:
  # Save the png to a file. The png is in base64 format.
  with open('chart.png', 'wb') as f:
    f.write(base64.b64decode(first_result.png))
  print('Chart saved as chart.png')
```
</CodeGroup>

The code in the variable `codeToRun`/`code_to_run` will produce this following plot that we're saving as `chart.png` file.
<Image
  src={imgStaticChart}
  className="rounded w-full"
  alt="Static chart produced by the code"
  unoptimized
/>

# Streaming

Use E2B SDK allows you to stream the output, and results when executing code in the sandbox.


## Stream `stdout` and `stderr`
When using the `runCode()` method in JavaScript or `run_code()` in Python you can pass `onStdout`/`on_stdout` and `onStderr`/`on_stderr` callbacks to handle the output.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const codeToRun = `
  import time
  import sys
  print("This goes first to stdout")
  time.sleep(3)
  print("This goes later to stderr", file=sys.stderr)
  time.sleep(3)
  print("This goes last")
`
const sandbox = await Sandbox.create()
sandbox.runCode(codeToRun, {
  // Use `onError` to handle runtime code errors
  onError: error => console.error('error:', error), // $HighlightLine
  onStdout: data => console.log('stdout:', data), // $HighlightLine
  onStderr: data => console.error('stderr:', data), // $HighlightLine
})
```
```python
from e2b_code_interpreter import Sandbox

code_to_run = """
  import time
  import sys
  print("This goes first to stdout")
  time.sleep(3)
  print("This goes later to stderr", file=sys.stderr)
  time.sleep(3)
  print("This goes last")
"""

sandbox = Sandbox()
sandbox.run_code(
  code_to_run,
  # Use `on_error` to handle runtime code errors
  on_error=lambda error: print('error:', error), # $HighlightLine
  on_stdout=lambda data: print('stdout:', data), # $HighlightLine
  on_stderr=lambda data: print('stderr:', data), # $HighlightLine
)
```
</CodeGroup>

The code above will print the following:

<CodeGroup>
```javascript {{ language: 'javascript' }}
stdout: {
  error: false,
  line: "This goes first to stdout\n",
  timestamp: 1729049666861000,
}
stderr: {
  error: true,
  line: "This goes later to stderr\n",
  timestamp: 1729049669924000,
}
stdout: {
  error: false,
  line: "This goes last\n",
  timestamp: 1729049672664000,
}
```
```bash {{ language: 'python' }}
stdout: This goes first to stdout

stderr: This goes later to stderr

stdout: This goes last

```
</CodeGroup>

## Stream `results`

When using the `runCode()` method in JavaScript or `run_code()` in Python you can pass `onResults`/`on_results` callback
to receive results from the sandbox like charts, tables, text, and more.

<CodeGroup>
```js
const codeToRun = `
import matplotlib.pyplot as plt

# Prepare data
categories = ['Category A', 'Category B', 'Category C', 'Category D']
values = [10, 20, 15, 25]

# Create and customize the bar chart
plt.figure(figsize=(10, 6))
plt.bar(categories, values, color='green')
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Values by Category')

# Display the chart
plt.show()
`
const sandbox = await Sandbox.create()
await sandbox.runCode(codeToRun, {
  onResult: result => console.log('result:', result), // $HighlightLine
})
```
```python
from e2b_code_interpreter import Sandbox

code_to_run = """
import matplotlib.pyplot as plt

# Prepare data
categories = ['Category A', 'Category B', 'Category C', 'Category D']
values = [10, 20, 15, 25]

# Create and customize the bar chart
plt.figure(figsize=(10, 6))
plt.bar(categories, values, color='green')
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Values by Category')

# Display the chart
plt.show()
"""

sandbox = Sandbox()
sandbox.run_code(
  code_to_run,
  on_result=lambda result: print('result:', result), # $HighlightLine
)
```
</CodeGroup>


# Run bash code
Use the `runCode`/`run_code` method to run bash code inside the sandbox.
You'll need to pass the `language` parameter with value `bash`.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
const execution = await sbx.runCode('echo "Hello, world!"', { language: 'bash' })
console.log(execution)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
execution = sbx.run_code("echo 'Hello, world!'", language="bash")
print(execution)
```
</CodeGroup>

# Run Java code
Use the `runCode`/`run_code` method to run Java code inside the sandbox.
You'll need to pass the `language` parameter with value `java`.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
const execution = await sbx.runCode('System.out.println("Hello, world!");', { language: 'java' })
console.log(execution)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
execution = sbx.run_code('System.out.println("Hello, world!");', language="java")
print(execution)
```
</CodeGroup>

# Run JavaScript code
Use the `runCode`/`run_code` method to run JavaScript code inside the sandbox.
You'll need to pass the `language` parameter with value `javascript` or `js`.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
const execution = await sbx.runCode('console.log("Hello, world!")', { language: 'js' })
console.log(execution)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
execution = sbx.run_code('console.log("Hello, world!")', language="js")
print(execution)
```
</CodeGroup>

# Supported languages

Typically you use Python to run AI-generated code for data analysis but you can use other languages as well.

Out of the box E2B Sandbox supports:
- [Python](/docs/code-interpreting/supported-languages/python)
- [JavaScript](/docs/code-interpreting/supported-languages/javascript)
- [R](/docs/code-interpreting/supported-languages/r)
- [Java](/docs/code-interpreting/supported-languages/java)
- [Bash](/docs/code-interpreting/supported-languages/bash)

<Note>
You can use any custom language runtime by creating a [custom sandbox template](/docs/sandbox-template).
</Note>


# Run Python code
Use the `runCode`/`run_code` method to run Python code inside the sandbox.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
const execution = await sbx.runCode('print("Hello, world!")')
console.log(execution)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
execution = sbx.run_code('print("Hello, world!")')
print(execution)
```
</CodeGroup>

## Run R code
Use the `runCode`/`run_code` method to run R code inside the sandbox.
You'll need to pass the `language` parameter with value `r`.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
const execution = await sbx.runCode('print("Hello, world!")', { language: 'r' })
console.log(execution)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
execution = sbx.run_code('print("Hello, world!")', language="r")
print(execution)
```
</CodeGroup>

# Running commands in background

To run commands in background, pass the `background` option to the `commands.run()` method. This will return immediately and the command will continue to run in the sandbox.
You can then later kill the command using the `commands.kill()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// Start the command in the background
const command = await sandbox.commands.run('echo hello; sleep 10; echo world', {
  background: true, // $HighlightLine
  onStdout: (data) => {
    console.log(data)
  },
})

// Kill the command
await command.kill()
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

# Start the command in the background
command = sandbox.commands.run('echo hello; sleep 10; echo world', background=True)

# Get stdout and stderr from the command running in the background.
# You can run this code in a separate thread or use command.wait() to wait for the command to finish.
for stdout, stderr, _ in command:
    if stdout:
        print(stdout)
    if stderr:
        print(stderr)

# Kill the command
command.kill()
```
</CodeGroup>


# Running commands in sandbox

You can run terminal commands inside the sandbox using the `commands.run()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()
const result = await sandbox.commands.run('ls -l')
console.log(result)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

result = sandbox.commands.run('ls -l')
print(result)
```
</CodeGroup>


# Streaming command output

To stream command output as it is being executed, pass the `onStdout`, `onStderr` callbacks to the `commands.run()` method in JavaScript
or the `on_stdout`, `on_stderr` callbacks to the `commands.run()` method in Python.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()
const result = await sandbox.commands.run('echo hello; sleep 1; echo world', {
  onStdout: (data) => {
    console.log(data)
  },
  onStderr: (data) => {
    console.log(data)
  },
})
console.log(result)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

result = sandbox.commands.run('echo hello; sleep 1; echo world', on_stdout=lambda data: print(data), on_stderr=lambda data: print(data))
print(result)
```
</CodeGroup>


# Download data from sandbox

You can download data from the sandbox using the `files.read()` method.

<CodeGroup>
```js
import fs from 'fs'
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// Read file from sandbox
const content = await sandbox.files.read('/path/in/sandbox')
// Write file to local filesystem
fs.writeFileSync('/local/path', content)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

# Read file from sandbox
content = sandbox.files.read('/path/in/sandbox')
# Write file to local filesystem
with open('/local/path', 'w') as file:
  file.write(content)
```
</CodeGroup>


# Filesystem

Each E2B Sandbox has its own isolated filesystem. The [Hobby tier](https://e2b.dev/pricing) sandboxes come with 1 GB of the free disk space and [Pro tier](https://e2b.dev/pricing) sandboxes come with 5 GB.

With E2B SDK you can:
- [Read and write files to the sandbox.](/docs/filesystem/read-write)
- [Watch directory for changes.](/docs/filesystem/watch)
- [Upload data to the sandbox.](/docs/filesystem/upload)
- [Download data from the sandbox.](/docs/filesystem/download)



# Read & write files

## Reading files

You can read files from the sandbox filesystem using the `files.read()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
const sandbox = await Sandbox.create()
const fileContent = await sandbox.files.read('/path/to/file')
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()
file_content = sandbox.files.read('/path/to/file')
```
</CodeGroup>

## Writing single files

You can write single files to the sandbox filesystem using the `files.write()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
const sandbox = await Sandbox.create()

await sandbox.files.write('/path/to/file', 'file content')
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

await sandbox.files.write('/path/to/file', 'file content')
```
</CodeGroup>

## Writing multiple files

You can also write multiple files to the sandbox filesystem using the `files.write()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
const sandbox = await Sandbox.create()

await sandbox.files.write([
    { path: '/path/to/a', data: 'file content' },
    { path: '/another/path/to/b', data: 'file content' }
])
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

await sandbox.files.write([
    { "path": "/path/to/a", "data": "file content" },
    { "path": "another/path/to/b", "data": "file content" }
])
```
</CodeGroup>

# Upload data to sandbox

You can upload data to the sandbox using the `files.write()` method.

## Upload single file

<CodeGroup>
```js
import fs from 'fs'
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// Read file from local filesystem
const content = fs.readFileSync('/local/path')
// Upload file to sandbox
await sandbox.files.write('/path/in/sandbox', content)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

# Read file from local filesystem
with open("path/to/local/file", "rb") as file:
  # Upload file to sandbox
  sandbox.files.write("/path/in/sandbox", file)
```
</CodeGroup>

## Upload directory / multiple files

<CodeGroup>
```js
const fs = require('fs');
const path = require('path');

import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// Read all files in the directory and store their paths and contents in an array
const readDirectoryFiles = (directoryPath) => {
  // Read all files in the local directory
  const files = fs.readdirSync(directoryPath);

  // Map files to objects with path and data
  const filesArray = files
    .filter(file => {
      const fullPath = path.join(directoryPath, file);
      // Skip if it's a directory
      return fs.statSync(fullPath).isFile();
    })
    .map(file => {
      const filePath = path.join(directoryPath, file);
    
      // Read the content of each file
      return {
        path: filePath,
        data: fs.readFileSync(filePath, 'utf8')
      };
    });

  return filesArray;
};

// Usage example
const files = readDirectoryContents('/local/dir');
console.log(files); 
// [
//   { path: '/local/dir/file1.txt', data: 'File 1 contents...' },
//   { path: '/local/dir/file2.txt', data: 'File 2 contents...' },
//   ...
// ]

await sandbox.files.write(files)
```
```python
import os
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

def read_directory_files(directory_path):
    files = []
    
    # Iterate through all files in the directory
    for filename in os.listdir(directory_path):
        file_path = os.path.join(directory_path, filename)
        
        # Skip if it's a directory
        if os.path.isfile(file_path):
            # Read file contents in binary mode
            with open(file_path, "rb") as file:
                files.append({
                    'path': file_path,
                    'data': file.read()
                })
    
    return files

files = read_directory_files("/local/dir")
print(files)
# [
#  {"'path": "/local/dir/file1.txt", "data": "File 1 contents..." },
#   { "path": "/local/dir/file2.txt", "data": "File 2 contents..." },
#   ...
# ]

sandbox.files.write(files)
```
</CodeGroup>

# Watch sandbox directory for changes

You can watch a directory for changes using the `files.watchDir()` method in JavaScript and `files.watch_dir()` method in Python.

<CodeGroup>
```js
import { Sandbox, FilesystemEventType } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()
const dirname = '/home/user'

// Start watching directory for changes
const handle = await sandbox.files.watchDir(dirname, async (event) => { // $HighlightLine
  console.log(event) // $HighlightLine
  if (event.type === FilesystemEventType.WRITE) { // $HighlightLine
    console.log(`wrote to file ${event.name}`) // $HighlightLine
  } // $HighlightLine
}) // $HighlightLine

// Trigger file write event
await sandbox.files.write(`${dirname}/my-file`, 'hello')
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()
dirname = '/home/user'

# Watch directory for changes
handle = sandbox.files.watch_dir(dirname) # $HighlightLine
# Trigger file write event
sandbox.files.write(f"{dirname}/my-file", "hello")

# Retrieve the latest new events since the last `get_new_events()` call
events = handle.get_new_events() # $HighlightLine
for event in events: # $HighlightLine
  print(event) # $HighlightLine
  if event.type == FilesystemEventType.Write: # $HighlightLine
    print(f"wrote to file {event.name}") # $HighlightLine
```
</CodeGroup>


## Recursive Watching

You can enable recursive watching using the parameter `recursive`.

<Note>
When rapidly creating new folders (e.g., deeply nested path of folders), events other than `CREATE` might not be emitted. To avoid this behavior, create the required folder structure in advance.
</Note>

<CodeGroup>
```js
import { Sandbox, FilesystemEventType } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()
const dirname = '/home/user'

// Start watching directory for changes
const handle = await sandbox.files.watchDir(dirname, async (event) => {
  console.log(event)
  if (event.type === FilesystemEventType.WRITE) {
    console.log(`wrote to file ${event.name}`)
  }
}, {
  recursive: true // $HighlightLine
})

// Trigger file write event
await sandbox.files.write(`${dirname}/my-folder/my-file`, 'hello') // $HighlightLine
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()
dirname = '/home/user'

# Watch directory for changes
handle = sandbox.files.watch_dir(dirname, recursive=True) # $HighlightLine
# Trigger file write event
sandbox.files.write(f"{dirname}/my-folder/my-file", "hello") # $HighlightLine

# Retrieve the latest new events since the last `get_new_events()` call
events = handle.get_new_events()
for event in events:
  print(event)
  if event.type == FilesystemEventType.Write:
    print(f"wrote to file {event.name}")
```
</CodeGroup>


# CLI Commands

Build your sandbox with our CLI. {{ className: 'lead' }}

<Note>
You can use `--help` flag for more information about commands.
</Note>

---

# Auth

<br/>

## `auth login`

Log in to the CLI. It will save your access token in `~/.e2b` file.

```bash
e2b auth login
```

## `auth logout`

Log out of the CLI. It will remove your access token from `~/.e2b` file.

```
e2b auth logout
```

## `auth configure`

Configure the default team for the CLI. It will be used for all commands that require a team.

```bash
e2b auth configure
```

## `auth info`

Get info about your current user.

```
e2b auth info
```

---

# Templates

<br/>

## `template init`

Creates a basic Dockerfile (`./e2b.Dockerfile`) in current directory.
You can then run `e2b template build` to build sandbox template from this Dockerfile.

```bash
e2b template init
```

#### **Options**

<Options>
  <Option name="path" type="-p, --path">
    Change the root directory where the command is executed to `path` directory.
  </Option>
</Options>


## `template build`

Builds a sandbox template defined by `./e2b.Dockerfile` or `./Dockerfile` from the root directory.
By default, the root directory is the current working directory.
This command also creates the `e2b.toml` config.

```bash
e2b template build
```

<Note>
Running `e2b template build` without specifying a template with the `[template]` argument will rebuild template defined by the `e2b.toml` config.

If there is no `e2b.toml` config a new template will be created.
</Note>

#### **Arguments**

<Options>
  <Option type="[template]">
    Specify the template you want to rebuild. You can use the template name or ID.
  </Option>
</Options>


#### **Options**

<Options>
  <Option type="-c, --cmd" name="start-command">
    Specify the command that should be running when a sandbox starts.
  </Option>
  <Option type="--config" name="e2b-toml">
    Specify the path to the config file. By default, E2B tries to find `e2b.toml` in the root directory.
  </Option>
  <Option type="-n, --name" name="template-name">
    Specify the name of the sandbox template. You can use the template name to start the sandbox in the SDK. The name must be lowercase and contain only letters, numbers, dashes, and underscores.
  </Option>
  <Option type="-p, --path" name="path">
    Change the root directory where the command is executed to the `path` directory.
  </Option>
  <Option type="-d, --dockerfile" name="dockerfile">
    Specify the path to Dockerfile. By default E2B tries to find `e2b.Dockerfile` or `Dockerfile` in the root directory.
  </Option>
  <Option type="-t, --team" name="team">
    Specify the team that will be used for the sandbox template. You can find team ID in the team settings in the [E2B dashboard](https://e2b.dev/dashboard?tab=team).
  </Option>
  <Option type="--cpu-count" name="cpu-count">
    Specify the number of CPUs that will be used to run the sandbox. The default value is 2.
  </Option>
  <Option type="--memory-mb" name="memory-mb">
    Specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512.
  </Option>
  <Option type="--build-arg" name="build-arg">
    Specify a build argument for the Dockerfile. The format is `key=value`. You can use this option multiple times.
  </Option>
</Options>

## `template delete`

Delete the sandbox template specified by the `[template]` argument, `e2b.toml` config in the working directory, or by an interactive selection.
By default, the root directory is the current working directory.

This command also deletes the `e2b.toml` config.

```bash
e2b template delete
```

<Note>
Running `e2b template delete` without specifying a template with the `[template]` argument will delete the template defined by the `e2b.toml` config.
</Note>

#### **Arguments**

<Options>
  <Option type="[template]">
    Specify the template you want to delete. You can use the template name or ID.
  </Option>
</Options>


#### **Options**

<Options>
  <Option type="-p, --path" name="path">
    Change the root directory where the command is executed to the `path` directory.
  </Option>
  <Option type="--config" name="e2b-toml">
    Specify the path to the config file. By default, E2B tries to find `e2b.toml` in the root directory.
  </Option>
  <Option type="-s, --select">
    Interactively select sandbox templates you want to delete.
  </Option>
  <Option type="-y, --yes">
    Don't ask for confirmation before deleting the sandbox template.
  </Option>
  <Option type="-t, --team" name="team">
    Specify the team that will be used for the sandbox template. You can find team ID in the team settings in the [E2B dashboard](https://e2b.dev/dashboard?tab=team).
  </Option>
</Options>


## `template list`

List your sandbox templates.

```bash
e2b template list
```

#### **Options**

<Options>
  <Option type="-t, --team" name="team">
    Specify the team that will be used for the sandbox template. You can find team ID in the team settings in the [E2B dashboard](https://e2b.dev/dashboard?tab=team).
  </Option>
</Options>


---

# Sandboxes

<br/>

## `sandbox list`

List your spawned sandboxes that are running right now.

```bash
e2b sandbox list
```


## `sandbox logs`
Starts printing logs from the specified sandbox.
If the sandbox is running new logs will be streamed to the terminal.

The timestamps are in the UTC format.

This command is useful if you need to debug a running sandbox or check logs from a sandbox that was already closed.

```bash
e2b sandbox logs <sandboxID>
```

<Note>
You can use `e2b sandbox list` to get a list of running sandboxes and their IDs that can be used with `e2b sandbox logs <sandboxID>` command.
</Note>

#### **Arguments**

<Options>
  <Option type="<sandboxID>">
    Specify the ID of the sandbox you want to get logs from.
  </Option>
</Options>

#### **Options**

<Options>
  <Option name="level" type="--level">
    Filter logs by level — allowed values are `DEBUG`, `INFO`, `WARN`, `ERROR`.
     The logs with the higher levels will be also shown.

    Default value is `DEBUG`.
  </Option>
  <Option type="-f, --follow">
    Enable streaming logs until the sandbox is closed.
  </Option>
  <Option name="format" type="--format">
    Specify format for printing logs — allowed values are `pretty`, `json`.

    Default value is `pretty`.
  </Option>
  <Option name="loggers" type="--loggers">
    Specify enabled loggers — allowed values are `process`, `filesystem`, `terminal`, `network` and `file`.
    You can specify multiple loggers by separating them with a comma.

    Default value is `process,filesystem`.
  </Option>
</Options>

## `sandbox connect`

Connects your terminal to a running sandbox that you spawned via the E2B SDK.
This command is useful if you need to debug a running sandbox.

This command works similar to the `docker exec -it <container> bash` command in Docker.

```bash
e2b sandbox connect <sandboxID>
```

<Note>
You can use `e2b sandbox list` to get a list of running sandboxes and their IDs that can be used with `e2b sandbox connect <sandboxID>` command.
</Note>

#### **Arguments**

<Options>
  <Option type="<sandboxID>">
    Specify the ID of a running sandbox you want to connect to.
  </Option>
</Options>

## `sandbox spawn`

Spawns a sandbox and connects your terminal to the sandbox.
This command can be used to debug your sandbox template.

This command works similar to the `docker run -it <image> bash` command in Docker.

```bash
e2b sandbox spawn
```

<Note>
Running `e2b sandbox spawn` without specifying a template with the `[template]` argument will spawn sandbox defined by the `e2b.toml` config.
</Note>

#### **Arguments**

<Options>
  <Option type="[template]">
    Specify the template you want to spawn sandbox from. You can use the template name or ID.
  </Option>
</Options>


#### **Options**

<Options>
  <Option name="path" type="-p, --path">
    Change the root directory where the command is executed to `path` directory.
  </Option>
  <Option type="--config" name="e2b-toml">
    Specify the path to the config file. By default, E2B tries to find `e2b.toml` in the root directory.
  </Option>
</Options>

## `sandbox kill`

Immediately kill a running sandbox.

```bash
e2b sandbox kill <sandboxID>
```


# Installation

You build and manage sandbox templates with our CLI. {{ className: 'lead' }}

The CLI is distributed as an [NPM package](https://www.npmjs.com/package/e2b).

## Download CLI

You can install the CLI with following command:

```bash
npm install -g @e2b/cli@latest
```

## Login

You'll need to login to your account to start using the CLI.
You'll be redirected to the browser after running the following command to finish the login.

```bash
e2b auth login
```

# Examples

Here are some examples of how to use the E2B Code Interpreter package. If you are missing something, please let us know.

## Minimal example with the sharing context

The following example demonstrates how to create a shared context between multiple code executions. This is useful when you want to share variables between different code cells.

<CodeGroup isRunnable={false}>
```js
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create()
await sandbox.notebook.execCell('x = 1')

const execution = await sandbox.notebook.execCell('x+=1; x')
console.log(execution.text)  // outputs 2

await sandbox.close()
```
```python
from e2b_code_interpreter import CodeInterpreter

with CodeInterpreter() as sandbox:
    sandbox.notebook.exec_cell("x = 1")

    execution = sandbox.notebook.exec_cell("x+=1; x")
    print(execution.text)  # outputs 2

```
</CodeGroup>

## Get charts and any display-able data

<CodeGroup isRunnable={false}>
```js
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create()

const code = `
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 20, 100)
y = np.sin(x)

plt.plot(x, y)
plt.show()
`;

// you can install dependencies in "jupyter notebook style"
await sandbox.notebook.execCell("!pip install matplotlib")

const execution = await sandbox.notebook.execCell(code)

// this contains the image data, you can e.g. save it to file or send to frontend
execution.results[0].png

await sandbox.close()
```
```python
import base64
import io

from matplotlib import image as mpimg, pyplot as plt

from e2b_code_interpreter import CodeInterpreter

code = """
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 20, 100)
y = np.sin(x)

plt.plot(x, y)
plt.show()
"""

with CodeInterpreter() as sandbox:
    # you can install dependencies in "jupyter notebook style"
    sandbox.notebook.exec_cell("!pip install matplotlib")

    # plot random graph
    execution = sandbox.notebook.exec_cell(code)

# there's your image
image = execution.results[0].png

# example how to show the image / prove it works
i = base64.b64decode(image)
i = io.BytesIO(i)
i = mpimg.imread(i, format='PNG')

plt.imshow(i, interpolation='nearest')
plt.show()
```
</CodeGroup>

## Streaming code output

<CodeGroup isRunnable={false}>
```js
import { CodeInterpreter } from "@e2b/code-interpreter";

code = `
import time
import pandas as pd

print("hello")
time.sleep(3)
data = pd.DataFrame(data=[[1, 2], [3, 4]], columns=["A", "B"])
display(data.head(10))
time.sleep(3)
print("world")
`

const sandbox = await CodeInterpreter.create()

await sandbox.notebook.execCell(code, {
  onStdout: (out) => console.log(out),
  onStderr: (outErr) => console.error(outErr),
  onResult: (result) => console.log(result.text)
})
````
```python
from e2b_code_interpreter import CodeInterpreter

code = """
import time
import pandas as pd

print("hello")
time.sleep(3)
data = pd.DataFrame(data=[[1, 2], [3, 4]], columns=["A", "B"])
display(data.head(10))
time.sleep(3)
print("world")
"""
with CodeInterpreter() as sandbox:
    sandbox.notebook.exec_cell(code, on_stdout=print, on_stderr=print, on_result=(lambda result: print(result.text)))
```
</ CodeGroup>


import Link from 'next/link'

# Code Execution

You can execute code using the notebook module, using the `execCell` method. The method takes a string of code as an argument and returns an object with the results of the execution.

<CodeGroup isRunnable={false}>
```js
import { CodeInterpreter } from '@e2b/code-interpreter'

const code = 'print("Hello, World!")'

const sandbox = CodeInterpreter.create()
const execution = await sandbox.notebook.execCell(code)
```

```python
from e2b_code_interpreter import CodeInterpreter

code = "print('Hello, World!')"

sandbox = CodeInterpreter.create()
execution = sandbox.notebook.exec_cell(code)
```
</CodeGroup>

The `execCell` method also accepts following optional arguments:
- `kernel id`: The ID of the kernel to execute the code on. If not provided, the default kernel is used. See <Link href="/code-interpreter/kernels">here</Link> for more info on kernels.
- `on stdout`: A callback function to handle standard output messages from the code execution.
- `on_stderr`: A callback function to handle standard error messages from the code execution.
- `on_result`: A callback function to handle the result and display calls of the code execution.

## Streaming response

You can use the `on_*` callbacks to handle the output of the code execution as it happens. This is useful for long-running code. You can stream the output to the user as it is generated.

## Execution object

The object returned by the `exec cell` method is little bit more complex, it's based on Jupyter. Here's an detailed explanation in the [Jupyter documentation](https://jupyter-client.readthedocs.io/en/stable/messaging.html).

It contains the following fields:

- `results`: A list containing result of the cell (interactively interpreted last line) and display calls (e.g. matplotlib plots).
- `logs`: Logs printed to stdout and stderr during execution.
- `error`: An error message, if there was an error during execution of the cell. It works only for Python code, not for system (`!` e.g `!pip install e2b`) commands.

### Result object

This object can be created in two different ways:
- Evaluation of the last line: If the last line of the code is an expression, the result is the value of that expression. As you would expect in REPL environments.
- Display calls: Calls to display functions, which can be used to display rich output in the notebook. E.g. [`img.show()`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.show.html), [`display(img)`](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html), etc.

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by [ipython kernel](https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics)

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The display calls don't have to have text representation, it's always present for the actual result,
the other representations are optional.

The result has those basic data types:

#### Text types:
- `text`: text representation of the result
- `html`: html representation of the result
- `markdown`: markdown representation of the result
- `latex`: latex representation of the result

#### Image types:
 - `png`: "base64 encoded png image",
 - `jpeg`: "base64 encoded jpeg image",
 - `svg`": "svg image",

#### Other types:
 - `json`: "json representation",
 - `javascript`: "javascript representation",
 - `pdf`: "base64 encoded pdf"

<Note>
  If you want to integrate your own display formats or how to implement them for your classes, you can read more in [here](https://github.com/ipython/ipython/blob/main/examples/IPython%20Kernel/Custom%20Display%20Logic.ipynb)
</Note>

### Logs object

Logs printed to stdout and stderr during execution. Examples of logs are print statements, warnings, subprocess output, etc.

It contains two fields:
- `stdout`: List of strings, each string is a line printed to stdout.
- `stderr`: List of strings, each string is a line printed to stderr.

### Error object

An error message, if there was an error during execution of the cell.
<Note>
  It works only for Python code, not for system (e.g. `!pip install non_existent_package`) commands. The system commands are executed in a separate process and the output is in stdout/stderr.
</Note>

It contains three fields:
- `name`: Name of the error, e.g. `NameError`, `ValueError`, etc.
- `value`: Value of the error, e.g. `name 'non_existent_variable' is not defined`, etc.
- `traceback`: Traceback of the error.


## Example how to interpret the results to LLM

Here's an example how to return the results to LLM:

<CodeGroup isRunnable={false}>
```js
const code = '<CODE GENERATED BY LLM>'
const execution = await sandbox.notebook.execCell(code)

// There was an error during execution, return the error and its traceback
if (execution.error) {
  return `There was an error during execution: ${execution.error.name}: ${execution.error.value}.\n
  ${execution.error.traceback}`
}

// The execution has some result, summarize to LLM, what are the results
if (execution.results.length > 0) {
  let message = 'These are results of the execution:\n'
  let counter = 1
  for (const result of execution.results) {
    message += `Result ${counter++}:\n`
    if (result.isMainResult) {
      message += `[Main result]: ${result.text}\n`
    } else {
      message += `[Display data]: ${result.text}\n`
    }
    if (result.formats().length > 0) {
      message += `It has following formats: ${result.formats()}\n`
    }
  }

  return message
}

// There were no results, check if there was something is stdout/err
if (
  execution.logs.stdout.length > 0 ||
  execution.logs.stderr.length > 0
) {
  let message = 'There was no result of the execution, but here are the logs:\n'
  if (execution.logs.stdout.length > 0) {
    message += `Stdout: ${execution.logs.stdout.join('\n')}\n`
  }
  if (execution.logs.stderr.length > 0) {
    message += `Stderr: ${execution.logs.stderr.join('\n')}\n`
  }

  return message
}

return 'There was no output of the execution.'
```

```python
code = "<CODE GENERATED BY LLM>"
execution = sandbox.notebook.exec_cell(code)

# There was an error during execution, return the error and its traceback
if execution.error:
    return (
        f"There was an error during execution: {execution.error.name}: {execution.error.value}.\n"
        f"{execution.error.traceback}"
    )

# The execution has some result, summarize to LLM, what are the results
if execution.results:
    message = "These are results of the execution:\n"
    for i, result in enumerate(execution.results):
        message += f"Result {i + 1}:\n"
        if result.is_main_result:
            message += f"[Main result]: {result.text}\n"
        else:
            message += f"[Display data]: {result.text}\n"

        if result.formats():
            message += f"It has also following formats: {result.formats()}\n"

    return message

# There were no results, check if there was something is stdout/err
if execution.logs.stdout or execution.logs.stderr:
    message = "There was no result of the execution, but here are the logs:\n"
    if execution.logs.stdout:
        message += "Stdout: " + "\n".join(execution.logs.stdout) + "\n"

    if execution.logs.stderr:
        message += "Stderr: " + "\n".join(execution.logs.stderr) + "\n"

    return message

return "There was no output of the execution."
```
</CodeGroup>


# Code Interpreter SDK
E2B's [Code Interpreter SDK](https://github.com/e2b-dev/code-interpreter) allows you to add code interpreting capabilities to your AI apps.

The code interpreter runs inside the [E2B Sandbox](https://github.com/e2b-dev/e2b) - an open-source secure sandbox made for running untrusted AI-generated code and AI agents.
- ✅ Works with any LLM and AI framework
- ✅ Supports streaming content like charts and stdout, stderr
- ✅ Python & JS SDK
- ✅ Runs on serverless and edge functions
- ✅ Runs AI-generated code in secure sandboxed environments
- ✅ 100% open source (including [infrastructure](https://github.com/e2b-dev/infra))

## Quickstart

### 1. Install SDK

JavaScript/TypeScript
```
npm i @e2b/code-interpreter
```

Python
```
pip install e2b_code_interpreter
```

### 2. Execute code with code interpreter inside sandbox

**JavaScript**
```ts
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create()
await sandbox.notebook.execCell('x = 1')

const execution = await sandbox.notebook.execCell('x+=1; x')
console.log(execution.text)  // outputs 2

await sandbox.close()
```

**Python**
```py
from e2b_code_interpreter import CodeInterpreter

with CodeInterpreter() as sandbox:
    sandbox.notebook.exec_cell("x = 1")

    execution = sandbox.notebook.exec_cell("x+=1; x")
    print(execution.text)  # outputs 2
```

### 3. Hello World guide
Dive depeer and check out the [JavaScript](/docs/hello-world/js) and [Python](/docs/hello-world/py) the Hello World guides to learn how o connect code interpreter LLMs.



import Link from 'next/link'

# Kernels

In this section you can find information about kernels and how to use them in Code Interpreter SDK. Having multiple kernels allows you to run code in separate contexts and optionally also languages.

By default the template starts with one default kernel. This kernel is used to execute code, if you don't specify `kernelID`. You can imagine kernel as a separate environment where code is executed. You can have multiple kernels running at the same time. Each kernel has its own state, so you can have multiple kernels running different code at the same time.

Kernel will be kept alive with the sandbox even if you disconnect.

## Creating a new kernel

To create a new kernel there's a `create_kernel` in Python and `createKernel()` in JavaScript/TypeScript method in the `CodeInterpreter` class. This method takes two optional arguments:
- `cwd` - working directory for the kernel, all system commands and file operations will be executed in this directory
- `kernel name` - kernel spec name (defaults to default kernel spec for server). In our case it's `python3`. If you want to use another kernel, you have to install in the template first. In that case you probably want to use <Link href='/code-interpreter/template'>Custom Template</Link>.

## Restarting a kernel

To restart a kernel you can use `restart` method. This method takes one argument - `kernelID`, if not specifed it will restart the default kernel. This method will restart the kernel and clear its state.

## Listing kernels

To list all kernels you can use `list` method. This method returns an array of all running kernels with their IDs and kernel spec names.

## Shutting down a kernel

To shutdown a kernel you can use `shutdown` method. This method takes one argument - `kernelID`, if not specifed it will delete the default kernel. This method will delete the kernel and all its state.


import Link from 'next/link'
import { FileCode } from 'lucide-react'

# Using custom sandbox template & custom compute with Code Interpreter SDK

If you want to customize the Code Interprerter sandbox (e.g.: add a preinstalled package) you can do that by using a [custom sandbox template](https://e2b.dev/docs/sandbox/templates/overview).


## Step-by-step guide
1. Create custom sandbox by following [this guide](https://e2b.dev/docs/guide/custom-sandbox)

2. Use prebuilt [E2B Code Interpreter image](https://hub.docker.com/r/e2bdev/code-interpreter) by replacing the `FROM` command in your `e2b.Dockerfile` with following

    ```sh
    FROM e2bdev/code-interpreter:latest
    ```

3. Run the following in the same directory where's your `e2b.toml`
    ```sh
    e2b template build -c "/root/.jupyter/start-up.sh"
    ```

4. Use your custom sandbox with Code Interpreter SDK

   **Python**
   ```python
   from e2b_code_interpreter import CodeInterpreter
   sandbox = CodeInterpreter(template="your-custom-sandbox-name")
   execution = sandbox.notebook.exec_cell("print('hello')")
   sandbox.close()

   # Or you can use `with` which handles closing the sandbox for you
   with CodeInterpreter(template="your-custom-sandbox-name") as sandbox:
       execution = sandbox.notebook.exec_cell("print('hello')")
   ```


   **JavaScript/TypeScript**
   ```js
   import { CodeInterpreter } from '@e2b/code-interpreter'
   const sandbox = await CodeInterpreter.create({ template: 'your-custom-sandbox-name' })
   const execution = await sandbox.notebook.execCell('print("hello")')
   await sandbox.close()
   ```


## Customize CPU & RAM of your sandbox
You can customize number of CPUs and MiB of RAM for your sandbox. To achieve that, specify the `--cpu-count` and `--memory-mb` options during the build step:
```sh
e2b template build -c "/home/user/.jupyter/start-up.sh" --cpu-count 4 --memory-mb 4096
```
The above will create a custom sandbox with 4 CPUs a 4 GiB of RAM.

## How to install another Python kernels

Jupyter has ability to work with different than Python kernel. It even supports multiple kernels in one notebook. If you want to install another kernels.

You can find list of available kernels [here](https://github.com/jupyter/jupyter/wiki/Jupyter-kernels). Each has a little bit different installation process, but in general you need to install kernel package and register it in jupyter.


# Clone GitHub Repository

# Getting help

If you have any questions, issues, or feature requests, please reach out on of the following channels: {{ className: 'lead' }}
- Send us an email at [hello@e2b.dev](mailto:hello@e2b.dev)
- Talk to us on our [Discord server](https://discord.gg/U7KEcGErtQ)
- Open an issue on [our GitHub](https://github.com/e2b-dev/e2b)
- Reach out on [Twitter / X](https://x.com/e2b)

import APIKey from './APIKey'

# Your API Key

<APIKey/>


## Use API key

To use the API key, you either:
- **Set the API key as the `E2B_API_KEY` environment variable**
- Or pass it directly to the `CodeInterpreter` constructor like this:
<CodeGroup isRunnable={false}>
```js {{ language: 'js' }}
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create({ apiKey: 'YOUR_API_KEY' })
await sandbox.notebook.execCell('x = 1')

const execution = await sandbox.notebook.execCell('x+=1; x')
console.log(execution.text)  // outputs 2

await sandbox.close()
```
```python {{ language: 'python' }}
from e2b_code_interpreter import CodeInterpreter

with CodeInterpreter(api_key="YOUR_API_KEY") as code_interpreter:
  sandbox.notebook.exec_cell("x = 1")
  execution = sandbox.notebook.exec_cell("x+=1; x")
  print(execution.text)  # outputs 2
```
</CodeGroup>


import { Libraries } from '@/components/Libraries'

# Installation

You create and control sandboxes with our SDKs.
We offer SDKs for [JavaScript / TypeScript](https://www.npmjs.com/package/e2b), and [Python](https://pypi.org/project/e2b/).

<Libraries/>

You can install them using the following commands:

<CodeGroup isRunnable={false}>
```bash {{ language: 'js' }}
npm install e2b
```
```bash {{ language: 'python' }}
pip install e2b
```
</CodeGroup>


## Next steps

1. [Get your API key](/docs/getting-started/api-key)
1. [Explore the Sandbox API](/docs/sandbox/api/envs)
{/* 1. [Follow the "Hello World" example](/docs/guides/) */}
{/* 1. [Check out the official guides](/docs/guides/overview) */}
{/* 1. [Explore integrations with AI frameworks and LLMs](/docs/integrations/overview) */}


# Code Interpreter SDK Beta - Language Runtimes

This guide shows how to run AI-generated code in different language runtimes using the new Code Interpreter beta SDK.
The following language runtimes are currently supported:
- **Python**
- **JavaScript**
- **Java**
- **Bash**
- **R**

<Note>
Want more language runtimes? Reached out to us on [Discord](https://discord.gg/U7KEcGErtQ) or over [email](emailto:contact@e2b.dev).
</Note>

## 1. Install the Code Interpreter beta SDK
The latest beta versions you should install can be found in NPM/PyPi release history:
- **JavaScript & TypeScript**
	- [Latest release](https://www.npmjs.com/package/@e2b/code-interpreter?activeTab=versions) with *rc* tag for `@e2b/code-interpreter`
- **Python**
	- [Latest release](https://pypi.org/project/e2b-code-interpreter/#history) with *PRE-RELEASE* for `e2b-code-interpreter`


## 2. Active kernel for the desired language
Each of the supported language runtimes has its own kernel.

**Python**
```python
from e2b_code_interpreter import CodeInterpreter

sandbox = CodeInterpreter()

# 1. Set JS kernel - available kernel names: 'r', 'javascript', 'java', 'bash'
js_id = sandbox.notebook.create_kernel(kernel_name="javascript")
# 2. Run JS code inside code interpreter!
execution = sandbox.notebook.exec_cell("console.log('Hello World!')", kernel_id=js_id)
print(execution)
# 3. Use Python again
sandbox.notebook.exec_cell("print('Hello World!')")
```

**JavaScript / TypeScript**
```js
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create()

// 1. Set JS kernel - available kernel names: 'r', 'javascript', 'java', 'bash'
const jsID = await sandbox.notebook.createKernel({ kernelName: 'javascript' })
// 2. Run JS code inside code interpreter!
const execution = await sandbox.notebook.execCell("console.log('Hello World!')", { kernelID: jsID })
console.log(execution)
// 3. Use Python again
await sandbox.notebook.execCell('print("Hello World!")')
```


# SDK Beta - Migration Guide
The following guide shows how to migrate your code from the current Core SDKs (`e2b`) and Code Interpreter SDKs (`@e2b/code-interpreter`/`e2b-code-interpreter`) to the beta versions.

The latest beta versions you should install can be found in NPM/PyPi release history:
- **JavaScript & TypeScript**
	- [Latest release](https://www.npmjs.com/package/e2b?activeTab=versions) with *rc* tag for `e2b`
	- [Latest release](https://www.npmjs.com/package/@e2b/code-interpreter?activeTab=versions) with *rc* tag for `@e2b/code-interpreter`
- **Python**
	- [Latest release](https://pypi.org/project/e2b/#history) with *PRE-RELEASE* for `e2b`
	- [Latest release](https://pypi.org/project/e2b-code-interpreter/#history) with *PRE-RELEASE* for `e2b-code-interpreter`

## Table of contents
- [Core Sandbox SDK changes](#core-sandbox-sdk-changes)
	- [Creating sandbox](#creating-sandbox)
	- [Modifying sandbox timeout](#modifying-sandbox-timeout)
	- [Reconnecting](#reconnecting)
	- [Writing files to sandbox](#writing-files-to-sandbox)
	- [Reading files from sandbox](#reading-files-from-sandbox)
	- [Uploading data to sandbox](#uploading-data-to-sandbox)
	- [Downloading files from sandbox](#downloading-files-from-sandbox)
	- [Running processes](#running-processes)
	- [Watching for files' changes](#watching-for-files-changes)
	- [Accessing sandbox ID](#accessing-sandbox-id)
	- [Getting sandbox upload URL](#getting-sandbox-upload-url)
	- [Configuring sandbox `cwd`](#configuring-sandbox-cwd)
	- [Timeouts](#timeouts)
	- [Listing sandboxes](#listing-sandboxes)
	- [Getting sandbox url](#getting-sandbox-url)
	- [Code Interpreter SDK changes](#code-interpreter-sdk-changes)
	- [Executing code](#executing-code)
	- [Custom template](#custom-template)
  - [Python Async](#python-async)
	- [Watching for files' changes in async Python SDK](#watching-for-files-changes-in-async-python-sdk)
	- [Running background commands in async Python SDK](#running-background-commands-in-async-python-sdk)


## <h1>Core Sandbox SDK changes</h1>
These changes affect both the `e2b` Core SDKs and Code Interpreter SDKs (`@e2b/code-interpreter`/`e2b-code-interpreter`) because the Code Interpreter uses the Core SDK.

<Note>
If you are using a custom template you need to rebuild it by calling `e2b template build` in the directory with the template.
</Note>

## Creating sandbox

When creating a sandbox you now **specify the sandbox timeout — how long the sandbox will exist**. If you don't specify the timeout the sandbox will be closed after 5 minutes.

You also no longer call the `.close()` method when you are done with the sandbox. Sandbox will be automatically closed and killed after the timeout.

You can use `.kill()` to kill the sandbox immediately if you are sure you won't need it anymore.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// await sandbox.close()

// Now
const sandbox = await Sandbox.create({ timeoutMs: 300_000 })
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()
# sandbox.close()

# Now
sandbox = Sandbox(timeout=300)
```
</CodeGroup>

If you need to use a [custom sandbox template](/docs/guide/custom-sandbox) you pass the template as the first parameter:
<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create({ template: 'template-name-or-id' })
// await sandbox.close()

// Now
const sandbox = await Sandbox.create('template-name-or-id', {
	timeoutMs: 300_000,
})
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox(template='template-name-or-id')
# sandbox.close()

# Now
sandbox = Sandbox(template='template-name-or-id', timeout=300)
```
</CodeGroup>

## Modifying sandbox timeout
If you need to change how long the sandbox should stay alive after it was created, you can use `.setTimeout()`/`.set_timeout()` method.
It will modify the timeout of the sandbox.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// await sandbox.keepAlive(600_000)

// Now
const sandbox = await Sandbox.create({ timeoutMs: 300_000 })
await sandbox.setTimeout(600_000)
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()
# sandbox.keep_alive(600)

# Now
sandbox = Sandbox(timeout=300)
sandbox.set_timeout(600)
```
</CodeGroup>

## Reconnecting
When connection to an existing sandbox use `.connect()`/`.connect()` method instead of `.reconnect()`/`.reconnect()`.

Instead of using `.keepAlive()`/`.keep_alive()` method to prevent the sandbox from closing until you reconnect use `.setTimeout()`/`.set_timeout()` method.
Because the timeout is set when the sandbox is created, you may not need to set the timeout when reconnecting at all now.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// await sandbox.keepAlive(600_000)
// await sandbox.close()

// const existingSandbox = await Sandbox.reconnect(sandbox.id)

// Now
const sandbox = await Sandbox.create({ timeoutMs: 600_000 })

const existingSandbox = await Sandbox.connect(sandbox.sandboxId)
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()
# sandbox.keep_alive(600)
# sandbox.close()

# existing_sandbox = Sandbox.reconnect(sandbox.id)

# Now
sandbox = Sandbox(timeout=600)

existing_sandbox = Sandbox.connect(sandbox.sandbox_id)
```
</CodeGroup>

## Writing files to sandbox
Use `.files.write()` method to write files to the sandbox.

The method accepts `path` in the sandbox as the first argument and the `data` as the second argument.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// await sandbox.filesystem.write('/hello.txt', 'Hello World!')

// Now
await sandbox.files.write('/path/in/sandbox', 'Hello World!')
```
```python
from e2b import Sandbox

# Before
# sandbox.filesystem.write("/hello.txt", "Hello World!")

# Now
sandbox.files.write("/path/in/sandbox", "Hello World!")
```
</CodeGroup>

## Reading files from sandbox
Use `.files.read()` method to read files from the sandbox.

The method accepts `path` in the sandbox as the first argument and optional `format` as the second argument.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
//const content = await sandbox.downloadFile('/path/in/sandbox')

// Now
const content = await sandbox.files.read('/path/in/sandbox')
```
```python
from e2b import Sandbox

# Before
# content = sandbox.download_file("/path/in/sandbox")

# Now
content = sandbox.files.read("/path/in/sandbox")
```
</CodeGroup>

## Uploading data to sandbox
Use `.files.write()` method to upload files to the sandbox.

The method accepts `path` in the sandbox as the first argument and the `data` as the second argument.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const content = fs.readFileSync('/local/path')
// await sandbox.uploadFile(content, '/path/in/sandbox')

// Now
const content = fs.readFileSync('/local/path')
await sandbox.files.write('/path/in/sandbox', content)
```
```python
from e2b import Sandbox

# Before
# with open("path/to/local/file", "rb") as file:
#	sandbox.upload_file(file)

# Now
with open("path/to/local/file", "rb") as file:
	sandbox.files.write("/path/in/sandbox", file)
```
</CodeGroup>

## Downloading files from sandbox
Use `.files.read()` method to download files from the sandbox.

The method accepts `path` in the sandbox as the first argument and optional `format` as the second argument.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
//const content = await sandbox.downloadFile('/path/in/sandbox')

// Now
const content = await sandbox.files.read('/path/in/sandbox')
```
```python
from e2b import Sandbox

# Before
# content = sandbox.download_file("/path/in/sandbox")

# Now
content = sandbox.files.read("/path/in/sandbox")
```
</CodeGroup>


## Running processes
You execute processes by calling `.commands.run()` method. By default, the method waits for the command to finish.

You can specify the timeout for the command execution by passing `timeoutMs`/`timeout` option. The default timeout is 60 seconds.

If the command fails with a non-zero exit it will raise `CommandExitError` in Javascript, or `CommandExitException` in Python, and you can catch and inspect the error for more info.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// const result = await sandbox.process.startAndWait({
// 	cmd: 'echo "Hello, world!"',
// 	onStderr: (msg) => console.log(msg.line),
// 	onStdout: (msg) => console.log(msg.line),
// })

// Now
const result = await sandbox.commands.run('echo "Hello, World!"', {
	onStderr(output) { console.log(output) },
	onStdout(output) { console.log(output) },
	timeoutMs: 60_000,
})
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()
# result = sandbox.process.start_and_wait(
# 	cmd='echo "Hello, world!"',
# 	on_stderr=lambda msg: print(msg.line),
# 	on_stdout=lambda msg: print(msg.line),
# )

# Now
result = sandbox.commands.run(
	cmd='echo "Hello, World!"',
	timeout=60,
	on_stdout=lambda output: print(output),
	on_stderr=lambda output: print(output),
)
```
</CodeGroup>
If you want to run the command in the background use `background: true`/`background=True` option.
You can then use `.wait()` method to wait for the command to finish.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// const process = await sandbox.process.start({
// 	cmd: 'sleep 10; echo "Hello, world!"',
// 	onStderr: (msg) => console.log(msg.line),
// 	onStdout: (msg) => console.log(msg.line),
// })

// const result = await process.wait()

// Now
const command = await sandbox.commands.run('sleep 10; echo "Hello, world!"', {
	onStderr(output) { console.log(output) },
	onStdout(output) { console.log(output) },
	background: true,
})

const result = await command.wait()
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()
# process = sandbox.process.start(
# 	cmd='echo "Hello, world!"',
# 	on_stderr=lambda msg: print(msg.line),
# 	on_stdout=lambda msg: print(msg.line),
# )

# result = process.wait()

# Now
command = sandbox.commands.run(
	cmd='echo "Hello, World!"',
	background=True,
)

result = command.wait(
	on_stderr=lambda output: print(output),
	on_stdout=lambda output: print(output),
)
```
</CodeGroup>


## Watching for files' changes

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandbox = await Sandbox.create()
// const watcher = sandbox.filesystem.watchDir('/path/in/sandbox')
// watcher.addEventListener((event) => console.log(event))
// await watcher.start()

// Now
const sandbox = await Sandbox.create()
await sandbox.files.watchDir('/path/in/sandbox', (event) => console.log(event))
```
```python
from e2b import Sandbox

# Before
# sandbox = Sandbox()

# watcher = sandbox.filesystem.watch_dir("/path/in/sandbox")
# watcher.add_event_listener(lambda event: print(event))
# watcher.start()

# Now
sandbox = Sandbox()
watcher = sandbox.files.watch_dir("/path/in/sandbox")

for event in watcher:
    print(event)
```
</CodeGroup>

## Accessing sandbox ID
The `id` property on the sandbox/code interpreter instance is now named `sandboxId`/`sandbox_id`.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandboxId = await sandbox.id

// Now
const sandboxId = await sandbox.sandboxId
```
```python
from e2b import Sandbox

# Before
# sandbox_id = sandbox.id

# Now
sandbox_id = sandbox.sandbox_id
```
</CodeGroup>

## Getting sandbox upload URL
The `.fileURL`/`.file_url()` is now `.uploadURL`/`.upload_url()` method that takes an optional argument that specifies the path in the sandbox where the file will be uploaded.

If the path is not specified the file will be uploaded to the home dir — `/home/user`.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const url = await sandbox.fileURL

// Now
const url = await sandbox.uploadUrl('/path/in/sandbox')
```
```python
from e2b import Sandbox

# Before
# url = sandbox.file_url()

# Now
url = sandbox.upload_url('/path/in/sandbox')
```
</CodeGroup>

## Configuring sandbox `cwd`
Previously you could set the sandbox working directory by passing `cwd` option when creating the sandbox.
Right now this is not supported because it leads to subtle bugs especially when reconnecting to an existing sandbox.

If you need this feature please reach out to us on [Discord](https://discord.com/invite/U7KEcGErtQ) or [GitHub](https://github.com/e2b-dev/e2b) so we can prioritize it.

## Timeouts
There are now two types of timeouts that you can pass as parameters:
1. `request_timeout`/`requestTimeoutMs` sets how long the operation should wait for connection/processing.
This is useful for ensuring that none of the sandbox operations hang indefinitely.
2. `timeout`/`timeoutMs` which is used for setting the maximum length of long-running operations like executing code, running processes, or the sandbox itself.

## Listing sandboxes
Some properties returned from the `Sandbox.list` method have been renamed.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const sandboxes = await Sandbox.list()

// `sandboxes` is an array of `RunningSandbox` objects:
// {
//   sandboxID: string
//   templateID: string
//   alias?: string
//   metadata?: SandboxMetadata
//   startedAt: Date
// }

// Now
const sandboxes = await Sandbox.list()

// `sandboxes` is an array of `SandboxInfo` objects:
// {
//   sandboxId: string
//   templateId: string
//   name?: string
//   metadata: Record<string, string>
//   startedAt: Date
// }
```
```python
from e2b import Sandbox

# Before
# sandboxes = Sandbox.list()

# `sandboxes` is an array of `RunningSandbox` objects:
# class RunningSandbox(BaseModel):
#     sandbox_id: str
#     template_id: str
#     alias: Optional[str]
#     metadata: Optional[Dict[str, str]]
#     cpu_count: int
#     memory_mb: int
#     started_at: datetime

# Now
sandboxes = Sandbox.list()

# `sandboxes` is an array of `SandboxInfo` objects:
# @dataclass
# class SandboxInfo:
#     sandbox_id: str
#     template_id: str
#     name: Optional[str]
#     metadata: Dict[str, str]
#     started_at: datetime

```
</CodeGroup>


## Getting sandbox url
The method for getting the sandbox host has changed from `sandbox.getHostname/sandbox.get_hostname` to `sandbox.getHost/sandbox.get_host`.
It now requires specifying the port.

<CodeGroup isRunnable={false}>
```js
import Sandbox from 'e2b'

// Before
// const host = await sandbox.getHostname(80)

// Now
const host = await sandbox.getHost(80)
```
```python
from e2b import Sandbox

# Before
# host = sandbox.get_hostname(80)

# Now
host = sandbox.get_host(80)
```
</CodeGroup>


## <h1>Code Interpreter SDK changes</h1>
All the previously mentioned changes to the Core SDK also apply to the Code Interpreter SDK.
Apart from them, the changes to the Code Interpreter SDK are very minimal:

## Executing code
When executing code via JS/TS Code Interpreter SDK you now pass the `timeoutMs` option to the `execCell` method instead of `timeout`.

The default timeout for the code execution is now 300 seconds.

<CodeGroup isRunnable={false}>
```js
import CodeInterpreter from '@e2b/code-interpreter'

// Before
// const sandbox = await CodeInterpreter.create()
// const execution = await sandbox.notebook.execCell('print("Hello, world!")', {
//   timeout: 2000,
// })
// await sandbox.close()

// Now
const sandbox = await CodeInterpreter.create({ timeoutMs: 300_000 })
const execution = await sandbox.notebook.execCell('print("Hello, world!")', {
  timeoutMs: 2000,
})
```

```python
from e2b_code_interpreter import CodeInterpreter

# Before
# sandbox = CodeInterpreter()
# execution = sandbox.notebook.exec_cell('print("Hello, world!")', timeout=2)
# sandbox.close()

# Now
sandbox = CodeInterpreter(timeout=300)
execution = sandbox.notebook.exec_cell('print("Hello, world!")', timeout=2)
```
</CodeGroup>

## Custom template
If you are using a custom template for the Code Interpreter you need to rebuild it.


You can rebuild the template by either calling
```sh
e2b template build -c "/root/.jupyter/start-up.sh"
```
if you use the E2B Docker image as base in your `e2b.Dockerfile`
```docker
FROM e2bdev/code-interpreter:latest

# You custom Dockerfile content here
```

Or if you are using custom base you need to copy all files excluding the `e2b.toml` from [beta template](https://github.com/e2b-dev/code-interpreter/tree/beta/template)
to the directory with your template and then run `e2b template build -c "/root/.jupyter/start-up.sh"`.

<Note>
Check of the [Code Interpreter custom template](/docs/code-interpreter/template) page for more info.
</Note>

## <h1>Python Async</h1>
Python Core SDK and Code Interpter SDK now support async.

If you need to use async import `AsyncSandbox`/`AsyncCodeInterpreter` instead of `Sandbox`/`CodeInterpreter`.

<CodeGroup isRunnable={false}>
```python
# Sync
# from e2b import Sandbox
# sandbox = Sandbox()

# from e2b_code_interpreter import CodeInterpreter
# sandbox = CodeInterpreter()

# Async
from e2b import AsyncSandbox
from e2b_code_interpreter import AsyncCodeInterpreter

sandbox = await AsyncSandbox.create()
sandbox = await AsyncCodeInterpreter.create()
```
</CodeGroup>

The async versions of methods for watching for files' changes and running commands in the background are slightly different:

## Watching for files' changes in async Python SDK

<CodeGroup isRunnable={false}>
```python
from e2b import Sandbox

# Sync
# sandbox = Sandbox()
# watcher = sandbox.files.watch_dir("/path/in/sandbox")

# for event in watcher:
#     print(event)

# Async
sandbox = await AsyncSandbox.create()

await sandbox.files.watch_dir("/path/in/sandbox", lambda event: print(event))
```
</CodeGroup>

## Running background commands in async Python SDK
<CodeGroup isRunnable={false}>
```python
from e2b import Sandbox

# Sync
# sandbox = Sandbox()
# command = sandbox.commands.run(
# 	cmd='echo "Hello, World!"',
# 	background=True,
# )

# result = command.wait(
# 	on_stderr=lambda output: print(output),
# 	on_stdout=lambda output: print(output),
# )

# Async
sandbox = await AsyncSandbox.create()
command = await sandbox.commands.run(
	cmd='echo "Hello, World!"',
	on_stderr=lambda output: print(output),
	on_stdout=lambda output: print(output),
	background=True,
)

result = await command.wait()
```
</CodeGroup>


# Connecting bucket to the sandbox

To enable persistence of the data in the sandbox we can use a bucket to store the data. We are leveraging the fuse file system to mount the bucket to the sandbox.

You will need to build a custom sandbox template with the fuse file system installed. The guide how to build a custom sandbox template can be found [here](/docs/guide/custom-sandbox).

## Google Cloud Storage

### Prerequisites

To use the Google Cloud Storage we'll need to have a bucket and a service account. The service account can be created [here](https://console.cloud.google.com/iam-admin/serviceaccounts), the bucket can be created [here](https://console.cloud.google.com/storage).

If you want to write to the bucket the service account must have the `Storage Object Admin` role for this bucket.

The guide how to create a service account key can be found [here](https://cloud.google.com/iam/docs/keys-create-delete#iam-service-account-keys-create-console).

### Mounting the bucket

To use the Google Cloud Storage we need to install the `gcsfuse` package. There's simple `Dockerfile` that can be used to create a container with the `gcsfuse` installed.

```docker
FROM ubuntu:latest

RUN apt-get update && apt-get install -y gnupg lsb-release wget

RUN lsb_release -c -s > /tmp/lsb_release
RUN GCSFUSE_REPO=$(cat /tmp/lsb_release); echo "deb https://packages.cloud.google.com/apt gcsfuse-$GCSFUSE_REPO main" | tee /etc/apt/sources.list.d/gcsfuse.list
RUN wget -O - https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -

RUN apt-get update && apt-get install -y gcsfuse

```

The actual mounting of the bucket is done in runtime during the start of the sandbox. The `gcsfuse` command is used to mount the bucket to the sandbox.

<CodeGroup isRunnable={false}>
```js {{ language: 'js' }}
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create({ template: '<your template id>' })
await sandbox.filesystem.makeDir("/home/user/bucket")
await sandbox.uploadFile("key.json")

const process = await sandbox.process.start("sudo gcsfuse <flags> --key-file /home/user/key.json <bucket-name> /home/user/bucket")
const output = await process.wait()
if (output.exitCode) {
    throw Error(output.stderr)
}
```

```python {{ language: 'python' }}
from e2b import Sandbox

with Sandbox(template="<your template id>") as sandbox:
    sandbox.filesystem.make_dir("/home/user/bucket")
    sandbox.upload_file("key.json")

    process = sandbox.process.start("sudo gcsfuse <flags> --key-file /home/user/key.json <bucket-name> /home/user/bucket")
    output = process.wait()
    if output.exit_code:
        raise Exception(output.stderr)

```
</CodeGroup>

### Flags

The list of all flags can be found [here](https://cloud.google.com/storage/docs/gcsfuse-cli#options).

### Allow the default user to access the files

To allow the default user to access the files we can use the following flags:

```
-o allow_other -file-mode=777 -dir-mode=777
```

## Amazon S3

For Amazon S3 we can use the `s3fs` package. The `Dockerfile` is similar to the one for the Google Cloud Storage.

```docker
FROM ubuntu:latest

RUN apt-get update && apt-get install s3fs
```

Similarly to the Google Cloud Storage, the actual mounting of the bucket is done in runtime during the start of the sandbox. The `s3fs` command is used to mount the bucket to the sandbox.

<CodeGroup isRunnable={false}>
```js {{ language: 'js' }}
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create({ template: '<your template id>' })
await sandbox.filesystem.makeDir('/home/user/bucket')


// Create a file with the credentials
// If you use another path for the credentials you need to add the path in the command s3fs command
await sandbox.filesystem.write('/root/.passwd-s3fs', '<AWS_ACCESS_KEY_ID>:<AWS_SECRET_ACCESS_KEY>')
await sandbox.process.startAndWait('sudo chmod 600 /root/.passwd-s3fs')

const process = await sandbox.process.start('sudo s3fs <flags> <bucket-name> /home/user/bucket')
const output = await process.wait()
if (output.exitCode) {
    throw Error(output.stderr)
}
```

```python {{ language: 'python' }}
from e2b import Sandbox

with Sandbox(template="<your template id>") as sandbox:
    sandbox.filesystem.make_dir("/home/user/bucket")

    # Create a file with the credentials
    # If you use another path for the credentials you need to add the path in the command s3fs command
    sandbox.filesystem.write("/root/.passwd-s3fs", "<AWS_ACCESS_KEY_ID>:<AWS_SECRET_ACCESS_KEY>")
    sandbox.process.start_and_wait("sudo chmod 600 /root/.passwd-s3fs")

    process = sandbox.process.start("sudo s3fs <flags> <bucket-name> /home/user/bucket")
    output = process.wait()
    if output.exit_code:
        raise Exception(output.stderr)

```
</CodeGroup>

### Flags

The list of all flags can be found [here](https://manpages.ubuntu.com/manpages/xenial/man1/s3fs.1.html).

### Allow the default user to access the files

To allow the default user to access the files add the following flag:

```
-o allow_other
```

## Cloudflare R2

For Cloudflare R2 we can use very similar setup as for S3. The `Dockerfile` is the same as for S3. The mounting is slightly different, we need to specify the endpoint for R2.

<CodeGroup isRunnable={false}>
```js {{ language: 'js' }}

import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create({ template: '<your template id>' })
await sandbox.filesystem.makeDir('/home/user/bucket')

// Create a file with the R2 credentials
// If you use another path for the credentials you need to add the path in the command s3fs command
await sandbox.filesystem.write('/root/.passwd-s3fs', '<R2_ACCESS_KEY_ID>:<R2_SECRET_ACCESS_KEY>')
await sandbox.process.startAndWait('sudo chmod 600 /root/.passwd-s3fs')

const output = await sandbox.process.startAndWait('sudo s3fs -o url=https://<ACCOUNT ID>.r2.cloudflarestorage.com <flags> <bucket-name> /home/user/bucket')
if (output.exitCode) {
    throw Error(output.stderr)
}
```

```python {{ language: 'python' }}
from e2b import Sandbox

with Sandbox(template="<your template id>") as sandbox:
    sandbox.filesystem.make_dir("/home/user/bucket")

    # Create a file with the R2 credentials
    # If you use another path for the credentials you need to add the path in the command s3fs command
    sandbox.filesystem.write("/root/.passwd-s3fs", "<R2_ACCESS_KEY_ID>:<R2_SECRET_ACCESS_KEY>")
    sandbox.process.start_and_wait("sudo chmod 600 /root/.passwd-s3fs")

    process = sandbox.process.start("sudo s3fs -o url=https://<ACCOUNT ID>.r2.cloudflarestorage.com <flags> <bucket-name> /home/user/bucket")
    output = process.wait()
    if output.exit_code:
        raise Exception(output.stderr)

```
</CodeGroup>

### Flags

It's the same as for S3.

import Image from 'next/image'

# Creating Custom Sandbox

In this guide, we'll create a custom E2B sandbox with preinstalled dependencies and files.
Once the sandbox is built, we'll show how to spawn and control it with our SDK.

## Prerequisites
1. [Node.js](https://nodejs.org/) 18.0.0 or later
1. [E2B CLI](/docs/cli/installation)
1. Running Docker instance

## 1. Install E2B CLI

<CodeGroup isTerminalCommand title="Install CLI" isRunnable={false}>
```bash
npm install -g @e2b/cli@latest
```
</CodeGroup>

<Note>
You need Node.js 18.0.0 or later to install the CLI.
</Note>

## 2. Login to CLI
Before you create your first custom sandbox, you will need to authenticate in the CLI with your E2B account.
Run the following command in your terminal.
<CodeGroup isTerminalCommand title="Login to CLI" isRunnable={false}>
```bash
e2b auth login
```
</CodeGroup>

<Note>
You need to have an existing E2B account to login. Sign up [here](/docs/getting-started/api-key).
</Note>

## 3. Create `e2b.Dockerfile`
To describe how your custom sandbox will look like, create a new Dockerfile and name it `e2b.Dockerfile`.
We use this Dockerfile as the [template file](/docs/sandbox/templates/template-file).

<Note>
Run `e2b template init` to create `e2b.Dockerfile` in the current directory.
</Note>

We want our custom sandbox to have the [ffmpeg](https://www.ffmpeg.org/) isntalled - ffmpeg is a tool for editing video and audio files.

<Note>
We support only Debian based images at the moment.
</Note>

<CodeGroup isFileName title="e2b.Dockerfile" isRunnable={false}>
```bash
# You can use most of the Debian based images
FROM ubuntu:22.04

# Install the ffmpeg tool/
RUN apt update \
    && apt install -y ffmpeg
```
</CodeGroup>

## 4. Build custom sandbox
Now it's time to create your custom sandbox based on the sandbox template file (the `e2b.Dockefile` file) you just created in the previous step.

Run the following command inside the template file directory in your terminal.
<Note>
[Pro users](/docs/pricing) can use the `--cpu-count=` ([docs](/docs/cli/commands#template-build)) and `--memory-mb=` ([docs](/docs/cli/commands#template-build)) flags to customize the sandbox compute.
Read more about the compute [here](/docs/sandbox/compute).
</Note>

<CodeGroup isTerminalCommand title="Build sandbox template" isRunnable={false}>
```bash
e2b template build --name "my-agent-sandbox"
```
</CodeGroup>

<Note>
Use the `.dockerignore` file to exclude files from the sandbox template.
</Note>

The final output should look similar to this.

<CodeGroup title="Build output" isRunnable={false}>
```bash
Preparing sandbox template building (1 files in Docker build context).
Found ./e2b.Dockerfile that will be used to build the sandbox template.
Started building the sandbox template my-agent-sandbox

# Truncated for visibility
# ...
# ...

Running postprocessing. It can take up to few minutes.

Postprocessing finished.

✅ Building sandbox template my-agent-sandbox finished.

┌ Usage examples ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                                                                                      │
│  You can use E2B Python or JS SDK to spawn sandboxes now.                                                                                            │
│  Find more here - https://e2b.dev/docs/guide/custom-sandbox in Spawn and control your sandbox section.                                               │
│                                                                                                                                                      │
│───────────────────────────────────────────────────────────────────── Python SDK ─────────────────────────────────────────────────────────────────────│
│                                                                                                                                                      │
│  from e2b import Sandbox                                                                                                                             │
│                                                                                                                                                      │
│  # Start sandbox                                                                                                                                     │
│  sandbox = Sandbox("my-agent-sandbox")                                                                                                               │
│                                                                                                                                                      │
│  # Interact with sandbox. Learn more here:                                                                                                           │
│  # https://e2b.dev/docs/sandbox/overview                                                                                                             │
│                                                                                                                                                      │
│  # Close sandbox once done                                                                                                                           │
│  sandbox.close()                                                                                                                                     │
│                                                                                                                                                      │
│─────────────────────────────────────────────────────────────────────── JS SDK ───────────────────────────────────────────────────────────────────────│
│                                                                                                                                                      │
│  import { Sandbox } from 'e2b'                                                                                                                  │
│                                                                                                                                                      │
│  // Start sandbox                                                                                                                                    │
│  const sandbox = await Sandbox.create('my-agent-sandbox')                                                                                            │
│                                                                                                                                                      │
│  // Interact with sandbox. Learn more here:                                                                                                          │
│  // https://e2b.dev/docs/sandbox/overview                                                                                                            │
│                                                                                                                                                      │
│  // Close sandbox once done                                                                                                                          │
│  await sandbox.close()                                                                                                                               │
│                                                                                                                                                      │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

Execution time: 42.55s
```
</CodeGroup>


This will create the `e2b.toml` file storing the sandbox config.
<CodeGroup isFileName title="e2b.toml" isRunnable={false}>
```toml
# This is a config for E2B sandbox template
template_id = "1wdqsf9le9gk21ztb4mo"
dockerfile = "e2b.Dockerfile"
template_name = "my-agent-sandbox"
```
</CodeGroup>

| Sandbox template name | Sandbox template ID |
---|---|
|`my-agent-sandbox`|`1wdqsf9le9gk21ztb4mo`|

### Updating your sandbox template
If you want to update your sandbox template, you run the same command you did to build it.
This will rebuild the template.

<CodeGroup isTerminalCommand title="Update sandbox template" isRunnable={false}>
```bash
e2b template build
```
</CodeGroup>

## 5. Spawn and control your sandbox

Now you can use the [E2B SDK](/docs/getting-started/installation) to spawn & control your new custom sandbox.

The sandbox template name is `my-agent-sandbox`. We'll use it as an unique identifier and pass it to the SDK as the `template` parameter.
This way, we'll be able to spawn our custom sandbox and control it with the SDK.

<CodeGroup title="Spawn & control your custom sandbox" isRunnable={true}>
```js {{ language: 'js' }}
import { Sandbox } from 'e2b'

// Spawn your custom sandbox
const sandbox = await Sandbox.create({ template: 'my-agent-sandbox' }) // $HighlightLine

// Interact with sandbox. Learn more here:
// https://e2b.dev/docs/sandbox/overview

// Close sandbox once done
await sandbox.close()
```

```python {{ language: 'python' }}
from e2b import Sandbox

# Spawn your custom sandbox
sandbox = Sandbox(template="my-agent-sandbox") # $HighlightLine

# Interact with sandbox. Learn more here:
# https://e2b.dev/docs/sandbox/overview

# Close sandbox once done
sandbox.close()
```
</CodeGroup>


import Image from 'next/image'
import imgChart from '@/images/hello-world-chart.png'

# Hello World.ts
This JavaScript guide will show you the basics of E2B:
- Connect the code interpreter to an LLM
- Prompt the LLM to generate the Python code
- Execute the AI-generated Python code in a secure E2B sandbox

### Get full code
Check out the [full code in our cookbook](https://github.com/e2b-dev/e2b-cookbook/tree/main/examples/hello-world-js).

### Overview
1. [Install Code Interpreter SDK](#1-install-code-interpreter-sdk)
1. [Prepare prompt and tools for LLM](#2-prepare-prompt-and-tools-for-llm)
1. [Prepare code interpreting](#3-prepare-code-interpreting)
1. [Call LLM and parse response with tools](#4-call-llm-and-parse-response-with-tools)
1. [Create code interpreter and run everything](##5-create-code-interpreter-and-run-everything)
1. [Save generated chart](#6-save-generated-chart)


## 1. Install Code Interpreter SDK

The Code Interpreter SDK allows you to run AI-generated code in a secure small VM - **E2B sandbox** - made for AI code execution.
Inside the sandbox is a Jupyter server running that you can control from our SDK through the `notebook.execCell()` method.

Check out the [SDK's repository on GitHub](https://github.com/e2b-dev/code-interpreter).

<CodeGroup isRunnable={false}>
```bash {{ language: 'javascript' }}
npm init -y \
&& npm i --save-dev typescript tsx @types/node \
&& npm i @e2b/code-interpreter
```
</CodeGroup>

Get your E2B API key [here](/docs/getting-started/api-key) and save it to `.env` in your root directory.
<CodeGroup isFileName title=".env" isRunnable={false}>
```bash
E2B_API_KEY="e2b-api-key"
```
</CodeGroup>

## 2. Prepare prompt and tools for LLM
We'll be using Anthropic's [Claude 3 Opus](https://www.anthropic.com/news/claude-3-family) model but E2B works with any LLM so feel free to pick any you want!

<Note>
Usually, all you need from the model is just support for tool use. If the LLM doesn't support tool use, you can ask the LLM to respond with Markdown or XML and parse the LLM's output on your own. Then just pass the parsed code from code blocks to the code interpreter.
</Note>

Create the `model.ts` file and paste the following code.
<CodeGroup isFileName title="model.ts" isRunnable={false}>
```ts
import { Anthropic } from '@anthropic-ai/sdk'

export const MODEL_NAME = 'claude-3-opus-20240229'

export const SYSTEM_PROMPT = `
## your job & context
you are a python data scientist. you are given tasks to complete and you run python code to solve them.
- the python code runs in jupyter notebook.
- every time you call \`execute_python\` tool, the python code is executed in a separate cell. it's okay to multiple calls to \`execute_python\`.
- display visualizations using matplotlib or any other visualization library directly in the notebook. don't worry about saving the visualizations to a file.
- you have access to the internet and can make api requests.
- you also have access to the filesystem and can read/write files.
- you can install any pip package (if it exists) if you need to but the usual packages for data analysis are already preinstalled.
- you can run any python code you want, everything is running in a secure sandbox environment.
`

export const tools: Anthropic.Tool[] = [
  {
    name: 'execute_python',
    description: 'Execute python code in a Jupyter notebook cell and returns any result, stdout, stderr, display_data, and error.',
    input_schema: {
      type: 'object',
      properties: {
        code: {
          type: 'string',
          description: 'The python code to execute in a single cell.'
        }
      },
      required: ['code']
    }
  }
]

```
</CodeGroup>

This defines our system prompt and the `tools` dictionary with available tools for the LLM - namely the `"execute_python"` tool.
A little bit later, we'll connect `"execute_python"` to the E2B's code interpretrer.


## 3. Prepare code interpreting
We'll create a new function called `codeInterpret()` in a separate file `codeInterpreter.ts`.

<CodeGroup isFileName title="codeInterpreter.ts" isRunnable={false}>
```ts {{ language: 'javascript' }}
import { CodeInterpreter } from '@e2b/code-interpreter'

export async function codeInterpret(codeInterpreter: CodeInterpreter, code: string) {
  console.log(`\n${'='.repeat(50)}\n> Running following AI-generated code:\n${code}\n${'='.repeat(50)}`);

  const exec = await codeInterpreter.notebook.execCell(
    code,
    {
      // You can stream logs from the code interpreter
      // onStderr: (stderr: string) => console.log("\n[Code Interpreter stdout]", stderr),
      // onStdout: (stdout: string) => console.log("\n[Code Interpreter stderr]", stdout),
      //
      // You can also stream additional results like charts, images, etc.
      // onResult: ...
    }
  )

  if (exec.error) {
    console.log('[Code Interpreter error]', exec.error) // Runtime error
    return undefined
  }

  return exec
}
```
</CodeGroup>

This function takes the `CodeInterpreter` object from our SDK, and `code` as paramaters.
The `code` parameter is the code generated by the LLM.

Inside the function, we call the `codeInterpreter.notebook.execCell()` method. The `execCell()` takes `code` argument, and executes this `code` inside E2B sandbox.

## 4. Call LLM and parse response with tools
We're using Claude 3 Opus. Get your [Anthropic API key](https://console.anthropic.com/), save it to `.env` file, and install the [Anthropic SDK](https://docs.anthropic.com/claude/reference/client-sdks).

<CodeGroup isFileName title=".env" isRunnable={false}>
```bash
ANTHROPIC_API_KEY="anthropic-api-key"
```
</CodeGroup>

<CodeGroup isRunnable={false}>
```bash {{ language: 'python' }}
npm i @anthropic-ai/sdk@0.28.0
```
</CodeGroup>

Now we'll put everything together.
Create the `index.ts` file, import dependencies, and create the `chat()` function that will do the LLM calling and tool parsing.

<CodeGroup isFileName title="index.ts" isRunnable={false}>
```ts {{ language: 'javascript' }}
import * as fs from 'fs'

import 'dotenv/config'
import { CodeInterpreter, Execution } from '@e2b/code-interpreter'
import Anthropic from '@anthropic-ai/sdk'

import {
  MODEL_NAME,
  SYSTEM_PROMPT,
  tools,
} from './model'
import { codeInterpret } from './codeInterpreter'

const anthropic = new Anthropic()

async function chat(codeInterpreter: CodeInterpreter, userMessage: string): Promise<Execution | undefined> {
  console.log('Waiting for Claude...')

  const msg = await anthropic.messages.create({
    model: MODEL_NAME,
    system: SYSTEM_PROMPT,
    max_tokens: 4096,
    messages: [{role: 'user', content: userMessage}],
    tools,
  })

  console.log(`\n${'='.repeat(50)}\nModel response: ${msg.content}\n${'='.repeat(50)}`)
  console.log(msg)

  if (msg.stop_reason === 'tool_use') {
    const toolBlock = msg.content.find((block) => block.type === 'tool_use');
    const toolName = toolBlock.name
    const toolInput = toolBlock.input

    console.log(`\n${'='.repeat(50)}\nUsing tool: ${toolName}\n${'='.repeat(50)}`);

    if (toolName === 'execute_python') {
      const code = toolInput.code
      return codeInterpret(codeInterpreter, code)
    }
    return undefined
  }
}
```
</CodeGroup>

## 5. Create code interpreter and run everything
Now we put all together, and run our program. In the end of `index.ts` add following code prompting the LLM to visualize a distribution of height of men and print the median.

<CodeGroup isFileName title="index.ts" isRunnable={false}>
```ts {{ language: 'javascript' }}
async function run() {
  const userMessage = 'Visualize a distribution of height of men based on the latest data you know. Also print the median value.'

  const codeInterpreter = await CodeInterpreter.create()

  const codeOutput = await chat(codeInterpreter, userMessage)
  if (!codeOutput) {
    console.log('No code output')
    return
  }

  const logs = codeOutput.logs
  console.log(logs)

  if (codeOutput.results.length == 0) {
    console.log('No results')
    return
  }

  const firstResult = codeOutput.results[0]
  // Print description of the first rich result
  console.log(firstResult.text)

  await codeInterpreter.close()
}

run()
```
</CodeGroup>

After running your code with the following command
<CodeGroup isRunnable={false}>
```bash {{ language: 'bash' }}
$ tsx index.ts
```
</CodeGroup>

you should see similar results to this:

```sh
stdout=['The median male height is 175.5 cm\n'] stderr=[]
<Figure size 800x400 with 1 Axes>
```

We got our median in the logs (`stdout`, and `stderr`) but we also something intering in `firstResult`.
```sh
<Figure size 800x400 with 1 Axes>
```

## 6. Save generated chart

This looks like a plot. Let's save it to a file. Update the `run()` function like this,
and run the code again with `tsx index.ts` in your terminal.
<CodeGroup isFileName title="index.ts" isRunnable={false}>
```ts {{ language: 'javscript' }}
async function run() {
  const userMessage = 'Visualize a distribution of height of men based on the latest data you know. Also print the median value.'

  const codeInterpreter = await CodeInterpreter.create()

  const codeOutput = await chat(codeInterpreter, userMessage)
  if (!codeOutput) {
    console.log('No code output')
    return
  }

  const logs = codeOutput.logs
  console.log(logs)

  if (codeOutput.results.length == 0) {
    console.log('No results')
    return
  }

  const firstResult = codeOutput.results[0]
  // Print description of the first rich result
  console.log(firstResult.text)

  // If we received a chart in PNG form, we can visualize it
  if (firstResult.png) {
      // Decode the base64 encoded PNG data
      const pngData = Buffer.from(firstResult.png, 'base64');

      // Generate a unique filename for the PNG
      const filename = 'chart.png';

      // Save the decoded PNG data to a file
      fs.writeFileSync(filename, pngData);

      console.log(`Saved chart to ${filename}`);
  }

  await codeInterpreter.close()
}

run()
```
</CodeGroup>

The chart got saved in the `chart.png` file and it should look similar to this:

<Image
  src={imgChart}
  className="rounded w-full"
  alt="Chart visualizing distribution height of men"
  unoptimized
/>


import Image from 'next/image'
import imgChart from '@/images/hello-world-chart.png'


# Hello World.py
This Python guide will show you the basics of E2B:
- Connect the code interpreter to an LLM
- Prompt the LLM to generate the Python code
- Execute the AI-generated Python code in a secure E2B sandbox

### Get full code
Check out the [full code in our cookbook](https://github.com/e2b-dev/e2b-cookbook/tree/main/examples/hello-world-python).

### Overview
1. [Install Code Interpreter SDK](#1-install-code-interpreter-sdk)
1. [Prepare prompt and tools for LLM](#2-prepare-prompt-and-tools-for-llm)
1. [Prepare code interpreting](#3-prepare-code-interpreting)
1. [Call LLM and parse response with tools](#4-call-llm-and-parse-response-with-tools)
1. [Create code interpreter and run everything](##5-create-code-interpreter-and-run-everything)
1. [Save generated chart](#6-save-generated-chart)


## 1. Install Code Interpreter SDK

The Code Interpreter SDK allows you to run AI-generated code in a secure small VM - **E2B sandbox** - made for AI code execution.
Inside the sandbox is a Jupyter server running that you can control from our SDK through the `notebook.execCell()` method.

Check out the [SDK's repository on GitHub](https://github.com/e2b-dev/code-interpreter).

<CodeGroup isRunnable={false}>
```bash {{ language: 'python' }}
pip install e2b_code_interpreter python-dotenv
```
</CodeGroup>

Get your E2B API key [here](/docs/getting-started/api-key) and save it to `.env` in your root directory.
<CodeGroup isFileName title=".env" isRunnable={false}>
```bash
E2B_API_KEY="e2b-api-key"
```
</CodeGroup>


## 2. Prepare prompt and tools for LLM
We'll be using Anthropic's [Claude 3 Opus](https://www.anthropic.com/news/claude-3-family) model but E2B works with any LLM so feel free to pick any you want!

<Note>
Usually, all you need from the model is just support for tool use. If the LLM doesn't support tool use, you can ask the LLM to respond with Markdown or XML and parse the LLM's output on your own. Then just pass the parsed code from code blocks to the code interpreter.
</Note>

Create the `model.py` file and paste the following code.
<CodeGroup isFileName title="model.py" isRunnable={false}>
```python
MODEL_NAME = "claude-3-opus-20240229"

SYSTEM_PROMPT = """
## your job & context
you are a python data scientist. you are given tasks to complete and you run python code to solve them.
- the python code runs in jupyter notebook.
- every time you call `execute_python` tool, the python code is executed in a separate cell. it's okay to multiple calls to `execute_python`.
- display visualizations using matplotlib or any other visualization library directly in the notebook. don't worry about saving the visualizations to a file.
- you have access to the internet and can make api requests.
- you also have access to the filesystem and can read/write files.
- you can install any pip package (if it exists) if you need to but the usual packages for data analysis are already preinstalled.
- you can run any python code you want, everything is running in a secure sandbox environment.
"""

tools = [
    {
        "name": "execute_python",
        "description": "Execute python code in a Jupyter notebook cell and returns any result, stdout, stderr, display_data, and error.",
        "input_schema": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "The python code to execute in a single cell."
                }
            },
            "required": ["code"]
        }
    }
]
```
</CodeGroup>

This defines our system prompt and the `tools` dictionary with available tools for the LLM - namely the `"execute_python"` tool.
A little bit later, we'll connect `"execute_python"` to the E2B's code interpreter.


## 3. Prepare code interpreting
We'll create a new function called `code_interpret()` in a separate file `code_interpreter.py`.

<CodeGroup isFileName title="code_interpreter.py" isRunnable={false}>
```python {{ language: 'python' }}
from e2b_code_interpreter import CodeInterpreter

def code_interpret(code_interpreter: CodeInterpreter, code: str):
  print(f"\n{'='*50}\n> Running following AI-generated code:\n{code}\n{'='*50}")
  exec = code_interpreter.notebook.exec_cell(
    code,
    # You can stream logs from the code interpreter
    # on_stderr=lambda stderr: print("\n[Code Interpreter stdout]", stderr),
    # on_stdout=lambda stdout: print("\n[Code Interpreter stderr]", stdout),
    #
    # You can also stream additional results like charts, images, etc.
    # on_result=...
  )

  if exec.error:
    print("[Code Interpreter error]", exec.error) # Runtime error
  else:
    return exec.results, exec.logs
```
</CodeGroup>

This function takes the `CodeInterpreter` object from our SDK and `code` as paramaters.
The `code` parameter is the code generated by the LLM.

Inside the function, we call the `code_interpreter.notebook.exec_cell()` method. The `exec_cell()` takes the `code` argument and executes this `code` inside E2B sandbox.

## 4. Call LLM and parse response with tools
We're using Claude 3 Opus. Get your [Anthropic API key](https://console.anthropic.com/), save it to `.env` file, and install the [Anthropic SDK](https://docs.anthropic.com/claude/reference/client-sdks).

<CodeGroup isFileName title=".env" isRunnable={false}>
```bash
ANTHROPIC_API_KEY="anthropic-api-key"
```
</CodeGroup>

<CodeGroup isRunnable={false}>
```bash {{ language: 'python' }}
pip install anthropic==0.35.0
```
</CodeGroup>

Now we'll put everything together.
Create the `main.py` file, import dependencies, and create the `chat()` function that will do the LLM calling and tool parsing.

<CodeGroup isFileName title="main.py" isRunnable={false}>
```python {{ language: 'python' }}
import base64
from dotenv import load_dotenv
from anthropic import Anthropic
from typing import List, Tuple
from e2b_code_interpreter import CodeInterpreter, Result
from e2b_code_interpreter.models import Logs

from e2b_hello_world.model import MODEL_NAME, SYSTEM_PROMPT, tools
from e2b_hello_world.code_interpreter import code_interpret

# Load the .env file
load_dotenv()

client = Anthropic()

def chat(code_interpreter: CodeInterpreter, user_message: str) -> Tuple[List[Result], Logs]:
    print(f"\n{'='*50}\nUser Message: {user_message}\n{'='*50}")

    message = client.messages.create(
        model=MODEL_NAME,
        system=SYSTEM_PROMPT,
        max_tokens=4096,
        messages=[{"role": "user", "content": user_message}],
        tools=tools,
    )

    print(f"\n{'='*50}\nModel response: {message.content}\n{'='*50}")

    if message.stop_reason == "tool_use":
        tool_use = next(block for block in message.content if block.type == "tool_use")
        tool_name = tool_use.name
        tool_input = tool_use.input

        print(f"\n{'='*50}\nUsing tool: {tool_name}\n{'='*50}")

        if tool_name == "execute_python":
            return code_interpret(code_interpreter, tool_input["code"])
        return []
```
</CodeGroup>


## 5. Create code interpreter and run everything
Now we are ready to run our program. At the end of `main.py` add the following code prompting the LLM to visualize a distribution of the height of men and print the median.

<CodeGroup isFileName title="main.py" isRunnable={false}>
```python {{ language: 'python' }}
def main():
  user_message = "Visualize a distribution of height of men based on the latest data you know. Also, print the median value."

  # Create the CodeInterpreter object and save it as code_interpreter
  with CodeInterpreter() as code_interpreter:
    code_interpreter_results, code_interpreter_logs = chat(
      code_interpreter,
      user_message,
    )

    print(code_interpreter_logs)

    first_result= code_interpreter_results[0]
    print(first_result)
```
</CodeGroup>

After running your code with the following command
<CodeGroup isRunnable={false}>
```bash {{ language: 'bash' }}
$ python main.py
```
</CodeGroup>

you should see results similar to this:

```sh
stdout=['The median male height is 175.5 cm\n'] stderr=[]
<Figure size 800x400 with 1 Axes>
```

We got our median in the logs (`stdout`, and `stderr`) but we also something intering in `first_result`.
```sh
<Figure size 800x400 with 1 Axes>
```

## 6. Save generated chart

This looks like a plot. Let's save it to a file. Add the following to the end of `main.py` and run the code again with `python main.py` in your terminal.
<CodeGroup isFileName title="main.py" isRunnable={false}>
```python {{ language: 'python' }}
    # If we received a chart in PNG form, we can visualize it
    if first_result.png:
      # Decode the base64 encoded PNG data
      png_data = base64.b64decode(first_result.png)

      # Generate a unique filename for the PNG
      filename = f"chart.png"

      # Save the decoded PNG data to a file
      with open(filename, "wb") as f:
          f.write(png_data)

      print(f"Saved chart to {filename}")
```
</CodeGroup>

The chart was saved in the `chart.png` file and it should look similar to this:

<Image
  src={imgChart}
  className="rounded w-full"
  alt="Chart visualizing distribution height of men"
  unoptimized
/>


# Open source

E2B is fully open source including the infrastructure layer.

- [E2B monorepo containing the SDKs, CLI, and docs](https://github.com/e2b-dev/e2b)
- [E2B infrastructure](https://github.com/e2b-dev/infra)
- [Example code interpreter ChatGPT plugin](https://github.com/e2b-dev/llm-code-interpreter)
- [List of awesome SDKs for AI agents](https://github.com/e2b-dev/awesome-sdks-for-ai-agents)
- [List of awesome AI agents](https://github.com/e2b-dev/awesome-ai-agents)
{/* - [E2B cookbook](https://github.com/e2b-dev/e2b-cookbook) */}


import { Guides } from '@/components/Guides'
import { UseCases } from '@/components/UseCases'
import { HeroPattern } from '@/components/HeroPattern'
import { Button } from '@/components/Button'

<HeroPattern />

# Code interpreting for your AI app
E2B's [Code Interpreter SDK](https://github.com/e2b-dev/code-interpreter) allows you to add code interpreting capabilities to your AI apps. {{ className: 'lead' }}

With code interpreting, you can build apps like:
- AI code execution
- Data analysis with AI
- AI tutors
- Reasoning modules for LLM

## Quickstart

### 1. Install SDK
<CodeGroup isRunnable={false}>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter
```
```bash {{ language: 'python' }}
pip install e2b_code_interpreter
```
</CodeGroup>

### 2. Execute code with code interpreter inside sandbox
<CodeGroup isRunnable={false}>
```ts {{ language: 'js' }}
import { CodeInterpreter } from '@e2b/code-interpreter'

const sandbox = await CodeInterpreter.create()
await sandbox.notebook.execCell('x = 1')

const execution = await sandbox.notebook.execCell('x+=1; x')
console.log(execution.text)  // outputs 2

await sandbox.close()
```

```py {{ language: 'python' }}
from e2b_code_interpreter import CodeInterpreter

with CodeInterpreter() as sandbox:
    sandbox.notebook.exec_cell("x = 1")

    execution = sandbox.notebook.exec_cell("x+=1; x")
    print(execution.text)  # outputs 2
```
</CodeGroup>

### 3. Hello World guide
Dive depeer and check out the [JavaScript](/docs/hello-world/js) and [Python](/docs/hello-world/py) Hello World guides to learn how to connect the code interpreter to LLMs.


import ManageBilling from '@/components/ManageBilling'
import SandboxSpec from '@/components/SandboxSpec'

# Pricing

[Manage Billing](/dashboard?tab=billing)

We charge you based on your real sandbox usage. All new users get one-time free $100 worth of usage in credits. {{ className: 'lead' }}

---

# Plans pricing
Additionally to the usage costs, you can also select a tier that includes dedicated support, prioritized features, and higher sandbox limits.

## Hobby tier
**$0/month + usage costs**

- One-time $100 of usage in credits
- Community support
- Up to 1 hour sandbox session length
- Up to 20 concurrently running sandboxes

## Pro tier
**$150/month + usage costs**

- One-time $100 of usage in credits
- Dedicated Slack channel with live Pro support from our team
- Prioritized features
- Customize your [sandbox compute](/docs/sandbox/compute)
- Up to 24 hours sandbox session length
- Up to 100 concurrently running sandboxes


If you need any additional features or resources, please [reach out to us](/docs/getting-help) with your use case.

---

# Compute pricing
We charge per second of a running sandbox.
- vCPU: $0.000014 per second (~$0.05 per hour)
- GiB RAM: $0.0000045 per second (~$0.018 per hour)
- GiB storage: Free

<Note>
1 GiB is equal to 1,024 MiB
</Note>

## Sandbox compute
Pro customers can customize the sandbox with **any combination** of the CPU and RAM based on the following tables.

<Note>
<b>By default your sandbox has 2 vCPU and 512 MiB RAM.</b>

To customize your sandbox compute, you need to build your custom sandbox template using the [E2B CLI](/docs/cli/installation).
Run [`e2b template build`](/docs/cli/commands#template-build) and specify the `--cpu-count` and `--memory-mb` options.

For example this custom build gives your sandbox 8 vCPU and 4GiB of RAM
```sh
e2b template build --cpu-count 8 --memory-mb 4096
```
</Note>

<SandboxSpec/>

<br/>
[Let us know](/docs/getting-help) if you need more powerful compute.


# Current Working Directory

You can set a working directory either for the whole sandbox, a filesystem operation, or a new process.

## Sandbox

If the current working directory for the sandbox is not set, it will default to the home directory - `/home/user`.

<CodeGroupAutoload path="cwd/sandbox" />

## Filesystem

All filesystem operations with relative paths are relative to the current working directory.

<CodeGroupAutoload path="cwd/filesystem"/>

## Process

If you set a working directory for the sandbox, all processes will inherit it. You can override it for each process.

<CodeGroupAutoload path="cwd/process"/>


export const sections = [
  { title: 'Logging', id: 'logging' },
]

# Logging

<LanguageSpecificText>
  ```js {{ language: 'js', text: "E2B package logs only warnings & errors to the console by default. Below is an example of how to fully customize the logging levels.\n\nFeel free to override the logger with your own implementation with debug, info, warn, and error methods." }}
  ```
  ```python {{ language: 'python', text: "E2B package uses the standard Python logging module You can configure the logging level, handlers and format as you would with any other Python application. \n\nBelow is an example of how to configure the logging module to log to the console." }}
  ```
</LanguageSpecificText>

<CodeGroupAutoload path="logging/e2b_logging" isRunnable={false} />


# Download files from the sandbox
Any file inside the sandbox can be downloaded using the `downloadFile`/`download_file` method.

## Use case for downloading files
For example, the download file method is useful for downloading any files produced by LLM. You can let LLM generate and execute code inside the sandbox.
This LLM-generated code might produce some files like charts, CSV files, or PDF files that you want to download to your machine.

<CodeGroupAutoload path="basics/download_file" isRunnable={false}/>



# Setting environment variables

## Global environment variables
You can set the sandbox's global environment variables when initializing a new sandbox.
<CodeGroupAutoload
  path="basics/set_env_vars"
  isRunnable={false}
/>


## Environment variables per process
Alternatively, you can set environment variables when starting a new process. These environment variables are accessible only for this process.

<Note>
Environment variables set when starting a new process have precedence over the environment variables set when initializing the sandbox.
</Note>

<CodeGroupAutoload
  path="basics/process_env_vars"
  isRunnable={true}
/>

## List directory

<CodeGroupAutoload
  path="basics/fs_ls"
  isRunnable={true}
/>

## Create directory

Create directory and all parent directories.

<CodeGroupAutoload
  path="basics/fs_mkdir"
  isRunnable={false}
/>

## Write to file

When writing to a file that doesn't exist, the file will get created.

When writing to a file that already exists, the file will get overwritten.

When writing to a file that's in a directory that doesn't exist, you'll get an error.

<CodeGroupAutoload
  path="basics/fs_write"
  isRunnable={true}
/>

## Read from file

<CodeGroupAutoload
  path="basics/fs_read"
  isRunnable={true}
/>

## Write bytes

<CodeGroupAutoload
  path="basics/fs_write_bytes"
  isRunnable={true}
/>

## Read bytes

<CodeGroupAutoload
  path="basics/fs_read_bytes"
  isRunnable={true}
/>

## Watch directory for changes

<CodeGroupAutoload
  path="basics/fs_watch"
  isRunnable={true}
/>


## Sandbox metadata

You can assign metadata to your sandbox. This metadata will be available if you call `Sandbox.list()`. This can be useful in situation where each of your users have dedicated sandbox and the time between the steps of the integration is long. You can use the metadata to store the user id and reconnect to it later.

<CodeGroupAutoload
  path="basics/metadata"
  isRunnable={true}
/>


# Starting process inside a sandbox

Here are the basic operations you can do with the process inside the sandbox:

- [Start process](/docs/sandbox/api/process#start-process)
- [Stop process](/docs/sandbox/api/process#stop-process)
- [Stdout](/docs/sandbox/api/process#stream-stdout)
- [Stdin](/docs/sandbox/api/process#send-stdin)
- [Stderr](/docs/sandbox/api/process#stream-stderr)
- [On exit](/docs/sandbox/api/process#on-process-exit)

## Start process

<CodeGroupAutoload
  path="basics/process_start"
  isRunnable={true}
/>

## Stop process

<CodeGroupAutoload
  path="basics/process_stop"
  isRunnable={false}
/>

## Stream stdout

Set either stdout handler for the whole sandbox level or per process.

<CodeGroupAutoload
  path="basics/process_stream_stdout"
  isRunnable={false}
/>

## Stream stderr

Set either stderr handler for the whole sandbox level or per process.

<CodeGroupAutoload
  path="basics/process_stream_stderr"
  isRunnable={false}
/>

## On process exit

Set either on exit handler for the whole sandbox level or per process.

<CodeGroupAutoload
  path="basics/process_exit"
  isRunnable={false}
/>

## Send stdin

<CodeGroupAutoload
  path="basics/process_write_stdin"
  isRunnable={true}
/>

# Connect to running sandbox

Disconnect and reconnect later to the same sandbox while keeping it alive {{ className: 'lead' }}

## Description

The sandboxes are by default kept alive only when connected to them. When you disconnect from a sandbox, it will be destroyed.

If you want to keep the sandbox alive even after disconnecting from it, you can explicitly say for how long you want to keep it alive. You can then disconnect from the sandbox and reconnect to it later. This can be useful for example in a **serverless environment** or **chatbot application**.

The duration limit to keep the sandbox alive is 1 hour. If you need more, feel free to [reach out to us](/docs/getting-help) with your use.

## Keep sandbox alive

The example below shows how to disconnect from a running sandbox and reconnect to it again while keeping the sandbox alive.

<CodeGroupAutoload
  path="reconnect/reconnect_1"
  isRunnable={false}
/>

Call the `keep_alive`/`keepAlive` method on the sandbox instance to keep it alive. You can specify the preferred duration, as a multiple of a default time unit, which is
- 1ms in JS
- 1s in Python.

You then disconnect from the sandbox.

<CodeGroupAutoload
  path="reconnect/reconnect_2"
  isRunnable={false}
/>

You can then reconnect to the sandbox from anywhere.

<CodeGroupAutoload
  path="reconnect/reconnect_3"

  isRunnable={false}
/>

## Use sandbox metadata
Sandbox metadata can be very useful to store information about the sandbox. You can use it to store the user ID or any other information you need to keep track of and then use this info for reconnecting to the sandbox. You can read more about sandbox metadata [here](/docs/sandbox/api/metadata).

# Timeouts

The SDK has a number of timeouts that can be configured to control how long the SDK will wait for a response from the E2B servers. **The default is 60 seconds.**

## Timeout creating sandbox
<CodeGroupAutoload path="timeout/timeout_sandbox" />

## Timeout process
<CodeGroupAutoload path="timeout/timeout_process" />

## Timeout filesystem operations
<CodeGroupAutoload path="timeout/timeout_filesystem" />

# Upload files to sandbox
You can upload any file to the sandbox. This is useful if you want to let the LLM work with your files or files of your users. The file will be uploaded to the user's home directory with the same name. If a file with the same name already exists, it will be overwritten.

## Use case for uploading files
A popular workflow is for example to upload a CSV data file and then let the LLM generate and execute Python code that operates with the uploaded CSV file inside the sandbox. This way, you can essentially create your own AI data analyst or code interpreter.

<Note>
We support uploading files up to 100MB at the moment. If you need to upload larger files, please [reach out to us](/docs/getting-help).
</Note>

<CodeGroupAutoload path="basics/upload_file" isRunnable={false}/>



# Sandbox URL
Each sandbox has its own URL that you can use to connect to any service running inside the sandbox.

For example, you can start a server inside the sandbox and connect to it from your browser.

<CodeGroupAutoload path="basics/get_url" isRunnable={true} />


If you want to get an URL for a specific port inside the sandbox, pass the port number to the `getHostname()`/`get_hostname()` method.
<CodeGroupAutoload path="basics/get_url_port" isRunnable={true} />


import SandboxSpec from '@/components/SandboxSpec'

# Sandbox compute
Pro customers can customize the sandbox with **any combination** of the CPU and RAM based on the following tables.

Read a dedicated page to [learn more about pricing](/docs/pricing).

<Note>
<b>By default your sandbox has 2 vCPU and 512 MiB RAM.</b>

To customize your sandbox compute, you need to build your custom sandbox template using the [E2B CLI](/docs/cli/installation).
Run [`e2b template build`](/docs/cli/commands#template-build) and specify the `--cpu-count` and `--memory-mb` options.

For example, this custom build command gives your sandbox 8 vCPU and 4GiB of RAM
```sh
e2b template build --cpu-count 8 --memory-mb 4096
```
</Note>

<SandboxSpec/>

<br/>

[Let us know](/docs/getting-help) if you need more powerful compute.

# Customizing Sandbox
Custom sandboxes allows you to spawn a sandbox with a pre-defined environment by you and then control it with our SDK.

You can build a custom sandbox by creating the [Sandbox Template](/docs/sandbox/templates/overview). Sandbox template is a Dockerfile that describes the environment of your sandbox.

Once you build your custom sandbox template, you can spawn multiple isolated sandboxes from it.

## How it works
1. [Provide the sandbox template file](/docs/sandbox/templates/template-file)
1. [Build a sandbox template from it using our CLI](/docs/guide/custom-sandbox#4-build-custom-sandbox)
1. Get a template ID from the CLI:
    ```sh
    # ... truncated CLI output
    ✅ Building sandbox template 3y5bvra6kgq0kaumgztu finished.
    ```
1. Pass the template ID to our SDK like this:
    <CodeGroup title="Using custom sandbox with SDK" isRunnable={false}>
      ```js {{ language: 'js' }}
      import { Sandbox } from 'e2b'

      // Create new sandbox
      const sandbox = await Sandbox.create({
        template: '<sandbox-template-id>', // You get sandbox template ID from the CLI after you run `$ e2b build`
      })

      // Close sandbox once done
      await sandbox.close()
      ```

      ```python {{ language: 'python' }}
      from e2b import Sandbox

      # Create new sandbox
      sandbox = Sandbox(
        template="<sandbox-template>", # You get sandbox template from the CLI after you run `$ e2b build`
      )

      # Close sandbox once done
      sandbox.close()
      ```
    </CodeGroup>
1. Run the code and we spawn a sandbox based on the template you built in step 2

Now you can do step 4/5 multiple times using the same ID, always creating a separate sandbox instance.


<Note>
Read more on [Sandbox Templates](/docs/sandbox/templates/overview) if you want to create your own custom sandbox.
</Note>

import Image from 'next/image'
import imgModel from '@/images/ai-app-e2b-sandbox-model.png'
import { Check } from 'lucide-react'

import { features } from './features'

# Overview
**The E2B's sandboxes are isolated cloud environments made specifcially for AI code interpreting or code execution.**

The E2B sandboxes are an ideal fit as a playground for AI assistants like coding copilots, code interpreters, AI data analysts, AI browser assistants, and other AI-powered apps.

## Features
<div className="flex flex-col items-start space-y-2">
  {features.map((feature, i) => (
    <span key={i} className="flex items-center space-x-2">
      <Check
        className="w-4 h-4 text-brand-400"
      />
      <span className="text-brand-100">{feature}</span>
    </span>
  ))}
</div>

With more features coming in the future:
- Out-of-the box working monitoring of what's happening inside the sandbox
- LLM Access control to data, tools, and any internet requests
- Statefull sandboxes
- Resumable workflows (pause sandbox and load it later)
- Unlimited long-running sandboxed

## Comparison to other services
With LLMs, it's not safe to let the LLM run code and use tools in the same environment where your application is running.

You need to isolate the LLM from the rest of your app and make sure that the LLM can't access your data, tools, and the internet without you knowing about it or giving it explicit access. You need to make sure that the LLM can run untrusted code safely and install libraries on fly.
The AI apps also often need to run for a long time, and need to be resumable - for example, when waiting for user's consent to make an internet purchase, you need to be able to pause the AI app and resume it later without losing the whole state.

Additionally, the AI apps present need for a new model:
- How can every user of your AI app have the environment described above for themselves?
- How can developers easily manage and orchestrate these environments?
- How can developers easily debug these environments?
- How to let LLMs use the same tools as humans do on their computers (for example browser, code linters, autocomplete, etc)?
- How can developers easily monitor what's happening inside these environments?
- How to scale these environments to billions of instances?

<Image
  src={imgModel}
  className="rounded w-full"
  alt="Separate E2B Sandbox for each instance of your AI app"
  unoptimized
/>

E2B Sandboxes are made exactly to solve these challenges. The sandbox is like an isolated runtime or playground for the LLM. **We give you our SDK to spawn and control these sandboxes.**


## How sandboxes work under the hood
When you create a new sandbox session, we start a small VM in our cloud. This VM is running a Ubuntu OS and it takes about 400-600ms to start it.

Inside this sandbox, your AI app can [run code and start any programs](/docs/sandbox/api/process), access the internet to download or upload data, use the [filesystem](/docs/sandbox/api/filesystem), start long running processes such as web servers, and more.
You can also [upload](/docs/sandbox/api/upload) to sandbox and [download](/docs/sandbox/api/upload) from sandbox any file you want.

To start and control the sandbox, use the [E2B SDK](/docs/getting-started/installation) for Python or JavaScript.

<CodeGroupAutoload
  title="Starting Sandbox"
  path="basics/init"
/>

<Note>
Make sure you have the `E2B_API_KEY` environment variable set with your [API key](/docs/getting-started/api-key).
</Note>


import Image from 'next/image'
import imgCustomSandbox from '@/images/custom-sandbox.png'

# Custom Sandbox

Custom sandboxes allow you to spawn a sandbox with an environment predefined by you and then control it with our SDK.

<Note>
The E2B Sandbox is a secure way to run your AI app. It is a long-running cloud environment where you can let any LLM (GPTs, Claude, local LLMs, etc) use tools exactly like you would do locally.

Read more about E2B Sandboxes [here](/docs/sandbox/overview).
</Note>


## How Custom Sandboxes Work

<Note>
Follow our [guide](/docs/guide/custom-sandbox) on how to create a custom sandbox.
</Note>

1. You build a custom sandbox by creating the [Sandbox Template](/docs/sandbox/templates/template-file) which is a Dockerfile describing the environment of your sandbox.
1. Build a sandbox template from it using our CLI
1. Get a template ID from the CLI:
    ```sh
    # ... truncated CLI output
    ✅ Building sandbox template 3y5bvra6kgq0kaumgztu finished.
    ```
1. Pass the template ID to our SDK like this:
    <CodeGroup title="Using custom sandbox with SDK" isRunnable={false}>
      ```js {{ language: 'js' }}
      import { Sandbox } from 'e2b'

      // Create new sandbox
      const sandbox = await Sandbox.create({
        // You get sandbox template from the CLI after you run `$ e2b build`
        template: '<sandbox-template>',  // $HighlightLine
      })

      // Close sandbox once done
      await sandbox.close()
      ```

      ```python {{ language: 'python' }}
      from e2b import Sandbox

      # Create new sandbox
      sandbox = Sandbox(
        # You get sandbox template from the CLI after you run `$ e2b build`
        template="<sandbox-template>", # $HighlightLine
      )

      # Close sandbox once done
      sandbox.close()
      ```
    </CodeGroup>
1. Run the code and we spawn a sandbox based on the template you built in step 2

Once you build your custom sandbox template, you can spawn multiple isolated sandboxes from it. You can repeat the steps 4, 5 multiple times using the same ID, always creating a separate sandbox instance.

<Image
  src={imgCustomSandbox}
  className="rounded w-full"
  alt="Graphics explaining how custom sandbox works"
  unoptimized
/>

<Note>
Follow [our guide](/docs/guide/custom-sandbox) on how to create a custom sandbox.
</Note>

import Image from 'next/image'
import imgCustomSandbox from '@/images/custom-sandbox.png'

# Template File

The template file is a Dockerfile named `e2b.Dockerfile`. The template file is used to define an environment for your custom sandbox. {{ className: 'lead' }}

<Note>
Follow our [guide](/docs/guide/custom-sandbox) on how to create a custom sandbox.
</Note>

<Image
  src={imgCustomSandbox}
  className="rounded w-full"
  alt="Graphics explaining how custom sandbox works"
  unoptimized
/>

## `e2b.Dockerfile`
The Dockerfile must be Debian based (e.g. Ubuntu). Only the following [Dockerfile commands](https://docs.docker.com/engine/reference/builder/) are supported:
  - `FROM`
  - `ADD`
  - `COPY`
  - `RUN`
  - `WORKDIR`
  - `ARG`

## Example

The following example template file defines a Ubuntu-based sandbox with installed GitHub CLI.


<CodeGroup isFileName title="e2b.Dockerfile" isRunnable={false}>
```sh
# You can use most of the Debian-based base images
FROM ubuntu:22.04

# Install dependencies and customize sandbox
RUN apt update \
	&& apt install sudo

# Install GitHub CLI
RUN type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
RUN curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
	&& sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
	&& echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
	&& sudo apt update \
	&& sudo apt install gh -y
```
</CodeGroup>


# Supported LLMs and AI frameworks
E2B is LLM agnostic - it supports any LLM models and any AI frameworks.

Usually, all you need from the model is just support for tool use. You then use the E2B code interpreter as a tool.
If the LLM doesn't support tool use, you can ask the LLM to respond with Markdown or XML and parse the LLM's output on your own. Then just pass the parsed code from code blocks to the code interpreter.

<Note>
Check out our [cookbook](https://github.com/e2b-dev/e2b-cookbook) for examples.
</Note>

# E2B Documentation

Here you'll find all the guides, concepts, and SDK references for developing with E2B.

## Installation

```bash
# JavaScript/Node.js
npm i @e2b/code-interpreter

# Python
pip install e2b-code-interpreter
```

## What is E2B?

E2B is an [open-source](https://github.com/e2b-dev) infrastructure that allows you to run AI-generated code in secure isolated sandboxes in the cloud.
To start and control sandboxes, use our [Python SDK](https://pypi.org/project/e2b/) or [JavaScript SDK](https://www.npmjs.com/package/e2b).

Some of the typical use cases for E2B are AI data analysis or visualization, running AI-generated code of various languages, playground for coding agents, environment for codegen evals, or running full AI-generated apps like in [Fragments](https://github.com/e2b-dev/fragments).

### Under the hood

The E2B Sandbox is a small isolated VM the can be started very quickly (~150ms). You can think of it as a small computer for the AI model. You can run many sandboxes at once. Typically, you run separate sandbox for each LLM, user, or AI agent session in your app.
For example, if you were building an AI data analysis chatbot, you would start the sandbox for every user session.

## Table of Contents

1. [API Reference](#api-reference)
2. [CLI](#cli)
3. [Code Interpreting](#code-interpreting)
4. [Commands](#commands)
5. [Filesystem](#filesystem)
6. [Quickstart](#quickstart)
7. [Sandbox](#sandbox)
8. [SDK Reference](#sdk-reference)
9. [Support](#support)
10. [Troubleshooting](#troubleshooting) 

import { Guides } from '@/components/Guides'
import { HeroPattern } from '@/components/HeroPattern'
import { Button } from '@/components/Button'

import { Quickstart } from '@/components/Quickstart'
import { Concepts } from '@/components/Concepts'
import { UseCases } from '@/components/UseCases'
import { CodeInterpreting } from '@/components/CodeInterpreting'

<HeroPattern />

# E2B Documentation
Here you'll find all the guides, concepts, and SDK references for developing with E2B.

<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter
```
```bash {{ language: 'python' }}
pip install e2b-code-interpreter
```
</CodeGroup>

## What is E2B?
E2B is an [open-source](https://github.com/e2b-dev) infrastructure that allows you to run AI-generated code in secure isolated sandboxes in the cloud.
To start and control sandboxes, use our [Python SDK](https://pypi.org/project/e2b/) or [JavaScript SDK](https://www.npmjs.com/package/e2b). {{ className: 'lead' }}

Some of the typical use cases for E2B are AI data analysis or visualization, running AI-generated code of various languages, playground for coding agents, environment for codegen evals, or running full AI-generated apps like in [Fragments](https://github.com/e2b-dev/fragments).

### Under the hood
The E2B Sandbox is a small isolated VM the can be started very quickly (~150ms). You can think of it as a small computer for the AI model. You can run many sandboxes at once. Typically, you run separate sandbox for each LLM, user, or AI agent session in your app.
For example, if you were building an AI data analysis chatbot, you would start the sandbox for every user session.

## Quickstart
<Quickstart/>

## Code interpreting with AI
<CodeInterpreting/>

## Learn the core concepts
<Concepts/>



# Connect LLMs to E2B
E2B can work with any LLM and AI framework. The easiest way to connect an LLM to E2B is to use the tool use capabilities of the LLM (sometimes known as function calling).

If the LLM doesn't support tool use, you can, for example, prompt the LLM to output code snippets and then manually extract the code snippets with [RegEx](https://en.wikipedia.org/wiki/Regular_expression).

## Contents
- [OpenAI](#openai)
- [Anthropic](#anthropic)
- [Mistral](#mistral)
- [Groq](#groq)
- [Vercel AI SDK](#vercel-ai-sdk)
- [CrewAI](#crewai)
- [LangChain](#langchain)
- [LlamaIndex](#llamaindex)
- [Ollama](#ollama)

---

## OpenAI

### Simple

<CodeGroup>
```python
# pip install openai e2b-code-interpreter
from openai import OpenAI
from e2b_code_interpreter import Sandbox

# Create OpenAI client
client = OpenAI()
system = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Send messages to OpenAI API
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": system},
        {"role": "user", "content": prompt}
    ]
)

# Extract the code from the response
code = response.choices[0].message.content

# Execute code in E2B Sandbox
if code:
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        result = execution.text

    print(result)
```
</CodeGroup>

### Function calling

<CodeGroup>
```python
# pip install openai e2b-code-interpreter
import json
from openai import OpenAI
from e2b_code_interpreter import Sandbox

# Create OpenAI client
client = OpenAI()
model = "gpt-4o"

# Define the messages
messages = [
    {
        "role": "user",
        "content": "Calculate how many r's are in the word 'strawberry'"
    }
]

# Define the tools
tools = [{
    "type": "function",
    "function": {
        "name": "execute_python",
        "description": "Execute python code in a Jupyter notebook cell and return result",
        "parameters": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "The python code to execute in a single cell"
                }
            },
            "required": ["code"]
        }
    }
}]

# Generate text with OpenAI
response = client.chat.completions.create(
    model=model,
    messages=messages,
    tools=tools,
)

# Append the response message to the messages list
response_message = response.choices[0].message
messages.append(response_message)

# Execute the tool if it's called by the model
if response_message.tool_calls:
    for tool_call in response_message.tool_calls:
        if tool_call.function.name == "execute_python":
            # Create a sandbox and execute the code
            with Sandbox() as sandbox:
                code = json.loads(tool_call.function.arguments)['code']
                execution = sandbox.run_code(code)
                result = execution.text

            # Send the result back to the model
            messages.append({
                "role": "tool",
                "name": "execute_python",
                "content": result,
                "tool_call_id": tool_call.id,
            })

# Generate the final response
final_response = client.chat.completions.create(
    model=model,
    messages=messages
)

print(final_response.choices[0].message.content)
```
</CodeGroup>

---

## Anthropic

### Simple

<CodeGroup>
```python
# pip install anthropic e2b-code-interpreter
from anthropic import Anthropic
from e2b_code_interpreter import Sandbox

# Create Anthropic client
anthropic = Anthropic()
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Send messages to Anthropic API
response = anthropic.messages.create(
    model="claude-3-5-sonnet-20240620",
    max_tokens=1024,
    messages=[
        {"role": "assistant", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]
)

# Extract code from response
code = response.content[0].text

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.logs.stdout

print(result)
```
</CodeGroup>

### Function calling

<CodeGroup>
```python
# pip install anthropic e2b-code-interpreter
from anthropic import Anthropic
from e2b_code_interpreter import Sandbox

# Create Anthropic client
client = Anthropic()
model = "claude-3-5-sonnet-20240620"

# Define the messages
messages = [
    {
        "role": "user",
        "content": "Calculate how many r's are in the word 'strawberry'"
    }
]

# Define the tools
tools = [{
    "name": "execute_python",
    "description": "Execute python code in a Jupyter notebook cell and return (not print) the result",
    "input_schema": {
        "type": "object",
        "properties": {
            "code": {
                "type": "string",
                "description": "The python code to execute in a single cell"
            }
        },
        "required": ["code"]
    }
}]

# Generate text with Anthropic
message = client.messages.create(
    model=model,
    max_tokens=1024,
    messages=messages,
    tools=tools
)

# Append the response message to the messages list
messages.append({
    "role": "assistant",
    "content": message.content
})

# Execute the tool if it's called by the model
if message.stop_reason == "tool_use":
    tool_use = next(block for block in message.content if block.type == "tool_use")
    tool_name = tool_use.name
    tool_input = tool_use.input

    if tool_name == "execute_python":
        with Sandbox() as sandbox:
            code = tool_input['code']
            execution = sandbox.run_code(code)
            result = execution.text

        # Append the tool result to the messages list
        messages.append({
            "role": "user",
            "content": [
                {
                    "type": "tool_result",
                    "tool_use_id": tool_use.id,
                    "content": result,
                }
            ],
        })

# Generate the final response
final_response = client.messages.create(
    model=model,
    max_tokens=1024,
    messages=messages,
    tools=tools
)

print(final_response.content[0].text)
```
</CodeGroup>

---

## Mistral

### Simple

<CodeGroup>
```python
# pip install mistralai e2b-code-interpreter
import os
from mistralai import Mistral
from e2b_code_interpreter import Sandbox

# Create Mistral client
client = Mistral(api_key=os.environ["MISTRAL_API_KEY"])
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Send the prompt to the model
response = client.chat.complete(
    model="codestral-latest",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]
)

# Extract the code from the response
code = response.choices[0].message.content

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)
```
</CodeGroup>

### Function calling

<CodeGroup>
```python
# pip install mistralai e2b-code-interpreter
import os
import json
from mistralai import Mistral
from e2b_code_interpreter import Sandbox

# Create Mistral client
client = Mistral(api_key=os.environ["MISTRAL_API_KEY"])
model = "mistral-large-latest"
messages = [
    {
        "role": "user",
        "content": "Calculate how many r's are in the word 'strawberry'"
    }
]

# Define the tools
tools = [{
    "type": "function",
    "function": {
        "name": "execute_python",
        "description": "Execute python code in a Jupyter notebook cell and return result",
        "parameters": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "The python code to execute in a single cell"
                }
            },
            "required": ["code"]
        }
    }
}]

# Send the prompt to the model
response = client.chat.complete(
    model=model,
    messages=messages,
    tools=tools
)

# Append the response message to the messages list
response_message = response.choices[0].message
messages.append(response_message)

# Execute the tool if it's called by the model
if response_message.tool_calls:
    for tool_call in response_message.tool_calls:
        if tool_call.function.name == "execute_python":
            # Create a sandbox and execute the code
            with Sandbox() as sandbox:
                code = json.loads(tool_call.function.arguments)['code']
                execution = sandbox.run_code(code)
                result = execution.text

            # Send the result back to the model
            messages.append({
                "role": "tool",
                "name": "execute_python",
                "content": result,
                "tool_call_id": tool_call.id,
            })

# Generate the final response
final_response = client.chat.complete(
    model=model,
    messages=messages,
)

print(final_response.choices[0].message.content)
```
</CodeGroup>

---

## Groq
<CodeGroup>
```python

# pip install groq e2b-code-interpreter
import os
from groq import Groq
from e2b_code_interpreter import Sandbox

api_key = os.environ["GROQ_API_KEY"]

# Create Groq client
client = Groq(api_key=api_key)
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry.'"

# Send the prompt to the model
response = client.chat.completions.create(
    model="llama3-70b-8192",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt},
    ]
)

# Extract the code from the response
code = response.choices[0].message.content

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)

```
</CodeGroup>

---

## Vercel AI SDK
Vercel's [AI SDK](https://sdk.vercel.ai) offers support for multiple different LLM providers through a unified JavaScript interface that's easy to use.

### Simple

<CodeGroup>
```js
// npm install ai @ai-sdk/openai @e2b/code-interpreter
import { openai } from '@ai-sdk/openai'
import { generateText } from 'ai'
import { Sandbox } from '@e2b/code-interpreter'

// Create OpenAI client
const model = openai('gpt-4o')
const system = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
const prompt = "Calculate how many r's are in the word 'strawberry'"

// Generate code with OpenAI
const { text: code } = await generateText({
  model,
  system,
  prompt
})

// Run the code in E2B Sandbox
const sandbox = await Sandbox.create()
const { text, results, logs, error } = await sandbox.runCode(code)

console.log(text)
```
</CodeGroup>

### Function calling

<CodeGroup>
```js
// npm install ai @ai-sdk/openai zod @e2b/code-interpreter
import { openai } from '@ai-sdk/openai'
import { generateText } from 'ai'
import z from 'zod'
import { Sandbox } from '@e2b/code-interpreter'

// Create OpenAI client
const model = openai('gpt-4o')

const prompt = "Calculate how many r's are in the word 'strawberry'"

// Generate text with OpenAI
const { text } = await generateText({
  model,
  prompt,
  tools: {
    // Define a tool that runs code in a sandbox
    execute_python: {
      description: 'Execute python code in a Jupyter notebook cell and return result',
      parameters: z.object({
        code: z.string().describe('The python code to execute in a single cell'),
      }),
      execute: async ({ code }) => {
        // Create a sandbox, execute LLM-generated code, and return the result
        const sandbox = await Sandbox.create()
        const { text, results, logs, error } = await sandbox.runCode(code)
        return results
      },
    },
  },
  // This is required to feed the tool call result back to the LLM
  maxSteps: 2
})

console.log(text)
```
</CodeGroup>

---

## CrewAI
[CrewAI](https://crewai.com/) is a platform for building AI agents.

<CodeGroup>
```python
# pip install crewai e2b-code-interpreter
from crewai.tools import tool
from crewai import Agent, Task, Crew, LLM
from e2b_code_interpreter import Sandbox

# Update tool definition using the decorator
@tool("Python Interpreter")  
def execute_python(code: str) -> str:
    """
    Execute Python code and return the results.
    """
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

# Define the agent
python_executor = Agent(
    role='Python Executor',
    goal='Execute Python code and return the results',
    backstory='You are an expert Python programmer capable of executing code and returning results.',
    tools=[execute_python],
    llm=LLM(model="gpt-4o")
)

# Define the task
execute_task = Task(
    description="Calculate how many r's are in the word 'strawberry'",
    agent=python_executor,
    expected_output="The number of r's in the word 'strawberry'"
)

# Create the crew
code_execution_crew = Crew(
    agents=[python_executor],
    tasks=[execute_task],
    verbose=True,
)

# Run the crew
result = code_execution_crew.kickoff()
print(result)
```
</CodeGroup>

---

## LangChain
[LangChain](https://langchain.com/) offers support multiple different LLM providers.

### Simple

<CodeGroup>
```python
# pip install langchain langchain-openai e2b-code-interpreter
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from e2b_code_interpreter import Sandbox

system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Create LangChain components
llm = ChatOpenAI(model="gpt-4o")
prompt_template = ChatPromptTemplate.from_messages([
    ("system", system_prompt),
    ("human", "{input}")
])

output_parser = StrOutputParser()

# Create the chain
chain = prompt_template | llm | output_parser

# Run the chain
code = chain.invoke({"input": prompt})

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)
```
</CodeGroup>

### Agent

<CodeGroup>
```python
# pip install langchain langchain-openai e2b-code-interpreter
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_openai import ChatOpenAI
from e2b_code_interpreter import Sandbox

system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Define the tool
@tool
def execute_python(code: str):
    """
    Execute python code in a Jupyter notebook.
    """
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

# Define LangChain components
prompt_template = ChatPromptTemplate.from_messages([
    ("system", system_prompt),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}"),
])

tools = [execute_python]
llm = ChatOpenAI(model="gpt-4o", temperature=0)

agent = create_tool_calling_agent(llm, tools, prompt_template)
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# Run the agent
agent_executor.invoke({"input": prompt})
```
</CodeGroup>

### Function calling

<CodeGroup>
```python
# pip install langchain langchain-openai e2b-code-interpreter
from langchain_openai import ChatOpenAI
from langchain.tools import Tool
from langchain.schema import HumanMessage, AIMessage, FunctionMessage
from e2b_code_interpreter import Sandbox

def execute_python(code: str):
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

# Define a tool that uses the E2B Sandbox
e2b_sandbox_tool = Tool(
    name="execute_python",
    func=execute_python,
    description="Execute python code in a Jupyter notebook cell and return result"
)

# Initialize the language model and bind the tool
llm = ChatOpenAI(model="gpt-4o").bind_tools([e2b_sandbox_tool])

# Define the messages
messages = [
    HumanMessage(content="Calculate how many 'r's are in the word 'strawberry'.")
]

# Run the model with a prompt
result = llm.invoke(messages)
messages.append(AIMessage(content=result.content))

# Check if the model called the tool
if result.additional_kwargs.get('tool_calls'):
    tool_call = result.additional_kwargs['tool_calls'][0]
    if tool_call['function']['name'] == "execute_python":
        code = tool_call['function']['arguments']
        execution_result = execute_python(code)

        # Send the result back to the model
        messages.append(
            FunctionMessage(name="execute_python", content=execution_result)
        )

final_result = llm.invoke(messages)
print(final_result.content)
```
</CodeGroup>

---

## LlamaIndex
[LlamaIndex](https://www.llamaindex.ai/) offers support multiple different LLM providers.
<CodeGroup>
```python
# pip install llama-index e2b-code-interpreter
from llama_index.core.tools import FunctionTool
from llama_index.llms.openai import OpenAI
from llama_index.core.agent import ReActAgent
from e2b_code_interpreter import Sandbox

# Define the tool
def execute_python(code: str):
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

e2b_sandbox_tool = FunctionTool.from_defaults(
    name="execute_python",
    description="Execute python code in a Jupyter notebook cell and return result",
    fn=execute_python
)

# Initialize LLM
llm = OpenAI(model="gpt-4o")

# Initialize ReAct agent
agent = ReActAgent.from_tools([e2b_sandbox_tool], llm=llm, verbose=True)
agent.chat("Calculate how many r's are in the word 'strawberry'")
```
</CodeGroup>

## Ollama

<CodeGroup>
```python
# pip install ollama
import ollama
from e2b_code_interpreter import Sandbox

# Send the prompt to the model
response = ollama.chat(
    model="llama3.2",
    messages=[{
        "role": "system",
        "content": "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
    },
    {
        "role": "user",
        "content": "Calculate how many r's are in the word 'strawberry'"
    }
])

# Extract the code from the response
code = response['message']['content']

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.logs.stdout

print(result)
```
</CodeGroup>


# Install custom packages

There are two ways to install custom packages in the E2B Sandbox.

1. [Create custom sandbox with preinstalled packages](#create-a-custom-sandbox).
2. [Install packages during the sandbox runtime](#install-packages-during-the-sandbox-runtime).

---

## Create a custom sandbox

Use this option if you know beforehand what packages you need in the sandbox.

Prerequisites:
- E2B CLI
- Docker running

<Note>
Custom sandbox template is a Docker image that we automatically convert to a sandbox that you can then start with our SDK.
</Note>


### 1. Install E2B CLI
Install the [E2B CLI](https://npmjs.com/package/@e2b/cli) globally on your machine with NPM.
<CodeGroup isTerminalCommand>
```bash
npm i -g @e2b/cli
```
</CodeGroup>

### 2. Login to E2B CLI
Before you can create a custom sandbox, you need to login to E2B CLI.
<CodeGroup isTerminalCommand>
```bash
e2b auth login
```
</CodeGroup>

### 2. Initialize a sandbox template
<CodeGroup isTerminalCommand>
```bash
e2b template init
```
</CodeGroup>

### 3. Specify the packages you need in `e2b.Dockerfile`
Edit the E2B Dockerfile to install the packages you need.

<Note>
You need to use the `e2bdev/code-interpreter:latest` base image.
</Note>

<CodeGroup title="e2b.Dockerfile">
```bash
FROM e2bdev/code-interpreter:latest

RUN pip install cowsay
RUN npm install cowsay
```
</CodeGroup>

### 4. Build the sandbox template
Run the following command to build the sandbox template.
<CodeGroup isTerminalCommand>
```bash
e2b template build -c "/root/.jupyter/start-up.sh"
```
</CodeGroup>

This will take a while, as it convert the Docker image to a sandbox which is a small VM.
At the end of the process you will see the sandbox ID like this:
```
Running postprocessing. It can take up to few minutes.

Postprocessing finished.

✅ Building sandbox template YOUR_TEMPLATE_ID finished.
```

### 5. Start your custom sandbox
Now you can pass the template ID to the SDK to start your custom sandbox.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = Sandbox.create({
  template: 'YOUR_TEMPLATE_ID',
})
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox(template='YOUR_TEMPLATE_ID')
```
</CodeGroup>

---


## Install packages during the sandbox runtime
Use this option if don't know beforehand what packages you need in the sandbox. You can install packages with the package manager of your choice.

<Note>
The packages installed during the runtime are available only in the running sandbox instance.
When you start a new sandbox instance, the packages are not be available.
</Note>

### 1. Install Python packages with PIP
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = Sandbox.create()
sbx.commands.run('pip install cowsay') // This will install the cowsay package
sbx.runCode(`
  import cowsay
  cowsay.cow("Hello, world!")
`)
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
sbx.commands.run("pip install cowsay") # This will install the cowsay package
sbx.run_code("""
  import cowsay
  cowsay.cow("Hello, world!")
""")
```
</CodeGroup>


### 2. Install Node.js packages with NPM
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = Sandbox.create()
sbx.commands.run('npm install cowsay') // This will install the cowsay package
sbx.runCode(`
  const cowsay = require('cowsay')
  console.log(cowsay.say({ text: 'Hello, world!' }))
`, { language: 'javascript' })
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
sbx.commands.run("npm install cowsay") # This will install the cowsay package
sbx.run_code("""
  import { say } from 'cowsay'
  console.log(say('Hello, world!'))
""", language="javascript")
```
</CodeGroup>


### 3. Install packages with package manager of your choice
Since E2B Sandboxes are Debian based machines, you can use any package manager supported by Debian.
You just need to make sure that the package manager is already installed in the sandbox.

For example, to install `curl` and `git`, you can use the following commands:

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = Sandbox.create()
await sbx.commands.run('apt-get update && apt-get install -y curl git')
```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
sbx.commands.run("apt-get update && apt-get install -y curl git")
```
</CodeGroup>

# Migrating E2B SDK from v0.* to v1.0 using Grit

This guide explains how to migrate your project from **E2B SDK `v0.*`** to **E2B SDK `v1.0`** using [Grit](https://www.grit.io/) and our custom migrations.
This mostly automates the process of searching through your codebase to update code to migrate to the new SDK without errors. However, this is not a 100% accurate process, and you should expect human intervention to be required.

## Step 1: Install the Grit CLI

You can install **Grit CLI** using one of the following methods:

### Option 1: Install via NPM

```bash
npm install --location=global @getgrit/cli
```

### Option 2: Install via bash script

```bash
curl -fsSL https://docs.grit.io/install | bash
```

## Step 2: Prepare for migration

Before applying the migration, format your code and commit your changes to ensure you have a stable state to revert to if necessary.

```bash
git add .
git commit -m "Last changes made"
```

## Step 3: Run Grit with the Custom Pattern

To apply the custom migration pattern, run the following command for your project. The `--interactive` flag allows you to review each change as it is made.

### For JavaScript/TypeScript:

```bash
grit apply github.com/e2b-dev/e2b-cookbook#e2b_v0_to_v1_js --interactive
```

### For Python:

```bash
grit apply github.com/e2b-dev/e2b-cookbook#e2b_v0_to_v1_py --interactive
```

## Step 5: Review changes

Once the migration is applied, review the changes for possible mistakes, including code that was broken (false positives) or outdated code that was not fixed (false negatives) by the migration. Such issues you may encounter include:

- ⚠️ If non-E2B objects with `.close()` methods, `.id` attributes, etc. exist in files that import E2B libraries, they will be incorrectly changed. You need to reject these changes manually.
- ⚠️ The output structure of `Sandbox.list()` has changed in the new SDK. You must manually rewrite your code to account for this.
- ⚠️ The global `cwd` option no longer exists when creating a Sandbox. You must manually rewrite your code to include the `cwd` option with each command.

You should manually review all changes made by Grit to fix these "gotchas" and others which are sure to exist.

## Step 6: Commit changes

Before commiting the changes made by Grit, it's recommended to re-format the generated code following the convention of your choice. After verifying the changes and reformatting code, commit them to Git.

```bash
git add .
git commit -m "Migrate project to E2B SDK v1.0"
```

## Step 7: Test your application

Now, thoroughly test your application to make sure the migration is successful and everything is functioning as expected.

---

By following these steps, you can easily migrate your TypeScript or Python project from **E2B SDK `v0.*`** to **E2B SDK `v1.0`** using Grit. Don’t forget to use version control to track all changes throughout the process and to thoroughly test your application after migrating.


# Running your first Sandbox

This guide will show you how to start your first E2B Sandbox.

## 1. Create E2B account

Every new E2B account get $100 in credits. You can sign up [here](/auth/sign-up).


## 2. Set your environment variables
1. Navigate to the [E2B Dashboard](/dashboard?tab=keys).
2. Copy your API key.
3. Paste your E2B API key into your `.env` file.
<CodeGroup title=".env">
```bash
E2B_API_KEY=e2b_***
```
</CodeGroup>


## 3. Install E2B SDK
Install the E2B SDK to your project by running the following command in your terminal.
<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter dotenv
```
```bash {{ language: 'python' }}
pip install e2b-code-interpreter python-dotenv
```
</CodeGroup>

## 4. Write code for starting Sandbox
We'll write the minimal code for starting Sandbox, executing Python inside it and listing all files inside the root directory.
<CodeGroup>
```ts {{ language: 'js', description: 'index.ts' }}
import 'dotenv/config'
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create() // By default the sandbox is alive for 5 minutes
const execution = await sbx.runCode('print("hello world")') // Execute Python inside the sandbox
console.log(execution.logs)

const files = await sbx.files.list('/')
console.log(files)
```

```python {{ language: 'python', description: 'main.py' }}
from dotenv import load_dotenv
load_dotenv()
from e2b_code_interpreter import Sandbox

sbx = Sandbox() # By default the sandbox is alive for 5 minutes
execution = sbx.run_code("print('hello world')") # Execute Python inside the sandbox
print(execution.logs)

files = sbx.files.list("/")
print(files)
```
</CodeGroup>

## 5. Start your first E2B Sandbox
Run the code with the following command:
<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npx tsx ./index.ts
```
```bash {{ language: 'python' }}
python main.py
```
</CodeGroup>




# Upload & downloads files

E2B Sandbox allows you to upload and downloads file to and from the Sandbox.

An alternative way to get your data to the sandbox is to create a [custom sandbox template](/docs/sandbox-template).


## Upload file
<CodeGroup>
```ts {{ language: 'js' }}
import { Sandbox } from '@e2b/code-interpreter'

// Read local file relative to the current working directory
const content = fs.readFileSync('local/file')

const sbx = await Sandbox.create()
// Upload file to the sandbox to absolute path '/home/user/my-file'
await sbx.files.write('/home/user/my-file', content)
```

```python {{ language: 'python' }}
from e2b_code_interpreter import Sandbox

sbx = Sandbox()

# Read local file relative to the current working directory
with open("local/file", "rb") as file:
   # Upload file to the sandbox to absolute path '/home/user/my-file'
	sbx.files.write("/home/user/my-file", file)
```
</CodeGroup>


## Upload multiple files
Currently, if you want to upload multiple files, you need to upload each one of the separately.
We're working on a better solution.

<CodeGroup>
```ts {{ language: 'js' }}
import { Sandbox } from '@e2b/code-interpreter'

// Read local file relative to the current working directory
const fileA = fs.readFileSync('local/file/a')
const fileB = fs.readFileSync('local/file/b')

const sbx = await Sandbox.create()
// Upload file A to the sandbox to absolute path '/home/user/my-file-a'
await sbx.files.write('/home/user/my-file-a', fileA)
// Upload file B to the sandbox to absolute path '/home/user/my-file-b'
await sbx.files.write('/home/user/my-file-b', fileB)
```

```python {{ language: 'python' }}
from e2b_code_interpreter import Sandbox

sbx = Sandbox()

# Read local file relative to the current working directory
with open("local/file/a", "rb") as file:
   # Upload file to the sandbox to absolute path '/home/user/my-file-a'
	sbx.files.write("/home/user/my-file-a", file)

with open("local/file/b", "rb") as file:
   # Upload file to the sandbox to absolute path '/home/user/my-file-b'
	sbx.files.write("/home/user/my-file-b", file)
```
</CodeGroup>


## Upload directory
We currently don't support an easy way to upload a whole directory.
You need to upload each file separately.

We're working on a better solution.

---

## Download file
To download a file, you need to first get the file's content and then write it to a local file.

<CodeGroup>
```ts {{ language: 'js' }}
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
// Download file from the sandbox to absolute path '/home/user/my-file'
const content = await sbx.files.read('/home/user/my-file')
// Write file to local path relative to the current working directory
fs.writeFileSync('local/file', content)
```

```python {{ language: 'python' }}
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
# Download file from the sandbox to absolute path '/home/user/my-file'
content = sbx.files.read('/home/user/my-file')
# Write file to local path relative to the current working directory
with open('local/file', 'w') as file:
    file.write(content)
```
</CodeGroup>

## Download multiple files
To download multiple files, you need to download each one of them separately from the sandbox.

We're working on a better solution.


<CodeGroup>
```ts {{ language: 'js' }}
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
// Download file A from the sandbox by absolute path '/home/user/my-file-a'
const contentA = await sbx.files.read('/home/user/my-file-a')
// Write file A to local path relative to the current working directory
fs.writeFileSync('local/file/a', contentA)

// Download file B from the sandbox by absolute path '/home/user/my-file-b'
const contentB = await sbx.files.read('/home/user/my-file-b')
// Write file B to local path relative to the current working directory
fs.writeFileSync('local/file/b', contentB)
```

```python {{ language: 'python' }}
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
# Download file A from the sandbox by absolute path '/home/user/my-file-a'
contentA = sbx.files.read('/home/user/my-file-a')
# Write file A to local path relative to the current working directory
with open('local/file/a', 'w') as file:
    file.write(contentA)

# Download file B from the sandbox by absolute path '/home/user/my-file-b'
contentB = sbx.files.read('/home/user/my-file-b')
# Write file B to local path relative to the current working directory
with open('local/file/b', 'w') as file:
    file.write(contentB)
```
</CodeGroup>

## Download directory
We currently don't support an easy way to download a whole directory.
You need to download each file separately.

We're working on a better solution.


# Connect to running sandbox

If you have a running sandbox, you can connect to it using the `Sandbox.connect()` method and then start controlling it with our SDK.

This is useful if you want to, for example, reuse the same sandbox instance for the same user after a short period of inactivity.

## 1. Get the sandbox ID
To connect to a running sandbox, you first need to retrieve its ID. You can do this by calling the `Sandbox.list()` method.

<CodeGroup>
```js
import { Sandbox } from "@e2b/code-interpreter"

// Get all running sandboxes
const runningSandboxes = await Sandbox.list() // $HighlightLine

if (runningSandboxes.length === 0) {
  throw new Error("No running sandboxes found")
}

// Get the ID of the sandbox you want to connect to
const sandboxId = runningSandboxes[0].sandboxId
```

```python
from e2b_code_interpreter import Sandbox

# Get all running sandboxes
running_sandboxes = Sandbox.list() # $HighlightLine

# Get the ID of the sandbox you want to connect to
if len(running_sandboxes) == 0:
  raise Exception("No running sandboxes found")

# Get the ID of the sandbox you want to connect to
sandbox_id = running_sandboxes[0].sandbox_id
```
</CodeGroup>

## 2. Connect to the sandbox

Now that you have the sandbox ID, you can connect to the sandbox using the `Sandbox.connect()` method.

<CodeGroup>
```js
import { Sandbox } from "@e2b/code-interpreter"

// Get all running sandboxes
const runningSandboxes = await Sandbox.list()

if (runningSandboxes.length === 0) {
  throw new Error("No running sandboxes found")
}

// Get the ID of the sandbox you want to connect to
const sandboxId = runningSandboxes[0].sandboxId

// Connect to the sandbox
const sandbox = await Sandbox.connect(sandboxId) // $HighlightLine
// Now you can use the sandbox as usual
// ...

```
```python
from e2b_code_interpreter import Sandbox

# Get all running sandboxes
running_sandboxes = Sandbox.list()

# Get the ID of the sandbox you want to connect to
if len(running_sandboxes) == 0:
  raise Exception("No running sandboxes found")

sandbox_id = running_sandboxes[0].sandbox_id

# Connect to the sandbox
sandbox = Sandbox.connect(sandbox_id) # $HighlightLine
# Now you can use the sandbox as usual
# ...

```
</CodeGroup>


# Environment variables
This page covers how to set and use environment variables in a sandbox, and default environment variables inside the sandbox.

## Default environment variables
### Knowing if you are inside a sandbox

Sometimes it's useful to know if the code is running inside a sandbox. Upon creating a sandbox, an environment variable `E2B_SANDBOX` is automatically set to `true`.
You can try it out by running the following code in the sandbox:

<CodeGroup>
```js
const sandbox = await Sandbox.create()
const result = await sandbox.commands.run('echo $E2B_SANDBOX')
```
```python
sandbox = Sandbox()
result = sandbox.commands.run("echo $E2B_SANDBOX")
```
</CodeGroup>


---

## Setting environment variables
There are 3 ways to set environment variables in a sandbox:
1. [Global environment variables when creating the sandbox](/docs/sandbox/environment-variables#1-global-environment-variables-when-creating-the-sandbox).
2. [When running code in the sandbox](/docs/sandbox/environment-variables#2-setting-environment-variables-when-running-code).
3. [When running commands in the sandbox](/docs/sandbox/environment-variables#3-setting-environment-variables-when-running-commands).

### 1. Global environment variables
You can set global environment variables when creating a sandbox.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create({
  env: { // $HighlightLine
    MY_VAR: 'my_value', // $HighlightLine
  }, // $HighlightLine
})
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox(
  env={ # $HighlightLine
    'MY_VAR': 'my_value', # $HighlightLine
  }, # $HighlightLine
)
```
</CodeGroup>

### 2. Setting environment variables when running code
You can set environment variables for specific code execution call in the sandbox.

<Note>
If you had a global environment variable with the same name, it will be overridden.
</Note>

<CodeGroup>
```js
const sandbox = await Sandbox.create()
const result = await sandbox.runCode('import os; print(os.environ.get("MY_VAR"))', {
  envs: { // $HighlightLine
    MY_VAR: 'my_value', // $HighlightLine
  }, // $HighlightLine
})
```
```python
sandbox = Sandbox()
result = sandbox.run_code(
    'import os; print(os.environ.get("MY_VAR"))',
    envs={ # $HighlightLine
        'MY_VAR': 'my_value' # $HighlightLine
    } # $HighlightLine
)
```
</CodeGroup>

### 3. Setting environment variables when running commands
You can set environment variables for specific command execution in the sandbox.

<Note>
If you had a global environment variable with the same name, it will be overridden.
</Note>

<CodeGroup>
```js
const sandbox = await Sandbox.create()
sandbox.commands.run('echo $MY_VAR', {
  envs: { // $HighlightLine
    MY_VAR: '123', // $HighlightLine
  }, // $HighlightLine
})
```
```python
sandbox = Sandbox()
sandbox.commands.run(
    'echo $MY_VAR',
    envs={ # $HighlightLine
        'MY_VAR': '123' # $HighlightLine
    } # $HighlightLine
)
```
</CodeGroup>


# Internet access

Every sandbox has access to the internet and can be reached by a public URL.


## Sandbox public URL
Every sandbox has a public URL that can be used to access running services inside the sandbox.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// You need to always pass a port number to get the host
const host = sandbox.getHost(3000) // $HighlightLine
console.log(`https://${host}`)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

# You need to always pass a port number to get the host
host = sandbox.get_host(3000) # $HighlightLine
print(f'https://{host}')
```
</CodeGroup>

The code above will print something like this:

<CodeGroup>
```bash {{ language: 'js' }}
https://3000-i62mff4ahtrdfdkyn2esc-b0b684e9.e2b.dev
```
```bash {{ language: 'python' }}
https://3000-i62mff4ahtrdfdkyn2esc-b0b684e9.e2b.dev
```
</CodeGroup>

The first leftmost part of the host is the port number we passed to the method.

## Connecting to a server running inside the sandbox
You can start a server inside the sandbox and connect to it using the approach above.

In this example we will start a simple HTTP server that listens on port 3000 and responds with the content of the directory where the server is started.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()

// Start a simple HTTP server inside the sandbox.
const process = await sandbox.commands.run('python -m http.server 3000', { background: true })
const host = sandbox.getHost(3000)
const url = `https://${host}`
console.log('Server started at:', url)

// Fetch data from the server inside the sandbox.
const response = await fetch(url);
const data = await response.text();
console.log('Response from server inside sandbox:', data);

// Kill the server process inside the sandbox.
await process.kill()
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()

# Start a simple HTTP server inside the sandbox.
process = sandbox.commands.run("python -m http.server 3000", background=True)
host = sandbox.get_host(3000)
url = f"https://{host}"
print('Server started at:', url)

# Fetch data from the server inside the sandbox.
response = sandbox.commands.run(f"curl {url}")
data = response.stdout
print("Response from server inside sandbox:", data)

# Kill the server process inside the sandbox.
process.kill()
```
</CodeGroup>


This output will look like this:
<CodeGroup>
```bash {{ language: 'js' }}
Server started at: https://3000-ip3nfrvajtqu5ktoxugc7-b0b684e9.e2b.dev
Response from server inside sandbox: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directory listing for /</title>
</head>
<body>
<h1>Directory listing for /</h1>
<hr>
<ul>
<li><a href=".bash_logout">.bash_logout</a></li>
<li><a href=".bashrc">.bashrc</a></li>
<li><a href=".profile">.profile</a></li>
</ul>
<hr>
</body>
</html>
```
```bash {{ language: 'python' }}
Server started at: https://3000-ip3nfrvajtqu5ktoxugc7-b0b684e9.e2b.dev
Response from server inside sandbox: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directory listing for /</title>
</head>
<body>
<h1>Directory listing for /</h1>
<hr>
<ul>
<li><a href=".bash_logout">.bash_logout</a></li>
<li><a href=".bashrc">.bashrc</a></li>
<li><a href=".profile">.profile</a></li>
</ul>
<hr>
</body>
</html>
```
</CodeGroup>


import Link from 'next/link'

# List running sandboxes

You can list all running sandboxes using the `Sandbox.list()` method.

<Note>
Once you have information about running sandbox, you can [connect](/docs/sandbox/connect) to it using the `Sandbox.connect()` method.
</Note>

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create({
  metadata: {
    name: 'My Sandbox',
  },
})

const runningSandboxes = await Sandbox.list() // $HighlightLine
const runningSandbox = runningSandboxes[0]
console.log('Running sandbox metadata:', runningSandbox.metadata)
console.log('Running sandbox id:', runningSandbox.sandboxId)
console.log('Running sandbox started at:', runningSandbox.startedAt)
console.log('Running sandbox template id:', runningSandbox.templateId)
```
```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox({
  metadata: {
    name: 'My Sandbox',
  },
})

running_sandboxes = sandbox.list() # $HighlightLine
running_sandbox = running_sandboxes[0]
print('Running sandbox metadata:', running_sandbox.metadata)
print('Running sandbox id:', running_sandbox.sandbox_id)
print('Running sandbox started at:', running_sandbox.started_at)
print('Running sandbox template id:', running_sandbox.template_id)
```
</CodeGroup>

The code above will output something like this:
<CodeGroup isTerminalCommand>
```bash {{ language: "js" }}
Running sandbox metadata: {
  name: "My Sandbox",
}
Running sandbox id: ixjj3iankaishgcge4jwn-b0b684e9
Running sandbox started at: 2024-10-15T21:13:07.311Z
Running sandbox template id: 3e4rngfa34txe0gxc1zf
```
```bash {{ language: "python" }}
Running sandbox metadata: {'name': 'My Sandbox'}
Running sandbox id: ixjj3iankaishgcge4jwn-b0b684e9
Running sandbox started at: 2024-10-15 21:13:07.311861+00:00
Running sandbox template id: 3e4rngfa34txe0gxc1zf
```
</CodeGroup>


## Filtering sandboxes

You can filter sandboxes by specifying <Link href="/docs/sandbox/metadata">Metadata</Link> key value pairs.
Specifying multiple key value pairs will return sandboxes that match all of them.

This can be useful when you have a large number of sandboxes and want to find only specific ones. The filtering is performed on the server.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox with metadata.
const sandbox = await Sandbox.create({
  metadata: {
    env: 'dev', // $HighlightLine
    app: 'my-app', // $HighlightLine
    userId: '123', // $HighlightLine
  },
})

// List running sandboxes that has `userId` key with value `123` and `env` key with value `dev`.
const runningSandboxes = await Sandbox.list({
  query: {
    metadata: { userId: '123', env: 'dev' }, // $HighlightLine
  },
})
```
```python
from e2b_code_interpreter import Sandbox

# Create sandbox with metadata.
sandbox = Sandbox(
    metadata={
        "env": "dev",  # $HighlightLine
        "app": "my-app",  # $HighlightLine
        "user_id": "123",  # $HighlightLine
    },
)

# List running sandboxes that has `userId` key with value `123` and `env` key with value `dev`.
running_sandboxes = Sandbox.list(
    query=SandboxQuery(
        metadata={
            "userId": "123",  # $HighlightLine
            "env": "dev",  # $HighlightLine
        }
    ),
)
```
</CodeGroup>


import Link from 'next/link'

# Sandbox metadata

Metadata is a way to attach arbitrary key-value pairs for a sandbox.

This is useful in various scenarios, for example:
- Associate a sandbox with a user session.
- Store custom user data for a sandbox like API keys.
- Associate a sandbox with a user ID and [connect to it later](/docs/sandbox/connect).

You specify metadata when creating a sandbox and can access it later through listing running sandboxes with `Sandbox.list()` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox with metadata.
const sandbox = await Sandbox.create({
  metadata: {
    userId: '123', // $HighlightLine
  },
})

// List running sandboxes and access metadata.
const runningSandboxes = await Sandbox.list()
// Will print:
// {
//   'userId': '123',
// }
console.log(runningSandboxes[0].metadata)
```
```python
from e2b_code_interpreter import Sandbox

# Create sandbox with metadata.
sandbox = Sandbox(
  metadata={
    'userId': '123', # $HighlightLine
  },
)

# List running sandboxes and access metadata.
running_sandboxes = Sandbox.list()
# Will print:
# {
#   'userId': '123',
# }
print(running_sandboxes[0].metadata)
```
</CodeGroup>

## Filtering sandboxes by metadata
You can also filter sandboxes by metadata, you can find more about it <Link href="/docs/sandbox/list#filtering-sandboxes">here</Link>.

# Sandbox metrics

<Note>
This feature is in a private beta.
</Note>

The sandbox metrics allows you to get information about the sandbox's CPU and memory usage.

## 1. Installation

To get sandbox metrics, you need to install the beta version of the SDKs and CLI.

### 1.1. Installing the beta version of the SDKs

<CodeGroup isTerminalCommand>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter@beta
#
# or use Core: https://github.com/e2b-dev/e2b
# npm i e2b@beta
```

```bash {{ language: 'python' }}
pip install e2b-code-interpreter==1.2.0b0
#
# or use Core: https://github.com/e2b-dev/e2b
# pip install e2b==1.2.0b0
```
</CodeGroup>

### 1.2. Installing the beta version of the CLI

<CodeGroup isTerminalCommand>
```bash {{ language: 'bash' }}
npm i -g @e2b/cli@beta
```
</CodeGroup>

## 2. Getting sandbox metrics
Getting the metrics of a sandbox returns an array of timestamped metrics containing CPU and memory usage information.
The metrics are collected at the start of the sandbox, then every 2 seconds, and finally right before the sandbox is deleted.

### 2.1. Getting sandbox metrics using the SDKs

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

const sbx = await Sandbox.create()
console.log('Sandbox created', sbx.sandboxId)

const metrics = await sbx.getMetrics() // $HighlightLine

// You can also get the metrics by sandbox ID:
// const metrics = await Sandbox.getMetrics(sbx.sandboxId)

console.log('Sandbox metrics:', metrics)

// [
//   {
//     cpuCount: 2,
//     cpuUsedPct: 50.05,
//     memTotalMiB: 484,
//     memUsedMiB: 37,
//     timestamp: '2025-01-23T23:44:12.222Z'
//   },
//   {
//     cpuCount: 2,
//     cpuUsedPct: 4.5,
//     memTotalMiB: 484,
//     memUsedMiB: 37,
//     timestamp: '2025-01-23T23:44:13.220Z'
//   }
// ]

```
```python
from e2b_code_interpreter import Sandbox

sbx = Sandbox()
print('Sandbox created', sbx.sandbox_id)

metrics = sbx.get_metrics() # $HighlightLine

# You can also get the metrics by sandbox ID:
# metrics = Sandbox.get_metrics(sbx.sandbox_id)

print('Sandbox metrics', metrics) 

# [
#   SandboxMetrics(timestamp=datetime.datetime(
#       2025, 1, 23, 23, 58, 42, 84050, tzinfo=tzutc()), 
#       cpu_count=2, 
#       cpu_used_pct=50.07, 
#       mem_total_mib=484
#       mem_used_mib=37, 
#   ), 
#   SandboxMetrics(timestamp=datetime.datetime(
#       2025, 1, 23, 23, 58, 44, 84845, tzinfo=tzutc()), 
#       cpu_count=2, 
#       cpu_used_pct=4.75, 
#       mem_total_mib=484
#       mem_used_mib=38,
#   ),
# ]
```
</CodeGroup>

### 2.2. Getting sandbox metrics using the CLI
<CodeGroup isTerminalCommand>
```bash
e2b sandbox metrics <sandbox_id>  # $HighlightLine

# Metrics for sandbox <sandbox_id>
# 
# [2025-01-23 00:58:58.829Z]  { cpuCount: 2, cpuUsedPct: 50.21, logger: '', memTotalMiB: 484, memUsedMiB: 38, timestamp: '2025-01-23T00:58:58.829638869Z' }
# [2025-01-23 00:59:03.814Z]  { cpuCount: 2, cpuUsedPct: 5.16, logger: '', memTotalMiB: 484, memUsedMiB: 37, timestamp: '2025-01-23T00:59:03.814028031Z' }
# [2025-01-23 00:59:08.815Z]  { cpuCount: 2, cpuUsedPct: 1.6, logger: '', memTotalMiB: 484, memUsedMiB: 37, timestamp: '2025-01-23T00:59:08.815933749Z' }
```
</CodeGroup>

## Limitations while in beta
- It may take a second or more to get the metrics after the sandbox is created. Until the logs are collected from the sandbox, you will get an empty array.

# Sandbox lifecycle

When you start the sandbox, it stays alive for 5 minutes by default but you can change it by passing the `timeout` parameter.
After the time passes, the sandbox will be automatically shutdown.
<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox with and keep it running for 60 seconds.
// 🚨 Note: The units are milliseconds.
const sandbox = await Sandbox.create({
  timeoutMs: 60_000, // $HighlightLine
})
```
```python
from e2b_code_interpreter import Sandbox

# Create sandbox with and keep it running for 60 seconds.
# 🚨 Note: The units are seconds.
sandbox = Sandbox(
  timeout=60, # $HighlightLine
)
```
</CodeGroup>


## Change sandbox timeout during runtime

You can change the sandbox timeout when it's running by calling the the `setTimeout` method in JavaScript or `set_timeout` method in Python.

When you call the set timeout method, the sandbox timeout will be reset to the new value that you specified.

This can be useful if you want to extend the sandbox lifetime when it's already running.
You can for example start with a sandbox with 1 minute timeout and then periodically call set timout every time user interacts with it in your app.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox with and keep it running for 60 seconds.
const sandbox = await Sandbox.create({ timeoutMs: 60_000 })

// Change the sandbox timeout to 30 seconds.
// 🚨 The new timeout will be 30 seconds from now.
await sandbox.setTimeout(30_000)
```
```python
from e2b_code_interpreter import Sandbox

# Create sandbox with and keep it running for 60 seconds.
sandbox = Sandbox(timeout=60)

# Change the sandbox timeout to 30 seconds.
# 🚨 The new timeout will be 30 seconds from now.
sandbox.set_timeout(30)
```
</CodeGroup>

## Shutdown sandbox

You can shutdown the sandbox any time even before the timeout is up by calling the `kill` method.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'

// Create sandbox with and keep it running for 60 seconds.
const sandbox = await Sandbox.create({ timeoutMs: 60_000 })

// Shutdown the sandbox immediately.
await sandbox.kill()
```
```python
from e2b_code_interpreter import Sandbox

# Create sandbox with and keep it running for 60 seconds.
sandbox = Sandbox(timeout=60)

# Shutdown the sandbox immediately.
sandbox.kill()
```
</CodeGroup>


# Sandbox persistence

<Note>
Sandbox persistence is currently in public beta:
1. You'll need to install the [beta version of the SDKs](#1-installing-the-beta-version-of-the-sdks).
1. Consider [some limitations](#limitations-while-in-beta).
1. The persistence is free for all users during the beta.
</Note>

The sandbox persistence allows you to pause your sandbox and resume it later from the same state it was in when you paused it.

This includes not only state of the sandbox's filesystem but also the sandbox's memory. This means all running processes, loaded variables, data, etc.

## 1. Installing the beta version of the SDKs
To use the sandbox persistence, you need to install the beta version of the SDKs.

<CodeGroup>
```bash {{ language: 'js' }}
npm i @e2b/code-interpreter@beta
#
# or use Core: https://github.com/e2b-dev/e2b
# npm i e2b@beta
#
# or use Desktop: https://github.com/e2b-dev/desktop
# npm i @e2b/desktop@beta
```

```bash {{ language: 'python' }}
pip install e2b-code-interpreter==1.0.4b
#
# or use Core: https://github.com/e2b-dev/e2b
# pip install e2b==1.1.0.b
#
# or use Desktop: https://github.com/e2b-dev/desktop
# pip install e2b-desktop==1.1.0.b
```
</CodeGroup>


## 2. Pausing sandbox
When you pause a sandbox, both the sandbox's filesystem and memory state will be saved. This includes all the files in the sandbox's filesystem and all the running processes, loaded variables, data, etc.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
// or use Core: https://github.com/e2b-dev/e2b
// import { Sandbox } from 'e2b'
//
// or use Desktop: https://github.com/e2b-dev/desktop
// import { Sandbox } from '@e2b/desktop'

const sbx = await Sandbox.create()
console.log('Sandbox created', sbx.sandboxId)

// Pause the sandbox
// You can save the sandbox ID in your database
// to resume the sandbox later
const sandboxId = await sbx.pause() // $HighlightLine
console.log('Sandbox paused', sandboxId) // $HighlightLine
```
```python
from e2b_code_interpreter import Sandbox
# or use Core: https://github.com/e2b-dev/e2b
# from e2b import Sandbox
#
# or use Desktop: https://github.com/e2b-dev/desktop
# from e2b_desktop import Sandbox

sbx = Sandbox()
print('Sandbox created', sbx.sandbox_id)

# Pause the sandbox
# You can save the sandbox ID in your database
# to resume the sandbox later
sandbox_id = sbx.pause() # $HighlightLine
print('Sandbox paused', sandbox_id) # $HighlightLine
```
</CodeGroup>


## 3. Resuming sandbox
When you resume a sandbox, it will be in the same state it was in when you paused it.
This means that all the files in the sandbox's filesystem will be restored and all the running processes, loaded variables, data, etc. will be restored.

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
// or use Core: https://github.com/e2b-dev/e2b
// import { Sandbox } from 'e2b'
//
// or use Desktop: https://github.com/e2b-dev/desktop
// import { Sandbox } from '@e2b/desktop'

const sbx = await Sandbox.create()
console.log('Sandbox created', sbx.sandboxId)

// Pause the sandbox
// You can save the sandbox ID in your database
// to resume the sandbox later
const sandboxId = await sbx.pause()
console.log('Sandbox paused', sandboxId)

// Resume the sandbox from the same state
const sameSbx = await Sandbox.resume(sandboxId) // $HighlightLine
console.log('Sandbox resumed', sameSbx.sandboxId) // $HighlightLine
```
```python
from e2b import Sandbox
# or use Core: https://github.com/e2b-dev/e2b
# from e2b import Sandbox
#
# or use Desktop: https://github.com/e2b-dev/desktop
# from e2b_desktop import Sandbox

sbx = Sandbox()
print('Sandbox created', sbx.sandbox_id)

# Pause the sandbox
# You can save the sandbox ID in your database
# to resume the sandbox later
sandbox_id = sbx.pause()
print('Sandbox paused', sandbox_id)

# Resume the sandbox from the same state
same_sbx = Sandbox.resume(sandbox_id) # $HighlightLine
print('Sandbox resumed', same_sbx.sandbox_id) # $HighlightLine
```
</CodeGroup>

## Sandbox's timeout
When you resume a sandbox, the sandbox's timeout is reset to the default timeout of an E2B sandbox - 5 minutes.


You can pass a custom timeout to the `Sandbox.resume()` method like this:

<CodeGroup>
```js
import { Sandbox } from '@e2b/code-interpreter'
// or use Core: https://github.com/e2b-dev/e2b
// import { Sandbox } from 'e2b'
//
// or use Desktop: https://github.com/e2b-dev/desktop
// import { Sandbox } from '@e2b/desktop'

const sbx = await Sandbox.resume(sandboxId, { timeoutMs: 60 * 1000 }) // 60 seconds
```
```python
from e2b_code_interpreter import Sandbox
# or use Core: https://github.com/e2b-dev/e2b
# from e2b import Sandbox
#
# or use Desktop: https://github.com/e2b-dev/desktop
# from e2b_desktop import Sandbox

sbx = Sandbox.resume(sandbox_id, timeout=60) # 60 seconds
```
</CodeGroup>

## Network
If you have a service (for example a server) running inside your sandbox and you pause the sandbox, the service won't be accessible from the outside and all the clients will be disconnected.
If you resume the sandbox, the service will be accessible again but you need to connect clients again.


## Limitations while in beta
- It takes about 4 seconds per 1 GB RAM to pause the sandbox
- It takes about 1 second to resume the sandbox
- Sandbox can be paused up to 30 days
  - After 30 days, the data will be deleted and you will not be able to resume the sandbox. Trying to resume sandbox that was deleted or does not exist will result in the `NotFoundError` error in JavaScript SDK and `NotFoundException` exception in Python SDK


# Customize sandbox CPU & RAM
You can customize the CPU and RAM of your sandbox template via E2B CLI.

You'll need to create a sandbox [template first](/docs/sandbox-template).

During the build step, you can specify the CPU and RAM of your sandbox template.

The following command will create a sandbox template with 2 CPUs and 2GB of RAM.
<CodeGroup isTerminalCommand>
```bash
e2b template build -c "/root/.jupyter/start-up.sh" --cpu-count 2 --memory-mb 2048
```
</CodeGroup>


# Sandbox templates

Sandbox templates allow you to customize the sandbox environment to your needs.

To create a sandbox template, you specify the `e2b.Dockerfile`. We then take this Dockerfile and create a new sandbox template from it and give you back a template ID.

You can then use this template ID to create a new sandbox with the SDK based on the template you created.

## How to create custom sandbox

**Steps**
1. [Install E2B CLI](#1-install-e2b-cli)
1. [Initialize sandbox template](#2-initialize-sandbox-template)
1. [Customize `e2b.Dockerfile`](#3-customize-e2bdockerfile)
1. [Build your sandbox template](#4-build-your-sandbox-template)
1. [Start your custom sandbox](#5-start-your-custom-sandbox)


### 1. Install E2B CLI
Install E2B CLI with npm:
<CodeGroup isTerminalCommand>
```bash
npm i @e2b/cli
```
</CodeGroup>

### 2. Initialize sandbox template
The following command will create a basic `e2b.Dockerfile` in the current directory.

<CodeGroup isTerminalCommand>
```bash
e2b template init
```
</CodeGroup>

### 3. Customize `e2b.Dockerfile`
Now you can customize your sandbox template by editing the `e2b.Dockerfile` file.
<CodeGroup title="e2b.Dockerfile">
```bash
# Make sure to use this base image
FROM e2bdev/code-interpreter:latest # $HighlightLine

# Install some Python packages
RUN pip install cowsay # $HighlightLine
```
</CodeGroup>

### 4. Build your sandbox template
Now you can build your sandbox template. We'll use Docker and the E2B CLI.
What is going to happen is that E2B CLI will call Docker to build the image and then push it to the E2B cloud.
Then we convert the Docker image to a micro VM that can be then launched as a sandbox with our SDK.

<CodeGroup isTerminalCommand>
```bash
e2b template build -c "/root/.jupyter/start-up.sh"
```
</CodeGroup>

This process will take a moment. In the end, you'll see your template ID that you'll need to use to create a sandbox with the SDK.

### 5. Start your custom sandbox
Now you can use the template ID to create a sandbox with the SDK.

<CodeGroup>
```javascript {{ language: 'js' }}
import { sandbox } from '@e2b/code-interpreter'

// Your template ID from the previous step
const templateID = 'id-of-your-template' // $HighlightLine
// Pass the template ID to the `Sandbox.create` method
const sandbox = await Sandbox.create(templateID) // $HighlightLine

// The template installed cowsay, so we can use it
const execution = await sandbox.runCode(`
import cowsay
cowsay.say('Hello from E2B!')
`)

console.log(execution.stdout)
```
```python {{ language: 'python' }}
from e2b_code_interpreter import Sandbox

# Your template ID from the previous step
template_id = 'id-of-your-template' # $HighlightLine
# Pass the template ID to the `Sandbox.create` method
sandbox = Sandbox(template_id) # $HighlightLine

# The template installed cowsay, so we can use it
execution = sandbox.run_code("""
import cowsay
cowsay.say('Hello from E2B!')
""")

print(execution.stdout)
```
</CodeGroup>

















# Start Command
The start command allows you to specify a command that will be **already running** when you spawn your custom sandbox.
This way, you can for example have running servers or seeded databases inside the sandbox that are already fully ready when you spawn the sandbox using the SDK and with zero waiting time for your users during the runtime.

The idea behind the start command feature is to lower the wait times for your users and have everything ready for your users when you spawn your sandbox.


## How to add start command

When you are building a sandbox template you can specify the start command by using the [`-c`](/docs/sdk-reference/cli/v1.0.9/template#e2b-template-build) option:

```bash
e2b build -c "<your-start-command>"
```

When you spawn the custom sandbox you built, the start command will be already running if there was no error when we tried to execute it.


## How it works
Every time you are building a [custom sandbox](/docs/sandbox-template), we create a container based on the [`e2b.Dockerfile`](/docs/sandbox-template#3-customize-e2b-dockerfile) file you create in the process.
We extract the container's filesystem and start a sandbox with this extracted filesystem.
We call this sandbox a _template sandbox_.

Then, these steps happen:

    1. We take the running template sandbox.
    2. (Only if you specified the start command, otherwise this step is skipped) **Execute the start command and wait 15 seconds**.
    3. Snapshot the sandbox and make it ready for you to spawn it with the SDK.


<Note title="Sandbox Snapshot">
Snapshots are saved running sandboxes. We serialize and save the whole sandbox's filesystem together with all the running processes in a way that can be loaded later.

This allows us to load the sandbox in a few hundred milliseconds any time later with all the processes already running and the filesystem exactly as it was.
</Note>


## Limits
- The network isn't accessible when running the start command during the build phase.
- We wait 15 seconds after we execute the start command before we snapshot the sandbox.


## Logs
You can retrieve the start command's logs using the SDK during runtime.

<Note>
These logs are the logs from the start command during the build phase.
</Note>

<CodeGroup title="Check start command logs" isRunnable={false}>
```js {{ language: 'js' }}
import { Sandbox } from 'e2b'

// Spawn your custom sandbox
const sandbox = await Sandbox.create({
  id: 'my-agent-sandbox',
  // If you specify onStderr and onStdout handlers when spawning the sandbox
  // you will see logs from the start command.
  onStderr: output => console.log("stderr", output.line), // $HighlightLine
  onStdout: output => console.log("stdout", output.line), // $HighlightLine
})

// Close sandbox once done
await sandbox.close()
```

```python {{ language: 'python' }}
from e2b import Sandbox

# Spawn your custom sandbox
sandbox = Sandbox(
  id="my-agent-sandbox",
  # If you specify on_stderr and on_stdout handlers when spawning the sandbox
  # you will see logs from the start command.
  on_stderr=lambda output: print("stderr", output.line),  # $HighlightLine
  on_stdout=lambda output: print("stdout", output.line),  # $HighlightLine
)

# Close sandbox once done
sandbox.close()
```
</CodeGroup>

Or you can use the CLI:

<CodeGroup isTerminalCommand>
```bash {{ language: 'bash' }}
e2b sandbox logs <sandbox-id>
```
</CodeGroup>

## Sandbox template config
The start command is specified inside the `e2b.toml` in the same directory where you ran `e2b build -c "<your-start-command>"`.
<CodeGroup isFileName title="e2b.toml" isRunnable={false}>
```toml
# This is a config for E2B sandbox template
template_id = "1wdqsf9le9gk21ztb4mo"
dockerfile = "e2b.Dockerfile"
template_name = "my-agent-sandbox"
start_cmd = "<your-start-command>"  # $HighlightLine
```
</CodeGroup>


## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




## e2b auth


authentication commands

### Usage

```bash
e2b auth [options] [command]
```
## e2b auth login


log in to CLI

### Usage

```bash
e2b auth login [options]
```


## e2b auth logout


log out of CLI

### Usage

```bash
e2b auth logout [options]
```


## e2b auth info


get information about the current user

### Usage

```bash
e2b auth info [options]
```


## e2b auth configure


configure user

### Usage

```bash
e2b auth configure [options]
```




## e2b sandbox


work with sandboxes

### Usage

```bash
e2b sandbox [options] [command]
```
## e2b sandbox connect


connect terminal to already running sandbox

### Usage

```bash
e2b sandbox connect [options] <sandboxID>
```


## e2b sandbox list


list all running sandboxes

### Usage

```bash
e2b sandbox list [options]
```


## e2b sandbox kill


kill sandbox

### Usage

```bash
e2b sandbox kill [options] [sandboxID]
```

### Options


 - `-a, --all: kill all running sandboxes `


## e2b sandbox spawn


spawn sandbox and connect terminal to it

### Usage

```bash
e2b sandbox spawn [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `


## e2b sandbox logs


show logs for sandbox

### Usage

```bash
e2b sandbox logs [options] <sandboxID>
```

### Options


 - `--level <level>: filter logs by level (DEBUG, INFO, WARN, ERROR). The logs with the higher levels will be also shown. [default: INFO]`
 - `-f, --follow: keep streaming logs until the sandbox is closed `
 - `--format <format>: specify format for printing logs (json, pretty) [default: pretty]`
 - `--loggers [loggers]: filter logs by loggers. Specify multiple loggers by separating them with a comma. `




## e2b template


manage sandbox templates

### Usage

```bash
e2b template [options] [command]
```
## e2b template build


build sandbox template defined by ./e2b.Dockerfile or ./Dockerfile in root directory. By default the root directory is the current working directory. This command also creates e2b.toml config.

### Usage

```bash
e2b template build [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `-d, --dockerfile <file>: specify path to Dockerfile. By default E2B tries to find e2b.Dockerfile or Dockerfile in root directory. `
 - `-n, --name <template-name>: specify sandbox template name. You can use the template name to start the sandbox with SDK. The template name must be lowercase and contain only letters, numbers, dashes and underscores. `
 - `-c, --cmd <start-command>: specify command that will be executed when the sandbox is started. `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `--cpu-count <cpu-count>: specify the number of CPUs that will be used to run the sandbox. The default value is 2. `
 - `--memory-mb <memory-mb>: specify the amount of memory in megabytes that will be used to run the sandbox. Must be an even number. The default value is 512. `
 - `--build-arg <args...>: specify additional build arguments for the build command. The format should be <varname>=<value>. `


## e2b template list


list sandbox templates

### Usage

```bash
e2b template list [options]
```

### Options


 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `


## e2b template init


create basic E2B Dockerfile (./e2b.Dockerfile) in root directory. You can then run e2b template build to build sandbox template from this Dockerfile

### Usage

```bash
e2b template init [options]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `


## e2b template delete


delete sandbox template and e2b.toml config

### Usage

```bash
e2b template delete [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual delete confirmation `


## e2b template publish


publish sandbox template

### Usage

```bash
e2b template publish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual publish confirmation `


## e2b template unpublish


unpublish sandbox template

### Usage

```bash
e2b template unpublish [options] [template]
```

### Options


 - `-p, --path <path>: change root directory where command is executed to <path> directory `
 - `--config <e2b-toml>: specify path to the E2B config toml. By default E2B tries to find ./e2b.toml in root directory. `
 - `-s, --select: select sandbox template from interactive list `
 - `-t, --team <team-id>: specify the team ID that the operation will be associated with. You can find team ID in the team settings in the E2B dashboard (https://e2b.dev/dashboard?tab=team). `
 - `-y, --yes: skip manual unpublish confirmation `




### ChartType

Chart types

#### Enumeration Members

| Enumeration Member | Value |
| ------ | ------ |
| `BAR` | `"bar"` |
| `BOX_AND_WHISKER` | `"box_and_whisker"` |
| `LINE` | `"line"` |
| `PIE` | `"pie"` |
| `SCATTER` | `"scatter"` |
| `SUPERCHART` | `"superchart"` |
| `UNKNOWN` | `"unknown"` |

***

### ScaleType

Ax scale types

#### Enumeration Members

| Enumeration Member | Value |
| ------ | ------ |
| `ASINH` | `"asinh"` |
| `CATEGORICAL` | `"categorical"` |
| `DATETIME` | `"datetime"` |
| `FUNCTION` | `"function"` |
| `FUNCTIONLOG` | `"functionlog"` |
| `LINEAR` | `"linear"` |
| `LOG` | `"log"` |
| `LOGIT` | `"logit"` |
| `SYMLOG` | `"symlog"` |

## Type Aliases

### BarChart

```ts
type BarChart: Chart2D & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `elements` | `BarData`[] |
| `type` | `ChartType.BAR` |

***

### BarData

```ts
type BarData: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `group` | `string` |
| `label` | `string` |
| `value` | `string` |

***

### BoxAndWhiskerChart

```ts
type BoxAndWhiskerChart: Chart2D & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `elements` | `BoxAndWhiskerData`[] |
| `type` | `ChartType.BOX_AND_WHISKER` |

***

### BoxAndWhiskerData

```ts
type BoxAndWhiskerData: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `first_quartile` | `number` |
| `label` | `string` |
| `max` | `number` |
| `median` | `number` |
| `min` | `number` |
| `outliers` | `number`[] |
| `third_quartile` | `number` |

***

### Chart

```ts
type Chart: object;
```

Represents a chart.

#### Type declaration

| Name | Type |
| ------ | ------ |
| `elements` | `any`[] |
| `title` | `string` |
| `type` | `ChartType` |

***

### ChartTypes

```ts
type ChartTypes: 
  | LineChart
  | ScatterChart
  | BarChart
  | PieChart
  | BoxAndWhiskerChart
  | SuperChart;
```

***

### LineChart

```ts
type LineChart: PointChart & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `type` | `ChartType.LINE` |

***

### PieChart

```ts
type PieChart: Chart & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `elements` | `PieData`[] |
| `type` | `ChartType.PIE` |

***

### PieData

```ts
type PieData: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `angle` | `number` |
| `label` | `string` |
| `radius` | `number` |

***

### PointData

```ts
type PointData: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `label` | `string` |
| `points` | [`number` \| `string`, `number` \| `string`][] |

***

### ScatterChart

```ts
type ScatterChart: PointChart & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `type` | `ChartType.SCATTER` |

***

### SuperChart

```ts
type SuperChart: Chart & object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `elements` | `Chart`[] |
| `type` | `ChartType.SUPERCHART` |

## Functions

### deserializeChart()

```ts
function deserializeChart(data: any): Chart
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `any` |

#### Returns

`Chart`


### DEFAULT\_TIMEOUT\_MS

```ts
const DEFAULT_TIMEOUT_MS: 60000 = 60_000;
```

***

### JUPYTER\_PORT

```ts
const JUPYTER_PORT: 49999 = 49999;
```


### BarChart

Re-exports BarChart

### BarData

Re-exports BarData

### BoxAndWhiskerChart

Re-exports BoxAndWhiskerChart

### BoxAndWhiskerData

Re-exports BoxAndWhiskerData

### Chart

Re-exports Chart

### ChartType

Re-exports ChartType

### ChartTypes

Re-exports ChartTypes

### Context

Re-exports Context

### CreateCodeContextOpts

Re-exports CreateCodeContextOpts

### default

Renames and re-exports Sandbox

### Execution

Re-exports Execution

### ExecutionError

Re-exports ExecutionError

### LineChart

Re-exports LineChart

### Logs

Re-exports Logs

### MIMEType

Re-exports MIMEType

### OutputMessage

Re-exports OutputMessage

### PieChart

Re-exports PieChart

### PieData

Re-exports PieData

### PointData

Re-exports PointData

### RawData

Re-exports RawData

### Result

Re-exports Result

### RunCodeOpts

Re-exports RunCodeOpts

### Sandbox

Re-exports Sandbox

### ScaleType

Re-exports ScaleType

### ScatterChart

Re-exports ScatterChart

### SuperChart

Re-exports SuperChart


### Execution

Represents the result of a cell execution.

#### Constructors

```ts
new Execution(
   results: Result[], 
   logs: Logs, 
   error?: ExecutionError, 
   executionCount?: number): Execution
```

###### Parameters

| Parameter | Type | Default value | Description |
| ------ | ------ | ------ | ------ |
| `results` | `Result`[] | `[]` | List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots). |
| `logs` | `Logs` | `...` | Logs printed to stdout and stderr during execution. |
| `error`? | `ExecutionError` | `undefined` | An Error object if an error occurred, null otherwise. |
| `executionCount`? | `number` | `undefined` | Execution count of the cell. |

###### Returns

`Execution`

#### Properties

| Property | Modifier | Type | Default value | Description |
| ------ | ------ | ------ | ------ | ------ |
| `error?` | `public` | `ExecutionError` | `undefined` | An Error object if an error occurred, null otherwise. |
| `executionCount?` | `public` | `number` | `undefined` | Execution count of the cell. |
| `logs` | `public` | `Logs` | `undefined` | Logs printed to stdout and stderr during execution. |
| `results` | `public` | `Result`[] | `[]` | List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots). |

#### Accessors

### text

###### Get Signature

```ts
get text(): undefined | string
```

Returns the text representation of the main result of the cell.

###### Returns

`undefined` \| `string`

#### Methods

### toJSON()

```ts
toJSON(): object
```

Returns the serializable representation of the execution result.

###### Returns

`object`

| Name | Type |
| ------ | ------ |
| `error` | `undefined` \| `ExecutionError` |
| `logs` | `Logs` |
| `results` | `Result`[] |

***

### ExecutionError

Represents an error that occurred during the execution of a cell.
The error contains the name of the error, the value of the error, and the traceback.

#### Constructors

```ts
new ExecutionError(
   name: string, 
   value: string, 
   traceback: string): ExecutionError
```

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `name` | `string` | Name of the error. |
| `value` | `string` | Value of the error. |
| `traceback` | `string` | The raw traceback of the error. |

###### Returns

`ExecutionError`

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `name` | `public` | `string` | Name of the error. |
| `traceback` | `public` | `string` | The raw traceback of the error. |
| `value` | `public` | `string` | Value of the error. |

***

### OutputMessage

Represents an output message from the sandbox code execution.

#### Constructors

```ts
new OutputMessage(
   line: string, 
   timestamp: number, 
   error: boolean): OutputMessage
```

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `line` | `string` | The output line. |
| `timestamp` | `number` | Unix epoch in nanoseconds. |
| `error` | `boolean` | Whether the output is an error. |

###### Returns

`OutputMessage`

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `error` | `readonly` | `boolean` | Whether the output is an error. |
| `line` | `readonly` | `string` | The output line. |
| `timestamp` | `readonly` | `number` | Unix epoch in nanoseconds. |

#### Methods

### toString()

```ts
toString(): string
```

###### Returns

`string`

***

### Result

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,
for the actual result the representation is always present for the result, the other representations are always optional.

#### Constructors

```ts
new Result(rawData: RawData, isMainResult: boolean): Result
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `rawData` | `RawData` |
| `isMainResult` | `boolean` |

###### Returns

`Result`

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `chart?` | `readonly` | `ChartTypes` | Contains the chart data. |
| `data?` | `readonly` | `Record`\<`string`, `unknown`\> | Contains the data from DataFrame. |
| `extra?` | `readonly` | `any` | Extra data that can be included. Not part of the standard types. |
| `html?` | `readonly` | `string` | HTML representation of the data. |
| `isMainResult` | `readonly` | `boolean` | - |
| `javascript?` | `readonly` | `string` | JavaScript representation of the data. |
| `jpeg?` | `readonly` | `string` | JPEG representation of the data. |
| `json?` | `readonly` | `string` | JSON representation of the data. |
| `latex?` | `readonly` | `string` | LaTeX representation of the data. |
| `markdown?` | `readonly` | `string` | Markdown representation of the data. |
| `pdf?` | `readonly` | `string` | PDF representation of the data. |
| `png?` | `readonly` | `string` | PNG representation of the data. |
| `raw` | `readonly` | `RawData` | - |
| `svg?` | `readonly` | `string` | SVG representation of the data. |
| `text?` | `readonly` | `string` | Text representation of the result. |

#### Methods

### formats()

```ts
formats(): string[]
```

Returns all the formats available for the result.

###### Returns

`string`[]

Array of strings representing the formats available for the result.

### toJSON()

```ts
toJSON(): object
```

Returns the serializable representation of the result.

###### Returns

`object`

| Name | Type |
| ------ | ------ |
| `extra`? | `any` |
| `html` | `undefined` \| `string` |
| `javascript` | `undefined` \| `string` |
| `jpeg` | `undefined` \| `string` |
| `json` | `undefined` \| `string` |
| `latex` | `undefined` \| `string` |
| `markdown` | `undefined` \| `string` |
| `pdf` | `undefined` \| `string` |
| `png` | `undefined` \| `string` |
| `svg` | `undefined` \| `string` |
| `text` | `undefined` \| `string` |

## Type Aliases

### Logs

```ts
type Logs: object;
```

Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.

#### Type declaration

| Name | Type | Description |
| ------ | ------ | ------ |
| `stderr` | `string`[] | List of strings printed to stderr by prints, subprocesses, etc. |
| `stdout` | `string`[] | List of strings printed to stdout by prints, subprocesses, etc. |

***

### MIMEType

```ts
type MIMEType: string;
```

Represents a MIME type.

***

### RawData

```ts
type RawData: object & E2BData;
```

Dictionary that maps MIME types to their corresponding representations of the data.

## Functions

### extractError()

```ts
function extractError(res: Response): Promise<undefined | SandboxError>
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `res` | `Response` |

#### Returns

`Promise`\<`undefined` \| `SandboxError`\>

***

### parseOutput()

```ts
function parseOutput(
   execution: Execution, 
   line: string, 
   onStdout?: (output: OutputMessage) => any, 
   onStderr?: (output: OutputMessage) => any, 
   onResult?: (data: Result) => any, 
onError?: (error: ExecutionError) => any): Promise<void>
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `execution` | `Execution` |
| `line` | `string` |
| `onStdout`? | (`output`: `OutputMessage`) => `any` |
| `onStderr`? | (`output`: `OutputMessage`) => `any` |
| `onResult`? | (`data`: `Result`) => `any` |
| `onError`? | (`error`: `ExecutionError`) => `any` |

#### Returns

`Promise`\<`void`\>


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from '@e2b/code-interpreter'

const sandbox = await Sandbox.create()
```

#### Methods

### createCodeContext()

```ts
createCodeContext(opts?: CreateCodeContextOpts): Promise<Context>
```

Creates a new context to run code in.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CreateCodeContextOpts` | options for creating the context. |

###### Returns

`Promise`\<`Context`\>

context object.

### runCode()

###### runCode(code, opts)

```ts
runCode(code: string, opts?: RunCodeOpts & object): Promise<Execution>
```

Run the code as Python.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `code` | `string` | code to execute. |
| `opts`? | `RunCodeOpts` & `object` | options for executing the code. |

###### Returns

`Promise`\<`Execution`\>

`Execution` result object.

###### runCode(code, opts)

```ts
runCode(code: string, opts?: RunCodeOpts & object): Promise<Execution>
```

Run the code for the specified language.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.
If no language is specified, Python is used.

You can reference previously defined variables, imports, and functions in the code.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `code` | `string` | code to execute. |
| `opts`? | `RunCodeOpts` & `object` | options for executing the code. |

###### Returns

`Promise`\<`Execution`\>

`Execution` result object.

###### runCode(code, opts)

```ts
runCode(code: string, opts?: RunCodeOpts & object): Promise<Execution>
```

Runs the code in the specified context, if not specified, the default context is used.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `code` | `string` | code to execute. |
| `opts`? | `RunCodeOpts` & `object` | options for executing the code |

###### Returns

`Promise`\<`Execution`\>

`Execution` result object

## Interfaces

### CreateCodeContextOpts

Options for creating a code context.

#### Properties

### cwd?

```ts
optional cwd: string;
```

Working directory for the context.

###### Default

```ts
/home/user
```

### language?

```ts
optional language: string;
```

Language for the context.

###### Default

```ts
python
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for the request in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### RunCodeOpts

Options for running code.

#### Properties

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for code execution.

###### Default

```ts
{}
```

### onError()?

```ts
optional onError: (error: ExecutionError) => any;
```

Callback for handling the `ExecutionError` object.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `error` | `ExecutionError` |

###### Returns

`any`

### onResult()?

```ts
optional onResult: (data: Result) => any;
```

Callback for handling the final execution result.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `Result` |

###### Returns

`any`

### onStderr()?

```ts
optional onStderr: (output: OutputMessage) => any;
```

Callback for handling stderr messages.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `output` | `OutputMessage` |

###### Returns

`any`

### onStdout()?

```ts
optional onStdout: (output: OutputMessage) => any;
```

Callback for handling stdout messages.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `output` | `OutputMessage` |

###### Returns

`any`

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for the request in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the code execution in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

## Type Aliases

### Context

```ts
type Context: object;
```

Represents a context for code execution.

#### Type declaration

| Name | Type | Description |
| ------ | ------ | ------ |
| `cwd` | `string` | The working directory of the context. |
| `id` | `string` | The ID of the context. |
| `language` | `string` | The language of the context. |







## AsyncSandbox

```python
class AsyncSandbox(BaseAsyncSandbox)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b_code_interpreter import AsyncSandbox
sandbox = await AsyncSandbox.create()
```


### run\_code

```python
@overload
async def run_code(code: str,
                   language: Union[Literal["python"], None] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code as Python.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
async def run_code(code: str,
                   language: Optional[str] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code for the specified language.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.
If no language is specified, Python is used.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
async def run_code(code: str,
                   context: Optional[Context] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code in the specified context, if not specified, the default context is used.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `context`: Concrete context to run the code in. If not specified, the default context for the language is used. It's mutually exclusive with the language.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### create\_code\_context

```python
async def create_code_context(
        cwd: Optional[str] = None,
        language: Optional[str] = None,
        request_timeout: Optional[float] = None) -> Context
```

Creates a new context to run code in.

**Arguments**:

- `cwd`: Set the current working directory for the context, defaults to `/home/user`
- `language`: Language of the context. If not specified, defaults to Python
- `request_timeout`: Timeout for the request in **milliseconds**

**Returns**:

Context object




## OutputMessage

```python
@dataclass
class OutputMessage()
```

Represents an output message from the sandbox code execution.


### line

The output line.


### timestamp

Unix epoch in nanoseconds


### error

Whether the output is an error.


## ExecutionError

```python
@dataclass
class ExecutionError()
```

Represents an error that occurred during the execution of a cell.
The error contains the name of the error, the value of the error, and the traceback.


### name

Name of the error.


### value

Value of the error.


### traceback

The raw traceback of the error.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Error object.


## MIMEType

```python
class MIMEType(str)
```

Represents a MIME type.


## Result

```python
@dataclass
class Result()
```

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,
for the actual result the representation is always present for the result, the other representations are always optional.


### is\_main\_result

Whether this data is the result of the cell. Data can be produced by display calls of which can be multiple in a cell.


### extra

Extra data that can be included. Not part of the standard types.


### formats

```python
def formats() -> Iterable[str]
```

Returns all available formats of the result.

**Returns**:

All available formats of the result in MIME types.


### \_\_str\_\_

```python
def __str__() -> Optional[str]
```

Returns the text representation of the data.

**Returns**:

The text representation of the data.


### \_repr\_html\_

```python
def _repr_html_() -> Optional[str]
```

Returns the HTML representation of the data.

**Returns**:

The HTML representation of the data.


### \_repr\_markdown\_

```python
def _repr_markdown_() -> Optional[str]
```

Returns the Markdown representation of the data.

**Returns**:

The Markdown representation of the data.


### \_repr\_svg\_

```python
def _repr_svg_() -> Optional[str]
```

Returns the SVG representation of the data.

**Returns**:

The SVG representation of the data.


### \_repr\_png\_

```python
def _repr_png_() -> Optional[str]
```

Returns the base64 representation of the PNG data.

**Returns**:

The base64 representation of the PNG data.


### \_repr\_jpeg\_

```python
def _repr_jpeg_() -> Optional[str]
```

Returns the base64 representation of the JPEG data.

**Returns**:

The base64 representation of the JPEG data.


### \_repr\_pdf\_

```python
def _repr_pdf_() -> Optional[str]
```

Returns the PDF representation of the data.

**Returns**:

The PDF representation of the data.


### \_repr\_latex\_

```python
def _repr_latex_() -> Optional[str]
```

Returns the LaTeX representation of the data.

**Returns**:

The LaTeX representation of the data.


### \_repr\_json\_

```python
def _repr_json_() -> Optional[dict]
```

Returns the JSON representation of the data.

**Returns**:

The JSON representation of the data.


### \_repr\_javascript\_

```python
def _repr_javascript_() -> Optional[str]
```

Returns the JavaScript representation of the data.

**Returns**:

The JavaScript representation of the data.


## Logs

```python
@dataclass(repr=False)
class Logs()
```

Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.


### stdout

List of strings printed to stdout by prints, subprocesses, etc.


### stderr

List of strings printed to stderr by prints, subprocesses, etc.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Logs object.


### serialize\_results

```python
def serialize_results(results: List[Result]) -> List[Dict[str, str]]
```

Serializes the results to JSON.


## Execution

```python
@dataclass(repr=False)
class Execution()
```

Represents the result of a cell execution.


### results

List of the result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).


### logs

Logs printed to stdout and stderr during execution.


### error

Error object if an error occurred, None otherwise.


### execution\_count

Execution count of the cell.


### text

```python
@property
def text() -> Optional[str]
```

Returns the text representation of the result.

**Returns**:

The text representation of the result.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Execution object.


## Context

```python
@dataclass
class Context()
```

Represents a context for code execution.


### id

The ID of the context.


### language

The language of the context.


### cwd

The working directory of the context.




## ChartType

```python
class ChartType(str, enum.Enum)
```

Chart types


## ScaleType

```python
class ScaleType(str, enum.Enum)
```

Ax scale types


## Chart

```python
class Chart()
```

Extracted data from a chart. It's useful for building an interactive charts or custom visualizations.




## Sandbox

```python
class Sandbox(BaseSandbox)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()
```


### run\_code

```python
@overload
def run_code(code: str,
             language: Union[Literal["python"], None] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code as Python.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
def run_code(code: str,
             language: Optional[str] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code for the specified language.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.
If no language is specified, Python is used.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
def run_code(code: str,
             context: Optional[Context] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code in the specified context, if not specified, the default context is used.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `context`: Concrete context to run the code in. If not specified, the default context for the language is used. It's mutually exclusive with the language.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### create\_code\_context

```python
def create_code_context(cwd: Optional[str] = None,
                        language: Optional[str] = None,
                        request_timeout: Optional[float] = None) -> Context
```

Creates a new context to run code in.

**Arguments**:

- `cwd`: Set the current working directory for the context, defaults to `/home/user`
- `language`: Language of the context. If not specified, defaults to Python
- `request_timeout`: Timeout for the request in **milliseconds**

**Returns**:

Context object












## ChartType

```python
class ChartType(str, enum.Enum)
```

Chart types


## ScaleType

```python
class ScaleType(str, enum.Enum)
```

Ax scale types


## Chart

```python
class Chart()
```

Extracted data from a chart. It's useful for building an interactive charts or custom visualizations.




## AsyncSandbox

```python
class AsyncSandbox(BaseAsyncSandbox)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b_code_interpreter import AsyncSandbox
sandbox = await AsyncSandbox.create()
```


### run\_code

```python
@overload
async def run_code(code: str,
                   language: Union[Literal["python"], None] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code as Python.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
async def run_code(code: str,
                   language: Optional[str] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code for the specified language.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.
If no language is specified, Python is used.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
async def run_code(code: str,
                   context: Optional[Context] = None,
                   on_stdout: Optional[OutputHandler[OutputMessage]] = None,
                   on_stderr: Optional[OutputHandler[OutputMessage]] = None,
                   on_result: Optional[OutputHandler[Result]] = None,
                   on_error: Optional[OutputHandler[ExecutionError]] = None,
                   envs: Optional[Dict[str, str]] = None,
                   timeout: Optional[float] = None,
                   request_timeout: Optional[float] = None) -> Execution
```

Runs the code in the specified context, if not specified, the default context is used.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `context`: Concrete context to run the code in. If not specified, the default context for the language is used. It's mutually exclusive with the language.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### create\_code\_context

```python
async def create_code_context(
        cwd: Optional[str] = None,
        language: Optional[str] = None,
        request_timeout: Optional[float] = None) -> Context
```

Creates a new context to run code in.

**Arguments**:

- `cwd`: Set the current working directory for the context, defaults to `/home/user`
- `language`: Language of the context. If not specified, defaults to Python
- `request_timeout`: Timeout for the request in **milliseconds**

**Returns**:

Context object








## Sandbox

```python
class Sandbox(BaseSandbox)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b_code_interpreter import Sandbox

sandbox = Sandbox()
```


### run\_code

```python
@overload
def run_code(code: str,
             language: Union[Literal["python"], None] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code as Python.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
def run_code(code: str,
             language: Optional[str] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code for the specified language.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.
If no language is specified, Python is used.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `language`: Language to use for code execution. If not defined, the default Python context is used.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### run\_code

```python
@overload
def run_code(code: str,
             context: Optional[Context] = None,
             on_stdout: Optional[OutputHandler[OutputMessage]] = None,
             on_stderr: Optional[OutputHandler[OutputMessage]] = None,
             on_result: Optional[OutputHandler[Result]] = None,
             on_error: Optional[OutputHandler[ExecutionError]] = None,
             envs: Optional[Dict[str, str]] = None,
             timeout: Optional[float] = None,
             request_timeout: Optional[float] = None) -> Execution
```

Runs the code in the specified context, if not specified, the default context is used.

Specify the `language` or `context` option to run the code as a different language or in a different `Context`.

You can reference previously defined variables, imports, and functions in the code.

**Arguments**:

- `code`: Code to execute
- `context`: Concrete context to run the code in. If not specified, the default context for the language is used. It's mutually exclusive with the language.
- `on_stdout`: Callback for stdout messages
- `on_stderr`: Callback for stderr messages
- `on_result`: Callback for the `Result` object
- `on_error`: Callback for the `ExecutionError` object
- `envs`: Custom environment variables
- `timeout`: Timeout for the code execution in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`Execution` result object


### create\_code\_context

```python
def create_code_context(cwd: Optional[str] = None,
                        language: Optional[str] = None,
                        request_timeout: Optional[float] = None) -> Context
```

Creates a new context to run code in.

**Arguments**:

- `cwd`: Set the current working directory for the context, defaults to `/home/user`
- `language`: Language of the context. If not specified, defaults to Python
- `request_timeout`: Timeout for the request in **milliseconds**

**Returns**:

Context object




## OutputMessage

```python
@dataclass
class OutputMessage()
```

Represents an output message from the sandbox code execution.


### line

The output line.


### timestamp

Unix epoch in nanoseconds


### error

Whether the output is an error.


## ExecutionError

```python
@dataclass
class ExecutionError()
```

Represents an error that occurred during the execution of a cell.
The error contains the name of the error, the value of the error, and the traceback.


### name

Name of the error.


### value

Value of the error.


### traceback

The raw traceback of the error.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Error object.


## MIMEType

```python
class MIMEType(str)
```

Represents a MIME type.


## Result

```python
@dataclass
class Result()
```

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,
for the actual result the representation is always present for the result, the other representations are always optional.


### is\_main\_result

Whether this data is the result of the cell. Data can be produced by display calls of which can be multiple in a cell.


### extra

Extra data that can be included. Not part of the standard types.


### formats

```python
def formats() -> Iterable[str]
```

Returns all available formats of the result.

**Returns**:

All available formats of the result in MIME types.


### \_\_str\_\_

```python
def __str__() -> Optional[str]
```

Returns the text representation of the data.

**Returns**:

The text representation of the data.


### \_repr\_html\_

```python
def _repr_html_() -> Optional[str]
```

Returns the HTML representation of the data.

**Returns**:

The HTML representation of the data.


### \_repr\_markdown\_

```python
def _repr_markdown_() -> Optional[str]
```

Returns the Markdown representation of the data.

**Returns**:

The Markdown representation of the data.


### \_repr\_svg\_

```python
def _repr_svg_() -> Optional[str]
```

Returns the SVG representation of the data.

**Returns**:

The SVG representation of the data.


### \_repr\_png\_

```python
def _repr_png_() -> Optional[str]
```

Returns the base64 representation of the PNG data.

**Returns**:

The base64 representation of the PNG data.


### \_repr\_jpeg\_

```python
def _repr_jpeg_() -> Optional[str]
```

Returns the base64 representation of the JPEG data.

**Returns**:

The base64 representation of the JPEG data.


### \_repr\_pdf\_

```python
def _repr_pdf_() -> Optional[str]
```

Returns the PDF representation of the data.

**Returns**:

The PDF representation of the data.


### \_repr\_latex\_

```python
def _repr_latex_() -> Optional[str]
```

Returns the LaTeX representation of the data.

**Returns**:

The LaTeX representation of the data.


### \_repr\_json\_

```python
def _repr_json_() -> Optional[dict]
```

Returns the JSON representation of the data.

**Returns**:

The JSON representation of the data.


### \_repr\_javascript\_

```python
def _repr_javascript_() -> Optional[str]
```

Returns the JavaScript representation of the data.

**Returns**:

The JavaScript representation of the data.


## Logs

```python
@dataclass(repr=False)
class Logs()
```

Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.


### stdout

List of strings printed to stdout by prints, subprocesses, etc.


### stderr

List of strings printed to stderr by prints, subprocesses, etc.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Logs object.


### serialize\_results

```python
def serialize_results(results: List[Result]) -> List[Dict[str, str]]
```

Serializes the results to JSON.


## Execution

```python
@dataclass(repr=False)
class Execution()
```

Represents the result of a cell execution.


### results

List of the result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).


### logs

Logs printed to stdout and stderr during execution.


### error

Error object if an error occurred, None otherwise.


### execution\_count

Execution count of the cell.


### text

```python
@property
def text() -> Optional[str]
```

Returns the text representation of the result.

**Returns**:

The text representation of the result.


### to\_json

```python
def to_json() -> str
```

Returns the JSON representation of the Execution object.


## Context

```python
@dataclass
class Context()
```

Represents a context for code execution.


### id

The ID of the context.


### language

The language of the context.


### cwd

The working directory of the context.



### Sandbox

#### Methods

### doubleClick()

```ts
doubleClick(): Promise<CommandResult>
```

Double left click on the current mouse position.

###### Returns

`Promise`\<`CommandResult`\>

### getCursorPosition()

```ts
getCursorPosition(): Promise<object>
```

Get the current mouse position.

###### Returns

`Promise`\<`object`\>

An object with `x` and `y` coordinates.

| Name | Type |
| ------ | ------ |
| `x` | `number` |
| `y` | `number` |

### getScreenSize()

```ts
getScreenSize(): Promise<object>
```

Get the current screen size.

###### Returns

`Promise`\<`object`\>

An object with `width` and `height` properties.

| Name | Type |
| ------ | ------ |
| `height` | `number` |
| `width` | `number` |

### getVideoStreamUrl()

```ts
getVideoStreamUrl(): Promise<string>
```

###### Returns

`Promise`\<`string`\>

### hotkey()

```ts
hotkey(...keys: string[]): Promise<CommandResult>
```

Press a hotkey.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| ...`keys` | `string`[] | The keys to press (e.g. `hotkey("ctrl", "c")` will press Ctrl+C). |

###### Returns

`Promise`\<`CommandResult`\>

### leftClick()

```ts
leftClick(): Promise<CommandResult>
```

Left click on the current mouse position.

###### Returns

`Promise`\<`CommandResult`\>

### middleClick()

```ts
middleClick(): Promise<CommandResult>
```

Middle click on the current mouse position.

###### Returns

`Promise`\<`CommandResult`\>

### moveMouse()

```ts
moveMouse(x: number, y: number): Promise<CommandResult>
```

Move the mouse to the given coordinates.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `x` | `number` | The x coordinate. |
| `y` | `number` | The y coordinate. |

###### Returns

`Promise`\<`CommandResult`\>

### open()

```ts
open(fileOrUrl: string): Promise<CommandHandle>
```

Open a file or a URL in the default application.
Note that you'll need to wait for the application to be opened.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `fileOrUrl` | `string` | The file or URL to open. |

###### Returns

`Promise`\<`CommandHandle`\>

### press()

```ts
press(key: string): Promise<CommandResult>
```

Press a key.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `key` | `string` | The key to press (e.g. "enter", "space", "backspace", etc.). |

###### Returns

`Promise`\<`CommandResult`\>

### rightClick()

```ts
rightClick(): Promise<CommandResult>
```

Right click on the current mouse position.

###### Returns

`Promise`\<`CommandResult`\>

### runPyautoguiCode()

```ts
runPyautoguiCode(code: string, opts: object): Promise<CommandResult>
```

Run the given Python code that uses pyautogui.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `code` | `string` |
| `opts` | `object` |
| `opts.onStderr`? | (`data`: `string`) => `void` |
| `opts.onStdout`? | (`data`: `string`) => `void` |

###### Returns

`Promise`\<`CommandResult`\>

### scroll()

```ts
scroll(amount: number): Promise<CommandResult>
```

Scroll the mouse wheel by the given amount.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `amount` | `number` | The amount to scroll. |

###### Returns

`Promise`\<`CommandResult`\>

### takeScreenshot()

###### takeScreenshot()

```ts
takeScreenshot(): Promise<Uint8Array>
```

Take a screenshot and save it to the given name.

###### Returns

`Promise`\<`Uint8Array`\>

A Uint8Array bytes representation of the screenshot.

###### takeScreenshot(format)

```ts
takeScreenshot(format: "bytes"): Promise<Uint8Array>
```

Take a screenshot and save it to the given name.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `format` | `"bytes"` | The format of the screenshot. |

###### Returns

`Promise`\<`Uint8Array`\>

A Uint8Array bytes representation of the screenshot.

###### takeScreenshot(format)

```ts
takeScreenshot(format: "blob"): Promise<Blob>
```

Take a screenshot and save it to the given name.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `format` | `"blob"` |

###### Returns

`Promise`\<`Blob`\>

A Blob representation of the screenshot.

###### takeScreenshot(format)

```ts
takeScreenshot(format: "stream"): Promise<ReadableStream<Uint8Array>>
```

Take a screenshot and save it to the given name.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `format` | `"stream"` |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

A ReadableStream of bytes representation of the screenshot.

### write()

```ts
write(text: string): Promise<CommandResult>
```

Write the given text at the current cursor position.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `text` | `string` | The text to write. |

###### Returns

`Promise`\<`CommandResult`\>

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `desktop` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

## Interfaces

### SandboxOpts

#### Properties

### onVideoStreamStart()?

```ts
optional onVideoStreamStart: (url: string) => void;
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `url` | `string` |

###### Returns

`void`

### videoStream?

```ts
optional videoStream: boolean;
```







## Sandbox

```python
class Sandbox(SandboxBase)
```


### get\_video\_stream\_url

```python
def get_video_stream_url()
```

Get the video stream URL.


### take\_screenshot

```python
@overload
def take_screenshot(format: Literal["stream"]) -> Iterator[bytes]
```

Take a screenshot and return it as a stream of bytes.


### take\_screenshot

```python
@overload
def take_screenshot(format: Literal["bytes"]) -> bytearray
```

Take a screenshot and return it as a bytearray.


### take\_screenshot

```python
def take_screenshot(format: Literal["bytes", "stream"] = "bytes")
```

Take a screenshot and return it in the specified format.

**Arguments**:

- `format`: The format of the screenshot. Can be 'bytes', 'blob', or 'stream'.

**Returns**:

The screenshot in the specified format.


### left\_click

```python
def left_click()
```

Left click on the current mouse position.


### double\_click

```python
def double_click()
```

Double left click on the current mouse position.


### right\_click

```python
def right_click()
```

Right click on the current mouse position.


### middle\_click

```python
def middle_click()
```

Middle click on the current mouse position.


### scroll

```python
def scroll(amount: int)
```

Scroll the mouse wheel by the given amount.

**Arguments**:

- `amount`: The amount to scroll.


### move\_mouse

```python
def move_mouse(x: int, y: int)
```

Move the mouse to the given coordinates.

**Arguments**:

- `x`: The x coordinate.
- `y`: The y coordinate.


### get\_cursor\_position

```python
def get_cursor_position()
```

Get the current cursor position.

**Returns**:

A tuple with the x and y coordinates.


### get\_screen\_size

```python
def get_screen_size()
```

Get the current screen size.

**Returns**:

A tuple with the width and height.


### write

```python
def write(text: str)
```

Write the given text at the current cursor position.

**Arguments**:

- `text`: The text to write.


### press

```python
def press(key: str)
```

Press a key.

**Arguments**:

- `key`: The key to press (e.g. "enter", "space", "backspace", etc.).


### hotkey

```python
def hotkey(*keys)
```

Press a hotkey.

**Arguments**:

- `keys`: The keys to press (e.g. `hotkey("ctrl", "c")` will press Ctrl+C).


### open

```python
def open(file_or_url: str)
```

Open a file or a URL in the default application.

**Arguments**:

- `file_or_url`: The file or URL to open.



# errors

## Classes

### AuthenticationError

Thrown when authentication fails.

#### Constructors

##### new AuthenticationError()

> **new AuthenticationError**(`message`): `AuthenticationError`

###### Parameters

• **message**: `any`

###### Returns

`AuthenticationError`

###### Defined in

errors.ts:72

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

##### new InvalidArgumentError()

> **new InvalidArgumentError**(`message`): `InvalidArgumentError`

###### Parameters

• **message**: `string`

###### Returns

`InvalidArgumentError`

###### Defined in

errors.ts:42

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

##### new NotEnoughSpaceError()

> **new NotEnoughSpaceError**(`message`): `NotEnoughSpaceError`

###### Parameters

• **message**: `string`

###### Returns

`NotEnoughSpaceError`

###### Defined in

errors.ts:52

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

##### new NotFoundError()

> **new NotFoundError**(`message`): `NotFoundError`

###### Parameters

• **message**: `string`

###### Returns

`NotFoundError`

###### Defined in

errors.ts:62

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`

#### Constructors

##### new SandboxError()

> **new SandboxError**(`message`): `SandboxError`

###### Parameters

• **message**: `any`

###### Returns

`SandboxError`

###### Defined in

errors.ts:14

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

##### new TemplateError()

> **new TemplateError**(`message`): `TemplateError`

###### Parameters

• **message**: `string`

###### Returns

`TemplateError`

###### Defined in

errors.ts:82

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

##### new TimeoutError()

> **new TimeoutError**(`message`): `TimeoutError`

###### Parameters

• **message**: `string`

###### Returns

`TimeoutError`

###### Defined in

errors.ts:32

## Functions

### formatSandboxTimeoutError()

> **formatSandboxTimeoutError**(`message`): `TimeoutError`

#### Parameters

• **message**: `string`

#### Returns

`TimeoutError`

#### Defined in

errors.ts:2


# sandbox/filesystem

## Enumerations

### FileType

Sandbox filesystem object type.

#### Enumeration Members

##### DIR

> **DIR**: `"dir"`

Filesystem object is a directory.

###### Defined in

sandbox/filesystem/index.ts:55

##### FILE

> **FILE**: `"file"`

Filesystem object is a file.

###### Defined in

sandbox/filesystem/index.ts:51

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

##### new Filesystem()

> **new Filesystem**(`transport`, `envdApi`, `connectionConfig`): `Filesystem`

###### Parameters

• **transport**: `Transport`

• **envdApi**: `EnvdApiClient`

• **connectionConfig**: `ConnectionConfig`

###### Returns

`Filesystem`

###### Defined in

sandbox/filesystem/index.ts:104

#### Methods

##### exists()

> **exists**(`path`, `opts`?): `Promise`\<`boolean`\>

Check if a file or a directory exists.

###### Parameters

• **path**: `string`

path to a file or a directory

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

###### Defined in

sandbox/filesystem/index.ts:399

##### list()

> **list**(`path`, `opts`?): `Promise`\<`EntryInfo`[]\>

List entries in a directory.

###### Parameters

• **path**: `string`

path to the directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

###### Defined in

sandbox/filesystem/index.ts:270

##### makeDir()

> **makeDir**(`path`, `opts`?): `Promise`\<`boolean`\>

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

• **path**: `string`

path to a new directory. For example '/dirA/dirB' when creating 'dirB'.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

###### Defined in

sandbox/filesystem/index.ts:308

##### read()

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`string`\>

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`string`\>

file content as string

###### Defined in

sandbox/filesystem/index.ts:123

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Uint8Array`\>

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### Defined in

sandbox/filesystem/index.ts:138

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Blob`\>

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### Defined in

sandbox/filesystem/index.ts:153

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`ReadableStream`\<`Uint8Array`\>\>

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

###### Defined in

sandbox/filesystem/index.ts:168

##### remove()

> **remove**(`path`, `opts`?): `Promise`\<`void`\>

Remove a file or directory.

###### Parameters

• **path**: `string`

path to a file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:377

##### rename()

> **rename**(`oldPath`, `newPath`, `opts`?): `Promise`\<`EntryInfo`\>

Rename a file or directory.

###### Parameters

• **oldPath**: `string`

path to the file or directory to rename.

• **newPath**: `string`

new path for the file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

###### Defined in

sandbox/filesystem/index.ts:339

##### watchDir()

> **watchDir**(`path`, `onEvent`, `opts`?): `Promise`\<`WatchHandle`\>

Start watching a directory for filesystem events.

###### Parameters

• **path**: `string`

path to directory to watch.

• **onEvent**

callback to call when an event in the directory occurs.

• **opts?**: `WatchOpts`

connection options.

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

###### Defined in

sandbox/filesystem/index.ts:430

##### write()

> **write**(`path`, `data`, `opts`?): `Promise`\<`EntryInfo`\>

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

• **path**: `string`

path to file.

• **data**: `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\>

data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### Defined in

sandbox/filesystem/index.ts:224

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

##### name

> **name**: `string`

Name of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:33

##### path

> **path**: `string`

Path to the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:41

##### type?

> `optional` **type**: `FileType`

Type of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:37

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76

***

### WatchOpts

Options for watching a directory.

#### Properties

##### onExit()?

> `optional` **onExit**: (`err`?) => `void` \| `Promise`\<`void`\>

Callback to call when the watch operation stops.

###### Parameters

• **err?**: `Error`

###### Returns

`void` \| `Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:93

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

###### Defined in

sandbox/filesystem/index.ts:89

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76


# sandbox

## Classes

### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

##### commands

> `readonly` **commands**: `Commands`

Module for running commands in the sandbox

###### Defined in

sandbox/index.ts:74

##### files

> `readonly` **files**: `Filesystem`

Module for interacting with the sandbox filesystem

###### Defined in

sandbox/index.ts:70

##### pty

> `readonly` **pty**: `Pty`

Module for interacting with the sandbox pseudo-terminals

###### Defined in

sandbox/index.ts:78

##### sandboxId

> `readonly` **sandboxId**: `string`

Unique identifier of the sandbox.

###### Defined in

sandbox/index.ts:83

#### Methods

##### downloadUrl()

> **downloadUrl**(`path`): `string`

Get the URL to download a file from the sandbox.

###### Parameters

• **path**: `string`

path to the file to download.

###### Returns

`string`

URL for downloading file.

###### Defined in

sandbox/index.ts:339

##### getHost()

> **getHost**(`port`): `string`

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

• **port**: `number`

number of the port in the sandbox.

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
``

###### Defined in

sandbox/index.ts:237

##### isRunning()

> **isRunning**(`opts`?): `Promise`\<`boolean`\>

Check if the sandbox is running.

###### Parameters

• **opts?**: `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\>

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

###### Defined in

sandbox/index.ts:259

##### kill()

> **kill**(`opts`?): `Promise`\<`void`\>

Kill the sandbox.

###### Parameters

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:310

##### setTimeout()

> **setTimeout**(`timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:290

##### uploadUrl()

> **uploadUrl**(`path`?): `string`

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

• **path?**: `string`

the directory where to upload the file, defaults to user's home directory.

###### Returns

`string`

URL for uploading file.

###### Defined in

sandbox/index.ts:328

##### connect()

> `static` **connect**\<`S`\>(`this`, `sandboxId`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\>

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

###### Defined in

sandbox/index.ts:209

##### create()

###### create(this, opts)

> `static` **create**\<`S`\>(`this`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:143

###### create(this, template, opts)

> `static` **create**\<`S`\>(`this`, `template`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the specified sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **template**: `string`

sandbox template name or ID.

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:162

##### kill()

> `static` **kill**(`sandboxId`, `opts`?): `Promise`\<`boolean`\>

Kill the sandbox specified by sandbox ID.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

###### Defined in

sandbox/sandboxApi.ts:55

##### list()

> `static` **list**(`opts`?): `Promise`\<`SandboxInfo`[]\>

List all running sandboxes.

###### Parameters

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

###### Defined in

sandbox/sandboxApi.ts:90

##### setTimeout()

> `static` **setTimeout**(`sandboxId`, `timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/sandboxApi.ts:129

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

##### accessToken?

> `optional` **accessToken**: `string`

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

###### Defined in

connectionConfig.ts:24

##### apiKey?

> `optional` **apiKey**: `string`

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

###### Defined in

connectionConfig.ts:18

##### debug?

> `optional` **debug**: `boolean`

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

###### Defined in

connectionConfig.ts:36

##### domain?

> `optional` **domain**: `string`

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

###### Defined in

connectionConfig.ts:30

##### envs?

> `optional` **envs**: `Record`\<`string`, `string`\>

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:32

##### logger?

> `optional` **logger**: `Logger`

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

###### Defined in

connectionConfig.ts:46

##### metadata?

> `optional` **metadata**: `Record`\<`string`, `string`\>

Custom metadata for the sandbox.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:23

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```

###### Defined in

sandbox/index.ts:39


# errors

## Classes

### AuthenticationError

Thrown when authentication fails.

#### Constructors

##### new AuthenticationError()

> **new AuthenticationError**(`message`): `AuthenticationError`

###### Parameters

• **message**: `any`

###### Returns

`AuthenticationError`

###### Defined in

errors.ts:72

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

##### new InvalidArgumentError()

> **new InvalidArgumentError**(`message`): `InvalidArgumentError`

###### Parameters

• **message**: `string`

###### Returns

`InvalidArgumentError`

###### Defined in

errors.ts:42

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

##### new NotEnoughSpaceError()

> **new NotEnoughSpaceError**(`message`): `NotEnoughSpaceError`

###### Parameters

• **message**: `string`

###### Returns

`NotEnoughSpaceError`

###### Defined in

errors.ts:52

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

##### new NotFoundError()

> **new NotFoundError**(`message`): `NotFoundError`

###### Parameters

• **message**: `string`

###### Returns

`NotFoundError`

###### Defined in

errors.ts:62

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`

#### Constructors

##### new SandboxError()

> **new SandboxError**(`message`): `SandboxError`

###### Parameters

• **message**: `any`

###### Returns

`SandboxError`

###### Defined in

errors.ts:14

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

##### new TemplateError()

> **new TemplateError**(`message`): `TemplateError`

###### Parameters

• **message**: `string`

###### Returns

`TemplateError`

###### Defined in

errors.ts:82

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

##### new TimeoutError()

> **new TimeoutError**(`message`): `TimeoutError`

###### Parameters

• **message**: `string`

###### Returns

`TimeoutError`

###### Defined in

errors.ts:32

## Functions

### formatSandboxTimeoutError()

> **formatSandboxTimeoutError**(`message`): `TimeoutError`

#### Parameters

• **message**: `string`

#### Returns

`TimeoutError`

#### Defined in

errors.ts:2


# sandbox/filesystem

## Enumerations

### FileType

Sandbox filesystem object type.

#### Enumeration Members

##### DIR

> **DIR**: `"dir"`

Filesystem object is a directory.

###### Defined in

sandbox/filesystem/index.ts:55

##### FILE

> **FILE**: `"file"`

Filesystem object is a file.

###### Defined in

sandbox/filesystem/index.ts:51

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

##### new Filesystem()

> **new Filesystem**(`transport`, `envdApi`, `connectionConfig`): `Filesystem`

###### Parameters

• **transport**: `Transport`

• **envdApi**: `EnvdApiClient`

• **connectionConfig**: `ConnectionConfig`

###### Returns

`Filesystem`

###### Defined in

sandbox/filesystem/index.ts:104

#### Methods

##### exists()

> **exists**(`path`, `opts`?): `Promise`\<`boolean`\>

Check if a file or a directory exists.

###### Parameters

• **path**: `string`

path to a file or a directory

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

###### Defined in

sandbox/filesystem/index.ts:399

##### list()

> **list**(`path`, `opts`?): `Promise`\<`EntryInfo`[]\>

List entries in a directory.

###### Parameters

• **path**: `string`

path to the directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

###### Defined in

sandbox/filesystem/index.ts:270

##### makeDir()

> **makeDir**(`path`, `opts`?): `Promise`\<`boolean`\>

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

• **path**: `string`

path to a new directory. For example '/dirA/dirB' when creating 'dirB'.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

###### Defined in

sandbox/filesystem/index.ts:308

##### read()

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`string`\>

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`string`\>

file content as string

###### Defined in

sandbox/filesystem/index.ts:123

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Uint8Array`\>

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### Defined in

sandbox/filesystem/index.ts:138

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Blob`\>

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### Defined in

sandbox/filesystem/index.ts:153

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`ReadableStream`\<`Uint8Array`\>\>

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

###### Defined in

sandbox/filesystem/index.ts:168

##### remove()

> **remove**(`path`, `opts`?): `Promise`\<`void`\>

Remove a file or directory.

###### Parameters

• **path**: `string`

path to a file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:377

##### rename()

> **rename**(`oldPath`, `newPath`, `opts`?): `Promise`\<`EntryInfo`\>

Rename a file or directory.

###### Parameters

• **oldPath**: `string`

path to the file or directory to rename.

• **newPath**: `string`

new path for the file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

###### Defined in

sandbox/filesystem/index.ts:339

##### watchDir()

> **watchDir**(`path`, `onEvent`, `opts`?): `Promise`\<`WatchHandle`\>

Start watching a directory for filesystem events.

###### Parameters

• **path**: `string`

path to directory to watch.

• **onEvent**

callback to call when an event in the directory occurs.

• **opts?**: `WatchOpts`

connection options.

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

###### Defined in

sandbox/filesystem/index.ts:430

##### write()

> **write**(`path`, `data`, `opts`?): `Promise`\<`EntryInfo`\>

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

• **path**: `string`

path to file.

• **data**: `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\>

data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### Defined in

sandbox/filesystem/index.ts:224

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

##### name

> **name**: `string`

Name of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:33

##### path

> **path**: `string`

Path to the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:41

##### type?

> `optional` **type**: `FileType`

Type of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:37

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76

***

### WatchOpts

Options for watching a directory.

#### Properties

##### onExit()?

> `optional` **onExit**: (`err`?) => `void` \| `Promise`\<`void`\>

Callback to call when the watch operation stops.

###### Parameters

• **err?**: `Error`

###### Returns

`void` \| `Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:93

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

###### Defined in

sandbox/filesystem/index.ts:89

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76


# sandbox

## Classes

### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

##### commands

> `readonly` **commands**: `Commands`

Module for running commands in the sandbox

###### Defined in

sandbox/index.ts:74

##### files

> `readonly` **files**: `Filesystem`

Module for interacting with the sandbox filesystem

###### Defined in

sandbox/index.ts:70

##### pty

> `readonly` **pty**: `Pty`

Module for interacting with the sandbox pseudo-terminals

###### Defined in

sandbox/index.ts:78

##### sandboxId

> `readonly` **sandboxId**: `string`

Unique identifier of the sandbox.

###### Defined in

sandbox/index.ts:83

#### Methods

##### downloadUrl()

> **downloadUrl**(`path`): `string`

Get the URL to download a file from the sandbox.

###### Parameters

• **path**: `string`

path to the file to download.

###### Returns

`string`

URL for downloading file.

###### Defined in

sandbox/index.ts:339

##### getHost()

> **getHost**(`port`): `string`

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

• **port**: `number`

number of the port in the sandbox.

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
``

###### Defined in

sandbox/index.ts:237

##### isRunning()

> **isRunning**(`opts`?): `Promise`\<`boolean`\>

Check if the sandbox is running.

###### Parameters

• **opts?**: `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\>

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

###### Defined in

sandbox/index.ts:259

##### kill()

> **kill**(`opts`?): `Promise`\<`void`\>

Kill the sandbox.

###### Parameters

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:310

##### setTimeout()

> **setTimeout**(`timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:290

##### uploadUrl()

> **uploadUrl**(`path`?): `string`

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

• **path?**: `string`

the directory where to upload the file, defaults to user's home directory.

###### Returns

`string`

URL for uploading file.

###### Defined in

sandbox/index.ts:328

##### connect()

> `static` **connect**\<`S`\>(`this`, `sandboxId`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\>

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

###### Defined in

sandbox/index.ts:209

##### create()

###### create(this, opts)

> `static` **create**\<`S`\>(`this`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:143

###### create(this, template, opts)

> `static` **create**\<`S`\>(`this`, `template`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the specified sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **template**: `string`

sandbox template name or ID.

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:162

##### kill()

> `static` **kill**(`sandboxId`, `opts`?): `Promise`\<`boolean`\>

Kill the sandbox specified by sandbox ID.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

###### Defined in

sandbox/sandboxApi.ts:55

##### list()

> `static` **list**(`opts`?): `Promise`\<`SandboxInfo`[]\>

List all running sandboxes.

###### Parameters

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

###### Defined in

sandbox/sandboxApi.ts:90

##### setTimeout()

> `static` **setTimeout**(`sandboxId`, `timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/sandboxApi.ts:129

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

##### accessToken?

> `optional` **accessToken**: `string`

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

###### Defined in

connectionConfig.ts:24

##### apiKey?

> `optional` **apiKey**: `string`

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

###### Defined in

connectionConfig.ts:18

##### debug?

> `optional` **debug**: `boolean`

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

###### Defined in

connectionConfig.ts:36

##### domain?

> `optional` **domain**: `string`

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

###### Defined in

connectionConfig.ts:30

##### envs?

> `optional` **envs**: `Record`\<`string`, `string`\>

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:32

##### logger?

> `optional` **logger**: `Logger`

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

###### Defined in

connectionConfig.ts:46

##### metadata?

> `optional` **metadata**: `Record`\<`string`, `string`\>

Custom metadata for the sandbox.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:23

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```

###### Defined in

sandbox/index.ts:39


# errors

## Classes

### AuthenticationError

Thrown when authentication fails.

#### Constructors

##### new AuthenticationError()

> **new AuthenticationError**(`message`): `AuthenticationError`

###### Parameters

• **message**: `any`

###### Returns

`AuthenticationError`

###### Defined in

errors.ts:72

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

##### new InvalidArgumentError()

> **new InvalidArgumentError**(`message`): `InvalidArgumentError`

###### Parameters

• **message**: `string`

###### Returns

`InvalidArgumentError`

###### Defined in

errors.ts:42

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

##### new NotEnoughSpaceError()

> **new NotEnoughSpaceError**(`message`): `NotEnoughSpaceError`

###### Parameters

• **message**: `string`

###### Returns

`NotEnoughSpaceError`

###### Defined in

errors.ts:52

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

##### new NotFoundError()

> **new NotFoundError**(`message`): `NotFoundError`

###### Parameters

• **message**: `string`

###### Returns

`NotFoundError`

###### Defined in

errors.ts:62

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`

#### Constructors

##### new SandboxError()

> **new SandboxError**(`message`): `SandboxError`

###### Parameters

• **message**: `any`

###### Returns

`SandboxError`

###### Defined in

errors.ts:14

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

##### new TemplateError()

> **new TemplateError**(`message`): `TemplateError`

###### Parameters

• **message**: `string`

###### Returns

`TemplateError`

###### Defined in

errors.ts:82

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

##### new TimeoutError()

> **new TimeoutError**(`message`): `TimeoutError`

###### Parameters

• **message**: `string`

###### Returns

`TimeoutError`

###### Defined in

errors.ts:32

## Functions

### formatSandboxTimeoutError()

> **formatSandboxTimeoutError**(`message`): `TimeoutError`

#### Parameters

• **message**: `string`

#### Returns

`TimeoutError`

#### Defined in

errors.ts:2


# sandbox/filesystem

## Enumerations

### FileType

Sandbox filesystem object type.

#### Enumeration Members

##### DIR

> **DIR**: `"dir"`

Filesystem object is a directory.

###### Defined in

sandbox/filesystem/index.ts:55

##### FILE

> **FILE**: `"file"`

Filesystem object is a file.

###### Defined in

sandbox/filesystem/index.ts:51

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

##### new Filesystem()

> **new Filesystem**(`transport`, `envdApi`, `connectionConfig`): `Filesystem`

###### Parameters

• **transport**: `Transport`

• **envdApi**: `EnvdApiClient`

• **connectionConfig**: `ConnectionConfig`

###### Returns

`Filesystem`

###### Defined in

sandbox/filesystem/index.ts:104

#### Methods

##### exists()

> **exists**(`path`, `opts`?): `Promise`\<`boolean`\>

Check if a file or a directory exists.

###### Parameters

• **path**: `string`

path to a file or a directory

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

###### Defined in

sandbox/filesystem/index.ts:399

##### list()

> **list**(`path`, `opts`?): `Promise`\<`EntryInfo`[]\>

List entries in a directory.

###### Parameters

• **path**: `string`

path to the directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

###### Defined in

sandbox/filesystem/index.ts:270

##### makeDir()

> **makeDir**(`path`, `opts`?): `Promise`\<`boolean`\>

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

• **path**: `string`

path to a new directory. For example '/dirA/dirB' when creating 'dirB'.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

###### Defined in

sandbox/filesystem/index.ts:308

##### read()

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`string`\>

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`string`\>

file content as string

###### Defined in

sandbox/filesystem/index.ts:123

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Uint8Array`\>

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### Defined in

sandbox/filesystem/index.ts:138

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Blob`\>

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### Defined in

sandbox/filesystem/index.ts:153

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`ReadableStream`\<`Uint8Array`\>\>

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

###### Defined in

sandbox/filesystem/index.ts:168

##### remove()

> **remove**(`path`, `opts`?): `Promise`\<`void`\>

Remove a file or directory.

###### Parameters

• **path**: `string`

path to a file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:377

##### rename()

> **rename**(`oldPath`, `newPath`, `opts`?): `Promise`\<`EntryInfo`\>

Rename a file or directory.

###### Parameters

• **oldPath**: `string`

path to the file or directory to rename.

• **newPath**: `string`

new path for the file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

###### Defined in

sandbox/filesystem/index.ts:339

##### watchDir()

> **watchDir**(`path`, `onEvent`, `opts`?): `Promise`\<`WatchHandle`\>

Start watching a directory for filesystem events.

###### Parameters

• **path**: `string`

path to directory to watch.

• **onEvent**

callback to call when an event in the directory occurs.

• **opts?**: `WatchOpts`

connection options.

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

###### Defined in

sandbox/filesystem/index.ts:430

##### write()

> **write**(`path`, `data`, `opts`?): `Promise`\<`EntryInfo`\>

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

• **path**: `string`

path to file.

• **data**: `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\>

data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### Defined in

sandbox/filesystem/index.ts:224

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

##### name

> **name**: `string`

Name of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:33

##### path

> **path**: `string`

Path to the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:41

##### type?

> `optional` **type**: `FileType`

Type of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:37

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76

***

### WatchOpts

Options for watching a directory.

#### Properties

##### onExit()?

> `optional` **onExit**: (`err`?) => `void` \| `Promise`\<`void`\>

Callback to call when the watch operation stops.

###### Parameters

• **err?**: `Error`

###### Returns

`void` \| `Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:93

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

###### Defined in

sandbox/filesystem/index.ts:89

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76


# sandbox

## Classes

### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

##### commands

> `readonly` **commands**: `Commands`

Module for running commands in the sandbox

###### Defined in

sandbox/index.ts:74

##### files

> `readonly` **files**: `Filesystem`

Module for interacting with the sandbox filesystem

###### Defined in

sandbox/index.ts:70

##### pty

> `readonly` **pty**: `Pty`

Module for interacting with the sandbox pseudo-terminals

###### Defined in

sandbox/index.ts:78

##### sandboxId

> `readonly` **sandboxId**: `string`

Unique identifier of the sandbox.

###### Defined in

sandbox/index.ts:83

#### Methods

##### downloadUrl()

> **downloadUrl**(`path`): `string`

Get the URL to download a file from the sandbox.

###### Parameters

• **path**: `string`

path to the file to download.

###### Returns

`string`

URL for downloading file.

###### Defined in

sandbox/index.ts:339

##### getHost()

> **getHost**(`port`): `string`

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

• **port**: `number`

number of the port in the sandbox.

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
``

###### Defined in

sandbox/index.ts:237

##### isRunning()

> **isRunning**(`opts`?): `Promise`\<`boolean`\>

Check if the sandbox is running.

###### Parameters

• **opts?**: `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\>

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

###### Defined in

sandbox/index.ts:259

##### kill()

> **kill**(`opts`?): `Promise`\<`void`\>

Kill the sandbox.

###### Parameters

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:310

##### setTimeout()

> **setTimeout**(`timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:290

##### uploadUrl()

> **uploadUrl**(`path`?): `string`

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

• **path?**: `string`

the directory where to upload the file, defaults to user's home directory.

###### Returns

`string`

URL for uploading file.

###### Defined in

sandbox/index.ts:328

##### connect()

> `static` **connect**\<`S`\>(`this`, `sandboxId`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\>

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

###### Defined in

sandbox/index.ts:209

##### create()

###### create(this, opts)

> `static` **create**\<`S`\>(`this`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:143

###### create(this, template, opts)

> `static` **create**\<`S`\>(`this`, `template`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the specified sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **template**: `string`

sandbox template name or ID.

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:162

##### kill()

> `static` **kill**(`sandboxId`, `opts`?): `Promise`\<`boolean`\>

Kill the sandbox specified by sandbox ID.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

###### Defined in

sandbox/sandboxApi.ts:55

##### list()

> `static` **list**(`opts`?): `Promise`\<`SandboxInfo`[]\>

List all running sandboxes.

###### Parameters

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

###### Defined in

sandbox/sandboxApi.ts:90

##### setTimeout()

> `static` **setTimeout**(`sandboxId`, `timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/sandboxApi.ts:129

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

##### accessToken?

> `optional` **accessToken**: `string`

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

###### Defined in

connectionConfig.ts:24

##### apiKey?

> `optional` **apiKey**: `string`

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

###### Defined in

connectionConfig.ts:18

##### debug?

> `optional` **debug**: `boolean`

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

###### Defined in

connectionConfig.ts:36

##### domain?

> `optional` **domain**: `string`

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

###### Defined in

connectionConfig.ts:30

##### envs?

> `optional` **envs**: `Record`\<`string`, `string`\>

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:32

##### logger?

> `optional` **logger**: `Logger`

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

###### Defined in

connectionConfig.ts:46

##### metadata?

> `optional` **metadata**: `Record`\<`string`, `string`\>

Custom metadata for the sandbox.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:23

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```

###### Defined in

sandbox/index.ts:39


# errors

## Classes

### AuthenticationError

Thrown when authentication fails.

#### Constructors

##### new AuthenticationError()

> **new AuthenticationError**(`message`): `AuthenticationError`

###### Parameters

• **message**: `any`

###### Returns

`AuthenticationError`

###### Defined in

errors.ts:72

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

##### new InvalidArgumentError()

> **new InvalidArgumentError**(`message`): `InvalidArgumentError`

###### Parameters

• **message**: `string`

###### Returns

`InvalidArgumentError`

###### Defined in

errors.ts:42

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

##### new NotEnoughSpaceError()

> **new NotEnoughSpaceError**(`message`): `NotEnoughSpaceError`

###### Parameters

• **message**: `string`

###### Returns

`NotEnoughSpaceError`

###### Defined in

errors.ts:52

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

##### new NotFoundError()

> **new NotFoundError**(`message`): `NotFoundError`

###### Parameters

• **message**: `string`

###### Returns

`NotFoundError`

###### Defined in

errors.ts:62

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

##### new RateLimitError()

> **new RateLimitError**(`message`): `RateLimitError`

###### Parameters

• **message**: `any`

###### Returns

`RateLimitError`

###### Defined in

errors.ts:92

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

##### new SandboxError()

> **new SandboxError**(`message`): `SandboxError`

###### Parameters

• **message**: `any`

###### Returns

`SandboxError`

###### Defined in

errors.ts:14

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

##### new TemplateError()

> **new TemplateError**(`message`): `TemplateError`

###### Parameters

• **message**: `string`

###### Returns

`TemplateError`

###### Defined in

errors.ts:82

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

##### new TimeoutError()

> **new TimeoutError**(`message`): `TimeoutError`

###### Parameters

• **message**: `string`

###### Returns

`TimeoutError`

###### Defined in

errors.ts:32

## Functions

### formatSandboxTimeoutError()

> **formatSandboxTimeoutError**(`message`): `TimeoutError`

#### Parameters

• **message**: `string`

#### Returns

`TimeoutError`

#### Defined in

errors.ts:2


# sandbox/filesystem

## Enumerations

### FileType

Sandbox filesystem object type.

#### Enumeration Members

##### DIR

> **DIR**: `"dir"`

Filesystem object is a directory.

###### Defined in

sandbox/filesystem/index.ts:55

##### FILE

> **FILE**: `"file"`

Filesystem object is a file.

###### Defined in

sandbox/filesystem/index.ts:51

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

##### new Filesystem()

> **new Filesystem**(`transport`, `envdApi`, `connectionConfig`): `Filesystem`

###### Parameters

• **transport**: `Transport`

• **envdApi**: `EnvdApiClient`

• **connectionConfig**: `ConnectionConfig`

###### Returns

`Filesystem`

###### Defined in

sandbox/filesystem/index.ts:104

#### Methods

##### exists()

> **exists**(`path`, `opts`?): `Promise`\<`boolean`\>

Check if a file or a directory exists.

###### Parameters

• **path**: `string`

path to a file or a directory

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

###### Defined in

sandbox/filesystem/index.ts:399

##### list()

> **list**(`path`, `opts`?): `Promise`\<`EntryInfo`[]\>

List entries in a directory.

###### Parameters

• **path**: `string`

path to the directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

###### Defined in

sandbox/filesystem/index.ts:270

##### makeDir()

> **makeDir**(`path`, `opts`?): `Promise`\<`boolean`\>

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

• **path**: `string`

path to a new directory. For example '/dirA/dirB' when creating 'dirB'.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

###### Defined in

sandbox/filesystem/index.ts:308

##### read()

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`string`\>

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`string`\>

file content as string

###### Defined in

sandbox/filesystem/index.ts:123

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Uint8Array`\>

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### Defined in

sandbox/filesystem/index.ts:138

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Blob`\>

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### Defined in

sandbox/filesystem/index.ts:153

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`ReadableStream`\<`Uint8Array`\>\>

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

###### Defined in

sandbox/filesystem/index.ts:168

##### remove()

> **remove**(`path`, `opts`?): `Promise`\<`void`\>

Remove a file or directory.

###### Parameters

• **path**: `string`

path to a file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:377

##### rename()

> **rename**(`oldPath`, `newPath`, `opts`?): `Promise`\<`EntryInfo`\>

Rename a file or directory.

###### Parameters

• **oldPath**: `string`

path to the file or directory to rename.

• **newPath**: `string`

new path for the file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

###### Defined in

sandbox/filesystem/index.ts:339

##### watchDir()

> **watchDir**(`path`, `onEvent`, `opts`?): `Promise`\<`WatchHandle`\>

Start watching a directory for filesystem events.

###### Parameters

• **path**: `string`

path to directory to watch.

• **onEvent**

callback to call when an event in the directory occurs.

• **opts?**: `WatchOpts`

connection options.

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

###### Defined in

sandbox/filesystem/index.ts:430

##### write()

> **write**(`path`, `data`, `opts`?): `Promise`\<`EntryInfo`\>

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

• **path**: `string`

path to file.

• **data**: `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\>

data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### Defined in

sandbox/filesystem/index.ts:224

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

##### name

> **name**: `string`

Name of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:33

##### path

> **path**: `string`

Path to the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:41

##### type?

> `optional` **type**: `FileType`

Type of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:37

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76

***

### WatchOpts

Options for watching a directory.

#### Properties

##### onExit()?

> `optional` **onExit**: (`err`?) => `void` \| `Promise`\<`void`\>

Callback to call when the watch operation stops.

###### Parameters

• **err?**: `Error`

###### Returns

`void` \| `Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:93

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

###### Defined in

sandbox/filesystem/index.ts:89

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76


# sandbox

## Classes

### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

##### commands

> `readonly` **commands**: `Commands`

Module for running commands in the sandbox

###### Defined in

sandbox/index.ts:74

##### files

> `readonly` **files**: `Filesystem`

Module for interacting with the sandbox filesystem

###### Defined in

sandbox/index.ts:70

##### pty

> `readonly` **pty**: `Pty`

Module for interacting with the sandbox pseudo-terminals

###### Defined in

sandbox/index.ts:78

##### sandboxId

> `readonly` **sandboxId**: `string`

Unique identifier of the sandbox.

###### Defined in

sandbox/index.ts:83

#### Methods

##### downloadUrl()

> **downloadUrl**(`path`): `string`

Get the URL to download a file from the sandbox.

###### Parameters

• **path**: `string`

path to the file to download.

###### Returns

`string`

URL for downloading file.

###### Defined in

sandbox/index.ts:339

##### getHost()

> **getHost**(`port`): `string`

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

• **port**: `number`

number of the port in the sandbox.

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
``

###### Defined in

sandbox/index.ts:237

##### isRunning()

> **isRunning**(`opts`?): `Promise`\<`boolean`\>

Check if the sandbox is running.

###### Parameters

• **opts?**: `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\>

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

###### Defined in

sandbox/index.ts:259

##### kill()

> **kill**(`opts`?): `Promise`\<`void`\>

Kill the sandbox.

###### Parameters

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:310

##### setTimeout()

> **setTimeout**(`timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:290

##### uploadUrl()

> **uploadUrl**(`path`?): `string`

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

• **path?**: `string`

the directory where to upload the file, defaults to user's home directory.

###### Returns

`string`

URL for uploading file.

###### Defined in

sandbox/index.ts:328

##### connect()

> `static` **connect**\<`S`\>(`this`, `sandboxId`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\>

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

###### Defined in

sandbox/index.ts:209

##### create()

###### create(this, opts)

> `static` **create**\<`S`\>(`this`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:143

###### create(this, template, opts)

> `static` **create**\<`S`\>(`this`, `template`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the specified sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **template**: `string`

sandbox template name or ID.

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:162

##### kill()

> `static` **kill**(`sandboxId`, `opts`?): `Promise`\<`boolean`\>

Kill the sandbox specified by sandbox ID.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

###### Defined in

sandbox/sandboxApi.ts:55

##### list()

> `static` **list**(`opts`?): `Promise`\<`SandboxInfo`[]\>

List all running sandboxes.

###### Parameters

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

###### Defined in

sandbox/sandboxApi.ts:90

##### setTimeout()

> `static` **setTimeout**(`sandboxId`, `timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/sandboxApi.ts:129

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

##### accessToken?

> `optional` **accessToken**: `string`

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

###### Defined in

connectionConfig.ts:24

##### apiKey?

> `optional` **apiKey**: `string`

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

###### Defined in

connectionConfig.ts:18

##### debug?

> `optional` **debug**: `boolean`

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

###### Defined in

connectionConfig.ts:36

##### domain?

> `optional` **domain**: `string`

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

###### Defined in

connectionConfig.ts:30

##### envs?

> `optional` **envs**: `Record`\<`string`, `string`\>

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:32

##### logger?

> `optional` **logger**: `Logger`

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

###### Defined in

connectionConfig.ts:46

##### metadata?

> `optional` **metadata**: `Record`\<`string`, `string`\>

Custom metadata for the sandbox.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:23

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```

###### Defined in

sandbox/index.ts:39


# errors

## Classes

### AuthenticationError

Thrown when authentication fails.

#### Constructors

##### new AuthenticationError()

> **new AuthenticationError**(`message`): `AuthenticationError`

###### Parameters

• **message**: `any`

###### Returns

`AuthenticationError`

###### Defined in

errors.ts:72

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

##### new InvalidArgumentError()

> **new InvalidArgumentError**(`message`): `InvalidArgumentError`

###### Parameters

• **message**: `string`

###### Returns

`InvalidArgumentError`

###### Defined in

errors.ts:42

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

##### new NotEnoughSpaceError()

> **new NotEnoughSpaceError**(`message`): `NotEnoughSpaceError`

###### Parameters

• **message**: `string`

###### Returns

`NotEnoughSpaceError`

###### Defined in

errors.ts:52

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

##### new NotFoundError()

> **new NotFoundError**(`message`): `NotFoundError`

###### Parameters

• **message**: `string`

###### Returns

`NotFoundError`

###### Defined in

errors.ts:62

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

##### new RateLimitError()

> **new RateLimitError**(`message`): `RateLimitError`

###### Parameters

• **message**: `any`

###### Returns

`RateLimitError`

###### Defined in

errors.ts:92

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

##### new SandboxError()

> **new SandboxError**(`message`): `SandboxError`

###### Parameters

• **message**: `any`

###### Returns

`SandboxError`

###### Defined in

errors.ts:14

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

##### new TemplateError()

> **new TemplateError**(`message`): `TemplateError`

###### Parameters

• **message**: `string`

###### Returns

`TemplateError`

###### Defined in

errors.ts:82

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

##### new TimeoutError()

> **new TimeoutError**(`message`): `TimeoutError`

###### Parameters

• **message**: `string`

###### Returns

`TimeoutError`

###### Defined in

errors.ts:32

## Functions

### formatSandboxTimeoutError()

> **formatSandboxTimeoutError**(`message`): `TimeoutError`

#### Parameters

• **message**: `string`

#### Returns

`TimeoutError`

#### Defined in

errors.ts:2


# sandbox/filesystem

## Enumerations

### FileType

Sandbox filesystem object type.

#### Enumeration Members

##### DIR

> **DIR**: `"dir"`

Filesystem object is a directory.

###### Defined in

sandbox/filesystem/index.ts:55

##### FILE

> **FILE**: `"file"`

Filesystem object is a file.

###### Defined in

sandbox/filesystem/index.ts:51

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

##### new Filesystem()

> **new Filesystem**(`transport`, `envdApi`, `connectionConfig`): `Filesystem`

###### Parameters

• **transport**: `Transport`

• **envdApi**: `EnvdApiClient`

• **connectionConfig**: `ConnectionConfig`

###### Returns

`Filesystem`

###### Defined in

sandbox/filesystem/index.ts:104

#### Methods

##### exists()

> **exists**(`path`, `opts`?): `Promise`\<`boolean`\>

Check if a file or a directory exists.

###### Parameters

• **path**: `string`

path to a file or a directory

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

###### Defined in

sandbox/filesystem/index.ts:402

##### list()

> **list**(`path`, `opts`?): `Promise`\<`EntryInfo`[]\>

List entries in a directory.

###### Parameters

• **path**: `string`

path to the directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

###### Defined in

sandbox/filesystem/index.ts:273

##### makeDir()

> **makeDir**(`path`, `opts`?): `Promise`\<`boolean`\>

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

• **path**: `string`

path to a new directory. For example '/dirA/dirB' when creating 'dirB'.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

###### Defined in

sandbox/filesystem/index.ts:311

##### read()

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`string`\>

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`string`\>

file content as string

###### Defined in

sandbox/filesystem/index.ts:123

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Uint8Array`\>

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### Defined in

sandbox/filesystem/index.ts:138

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`Blob`\>

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### Defined in

sandbox/filesystem/index.ts:153

###### read(path, opts)

> **read**(`path`, `opts`?): `Promise`\<`ReadableStream`\<`Uint8Array`\>\>

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

• **path**: `string`

path to the file.

• **opts?**: `FilesystemRequestOpts` & `object`

connection options.

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

###### Defined in

sandbox/filesystem/index.ts:168

##### remove()

> **remove**(`path`, `opts`?): `Promise`\<`void`\>

Remove a file or directory.

###### Parameters

• **path**: `string`

path to a file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:380

##### rename()

> **rename**(`oldPath`, `newPath`, `opts`?): `Promise`\<`EntryInfo`\>

Rename a file or directory.

###### Parameters

• **oldPath**: `string`

path to the file or directory to rename.

• **newPath**: `string`

new path for the file or directory.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

###### Defined in

sandbox/filesystem/index.ts:342

##### watchDir()

> **watchDir**(`path`, `onEvent`, `opts`?): `Promise`\<`WatchHandle`\>

Start watching a directory for filesystem events.

###### Parameters

• **path**: `string`

path to directory to watch.

• **onEvent**

callback to call when an event in the directory occurs.

• **opts?**: `WatchOpts`

connection options.

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

###### Defined in

sandbox/filesystem/index.ts:433

##### write()

> **write**(`path`, `data`, `opts`?): `Promise`\<`EntryInfo`\>

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

• **path**: `string`

path to file.

• **data**: `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\>

data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`.

• **opts?**: `FilesystemRequestOpts`

connection options.

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### Defined in

sandbox/filesystem/index.ts:224

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

##### name

> **name**: `string`

Name of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:33

##### path

> **path**: `string`

Path to the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:41

##### type?

> `optional` **type**: `FileType`

Type of the filesystem object.

###### Defined in

sandbox/filesystem/index.ts:37

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76

***

### WatchOpts

Options for watching a directory.

#### Properties

##### onExit()?

> `optional` **onExit**: (`err`?) => `void` \| `Promise`\<`void`\>

Callback to call when the watch operation stops.

###### Parameters

• **err?**: `Error`

###### Returns

`void` \| `Promise`\<`void`\>

###### Defined in

sandbox/filesystem/index.ts:93

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

###### Defined in

sandbox/filesystem/index.ts:89

##### user?

> `optional` **user**: `Username`

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

###### Defined in

sandbox/filesystem/index.ts:76


# sandbox

## Classes

### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

##### commands

> `readonly` **commands**: `Commands`

Module for running commands in the sandbox

###### Defined in

sandbox/index.ts:74

##### files

> `readonly` **files**: `Filesystem`

Module for interacting with the sandbox filesystem

###### Defined in

sandbox/index.ts:70

##### pty

> `readonly` **pty**: `Pty`

Module for interacting with the sandbox pseudo-terminals

###### Defined in

sandbox/index.ts:78

##### sandboxId

> `readonly` **sandboxId**: `string`

Unique identifier of the sandbox.

###### Defined in

sandbox/index.ts:83

#### Methods

##### downloadUrl()

> **downloadUrl**(`path`): `string`

Get the URL to download a file from the sandbox.

###### Parameters

• **path**: `string`

path to the file to download.

###### Returns

`string`

URL for downloading file.

###### Defined in

sandbox/index.ts:339

##### getHost()

> **getHost**(`port`): `string`

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

• **port**: `number`

number of the port in the sandbox.

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
``

###### Defined in

sandbox/index.ts:237

##### isRunning()

> **isRunning**(`opts`?): `Promise`\<`boolean`\>

Check if the sandbox is running.

###### Parameters

• **opts?**: `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\>

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

###### Defined in

sandbox/index.ts:259

##### kill()

> **kill**(`opts`?): `Promise`\<`void`\>

Kill the sandbox.

###### Parameters

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:310

##### setTimeout()

> **setTimeout**(`timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\>

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/index.ts:290

##### uploadUrl()

> **uploadUrl**(`path`?): `string`

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

• **path?**: `string`

the directory where to upload the file, defaults to user's home directory.

###### Returns

`string`

URL for uploading file.

###### Defined in

sandbox/index.ts:328

##### connect()

> `static` **connect**\<`S`\>(`this`, `sandboxId`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\>

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

###### Defined in

sandbox/index.ts:209

##### create()

###### create(this, opts)

> `static` **create**\<`S`\>(`this`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:143

###### create(this, template, opts)

> `static` **create**\<`S`\>(`this`, `template`, `opts`?): `Promise`\<`InstanceType`\<`S`\>\>

Create a new sandbox from the specified sandbox template.

###### Type Parameters

• **S** *extends* *typeof* `Sandbox`

###### Parameters

• **this**: `S`

• **template**: `string`

sandbox template name or ID.

• **opts?**: `SandboxOpts`

connection options.

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

###### Defined in

sandbox/index.ts:162

##### kill()

> `static` **kill**(`sandboxId`, `opts`?): `Promise`\<`boolean`\>

Kill the sandbox specified by sandbox ID.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

###### Defined in

sandbox/sandboxApi.ts:55

##### list()

> `static` **list**(`opts`?): `Promise`\<`SandboxInfo`[]\>

List all running sandboxes.

###### Parameters

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

###### Defined in

sandbox/sandboxApi.ts:90

##### setTimeout()

> `static` **setTimeout**(`sandboxId`, `timeoutMs`, `opts`?): `Promise`\<`void`\>

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

• **sandboxId**: `string`

sandbox ID.

• **timeoutMs**: `number`

timeout in **milliseconds**.

• **opts?**: `SandboxApiOpts`

connection options.

###### Returns

`Promise`\<`void`\>

###### Defined in

sandbox/sandboxApi.ts:129

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

##### accessToken?

> `optional` **accessToken**: `string`

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

###### Defined in

connectionConfig.ts:24

##### apiKey?

> `optional` **apiKey**: `string`

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

###### Defined in

connectionConfig.ts:18

##### debug?

> `optional` **debug**: `boolean`

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

###### Defined in

connectionConfig.ts:36

##### domain?

> `optional` **domain**: `string`

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

###### Defined in

connectionConfig.ts:30

##### envs?

> `optional` **envs**: `Record`\<`string`, `string`\>

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:32

##### logger?

> `optional` **logger**: `Logger`

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

###### Defined in

connectionConfig.ts:46

##### metadata?

> `optional` **metadata**: `Record`\<`string`, `string`\>

Custom metadata for the sandbox.

###### Default

```ts
{}
```

###### Defined in

sandbox/index.ts:23

##### requestTimeoutMs?

> `optional` **requestTimeoutMs**: `number`

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

###### Defined in

connectionConfig.ts:42

##### timeoutMs?

> `optional` **timeoutMs**: `number`

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```

###### Defined in

sandbox/index.ts:39


### Commands

Module for starting and interacting with commands in the sandbox.

#### Constructors

```ts
new Commands(transport: Transport, connectionConfig: ConnectionConfig): Commands
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Commands`

#### Methods

### connect()

```ts
connect(pid: number, opts?: CommandConnectOpts): Promise<CommandHandle>
```

Connect to a running command.
You can use CommandHandle.wait to wait for the command to finish and get execution results.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command to connect to. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandConnectOpts` | connection options. |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### kill()

```ts
kill(pid: number, opts?: CommandRequestOpts): Promise<boolean>
```

Kill a running command specified by its process ID.
It uses `SIGKILL` signal to kill the command.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the command was killed, `false` if the command was not found.

### list()

```ts
list(opts?: CommandRequestOpts): Promise<ProcessInfo[]>
```

List all running commands and PTY sessions.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`ProcessInfo`[]\>

list of running commands and PTY sessions.

### run()

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandResult>
```

Start a new command and wait until it finishes executing.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command. |

###### Returns

`Promise`\<`CommandResult`\>

`CommandResult` result of the command execution.

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandHandle>
```

Start a new command in the background.
You can use CommandHandle.wait to wait for the command to finish and get its result.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### sendStdin()

```ts
sendStdin(
   pid: number, 
   data: string, 
opts?: CommandRequestOpts): Promise<void>
```

Send data to command stdin.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `data` | `string` | data to send to the command. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

***

### Pty

Module for interacting with PTYs (pseudo-terminals) in the sandbox.

#### Constructors

```ts
new Pty(transport: Transport, connectionConfig: ConnectionConfig): Pty
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Pty`

#### Methods

### create()

```ts
create(opts: PtyCreateOpts): Promise<CommandHandle>
```

Create a new PTY (pseudo-terminal).

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts` | `PtyCreateOpts` | options for creating the PTY. |

###### Returns

`Promise`\<`CommandHandle`\>

handle to interact with the PTY.

### kill()

```ts
kill(pid: number, opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Kill a running PTY specified by process ID.
It uses `SIGKILL` signal to kill the PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the PTY was killed, `false` if the PTY was not found.

### resize()

```ts
resize(
   pid: number, 
   size: object, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Resize PTY.
Call this when the terminal window is resized and the number of columns and rows has changed.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `size` | `object` | new size of the PTY. |
| `size.cols` | `number` | - |
| `size.rows`? | `number` | - |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### sendInput()

```ts
sendInput(
   pid: number, 
   data: Uint8Array, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Send input to a PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `data` | `Uint8Array` | input data to send to the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### CommandRequestOpts

Options for sending a command request.

#### Extended by

- `CommandStartOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### CommandStartOpts

Options for starting a new command.

#### Properties

### background?

```ts
optional background: boolean;
```

If true, starts command in the background and the method returns immediately.
You can use CommandHandle.wait to wait for the command to finish.

### cwd?

```ts
optional cwd: string;
```

Working directory for the command.

###### Default

```ts
// home directory of the user used to start the command
```

### envs?

```ts
optional envs: Record<string, string>;
```

Environment variables used for the command.

This overrides the default environment variables from `Sandbox` constructor.

###### Default

`{}`

### onStderr()?

```ts
optional onStderr: (data: string) => void | Promise<void>;
```

Callback for command stderr output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### onStdout()?

```ts
optional onStdout: (data: string) => void | Promise<void>;
```

Callback for command stdout output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the command in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to run the command as.

###### Default

`user`

***

### ProcessInfo

Information about a command, PTY session or start command running in the sandbox as process.

#### Properties

### args

```ts
args: string[];
```

Command arguments.

### cmd

```ts
cmd: string;
```

Command that was executed.

### cwd?

```ts
optional cwd: string;
```

Executed command working directory.

### envs

```ts
envs: Record<string, string>;
```

Environment variables used for the command.

### pid

```ts
pid: number;
```

Process ID.

### tag?

```ts
optional tag: string;
```

Custom tag used for identifying special commands like start command in the custom template.

## Type Aliases

### CommandConnectOpts

```ts
type CommandConnectOpts: Pick<CommandStartOpts, "onStderr" | "onStdout" | "timeoutMs"> & CommandRequestOpts;
```

Options for connecting to a command.


### AuthenticationError

Thrown when authentication fails.

#### Constructors

```ts
new AuthenticationError(message: any): AuthenticationError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`AuthenticationError`

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

```ts
new InvalidArgumentError(message: string): InvalidArgumentError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`InvalidArgumentError`

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

```ts
new NotEnoughSpaceError(message: string): NotEnoughSpaceError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotEnoughSpaceError`

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

```ts
new NotFoundError(message: string): NotFoundError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotFoundError`

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

```ts
new RateLimitError(message: any): RateLimitError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`RateLimitError`

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

```ts
new SandboxError(message: any): SandboxError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`SandboxError`

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

```ts
new TemplateError(message: string): TemplateError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TemplateError`

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

```ts
new TimeoutError(message: string): TimeoutError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TimeoutError`

## Functions

### formatSandboxTimeoutError()

```ts
function formatSandboxTimeoutError(message: string): TimeoutError
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

#### Returns

`TimeoutError`


### FileType

Sandbox filesystem object type.

#### Enumeration Members

| Enumeration Member | Value | Description |
| ------ | ------ | ------ |
| `DIR` | `"dir"` | Filesystem object is a directory. |
| `FILE` | `"file"` | Filesystem object is a file. |

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

```ts
new Filesystem(
   transport: Transport, 
   envdApi: EnvdApiClient, 
   connectionConfig: ConnectionConfig): Filesystem
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `envdApi` | `EnvdApiClient` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Filesystem`

#### Methods

### exists()

```ts
exists(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Check if a file or a directory exists.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or a directory |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

### list()

```ts
list(path: string, opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

List entries in a directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

### makeDir()

```ts
makeDir(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a new directory. For example '/dirA/dirB' when creating 'dirB'. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

### read()

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<string>
```

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`string`\>

file content as string

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Uint8Array>
```

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Blob>
```

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<ReadableStream<Uint8Array>>
```

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

### remove()

```ts
remove(path: string, opts?: FilesystemRequestOpts): Promise<void>
```

Remove a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

### rename()

```ts
rename(
   oldPath: string, 
   newPath: string, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Rename a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `oldPath` | `string` | path to the file or directory to rename. |
| `newPath` | `string` | new path for the file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

### watchDir()

```ts
watchDir(
   path: string, 
   onEvent: (event: FilesystemEvent) => void | Promise<void>, 
opts?: WatchOpts): Promise<WatchHandle>
```

Start watching a directory for filesystem events.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to directory to watch. |
| `onEvent` | (`event`: `FilesystemEvent`) => `void` \| `Promise`\<`void`\> | callback to call when an event in the directory occurs. |
| `opts`? | `WatchOpts` | connection options. |

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

### write()

```ts
write(
   path: string, 
   data: string | ArrayBuffer | Blob | ReadableStream<any>, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to file. |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\> | data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

### name

```ts
name: string;
```

Name of the filesystem object.

### path

```ts
path: string;
```

Path to the filesystem object.

### type?

```ts
optional type: FileType;
```

Type of the filesystem object.

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

***

### WatchOpts

Options for watching a directory.

#### Properties

### onExit()?

```ts
optional onExit: (err?: Error) => void | Promise<void>;
```

Callback to call when the watch operation stops.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `err`? | `Error` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `commands` | `readonly` | `Commands` | Module for running commands in the sandbox |
| `files` | `readonly` | `Filesystem` | Module for interacting with the sandbox filesystem |
| `pty` | `readonly` | `Pty` | Module for interacting with the sandbox pseudo-terminals |
| `sandboxId` | `readonly` | `string` | Unique identifier of the sandbox. |

#### Methods

### downloadUrl()

```ts
downloadUrl(path: string): string
```

Get the URL to download a file from the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file to download. |

###### Returns

`string`

URL for downloading file.

### getHost()

```ts
getHost(port: number): string
```

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `port` | `number` | number of the port in the sandbox. |

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
```

### isRunning()

```ts
isRunning(opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Check if the sandbox is running.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

### kill()

```ts
kill(opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Kill the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### setTimeout()

```ts
setTimeout(timeoutMs: number, opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### uploadUrl()

```ts
uploadUrl(path?: string): string
```

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path`? | `string` | the directory where to upload the file, defaults to user's home directory. |

###### Returns

`string`

URL for uploading file.

### connect()

```ts
static connect<S>(
   this: S, 
   sandboxId: string, 
opts?: Omit<SandboxOpts, "timeoutMs" | "metadata" | "envs">): Promise<InstanceType<S>>
```

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\> | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

### kill()

```ts
static kill(sandboxId: string, opts?: SandboxApiOpts): Promise<boolean>
```

Kill the sandbox specified by sandbox ID.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

### list()

```ts
static list(opts?: SandboxApiOpts): Promise<SandboxInfo[]>
```

List all running sandboxes.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

### setTimeout()

```ts
static setTimeout(
   sandboxId: string, 
   timeoutMs: number, 
opts?: SandboxApiOpts): Promise<void>
```

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

### accessToken?

```ts
optional accessToken: string;
```

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

### apiKey?

```ts
optional apiKey: string;
```

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

### debug?

```ts
optional debug: boolean;
```

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

### domain?

```ts
optional domain: string;
```

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

### logger?

```ts
optional logger: Logger;
```

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

### metadata?

```ts
optional metadata: Record<string, string>;
```

Custom metadata for the sandbox.

###### Default

```ts
{}
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```


### Commands

Module for starting and interacting with commands in the sandbox.

#### Constructors

```ts
new Commands(transport: Transport, connectionConfig: ConnectionConfig): Commands
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Commands`

#### Methods

### connect()

```ts
connect(pid: number, opts?: CommandConnectOpts): Promise<CommandHandle>
```

Connect to a running command.
You can use CommandHandle.wait to wait for the command to finish and get execution results.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command to connect to. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandConnectOpts` | connection options. |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### kill()

```ts
kill(pid: number, opts?: CommandRequestOpts): Promise<boolean>
```

Kill a running command specified by its process ID.
It uses `SIGKILL` signal to kill the command.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the command was killed, `false` if the command was not found.

### list()

```ts
list(opts?: CommandRequestOpts): Promise<ProcessInfo[]>
```

List all running commands and PTY sessions.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`ProcessInfo`[]\>

list of running commands and PTY sessions.

### run()

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandResult>
```

Start a new command and wait until it finishes executing.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command. |

###### Returns

`Promise`\<`CommandResult`\>

`CommandResult` result of the command execution.

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandHandle>
```

Start a new command in the background.
You can use CommandHandle.wait to wait for the command to finish and get its result.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### sendStdin()

```ts
sendStdin(
   pid: number, 
   data: string, 
opts?: CommandRequestOpts): Promise<void>
```

Send data to command stdin.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `data` | `string` | data to send to the command. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

***

### Pty

Module for interacting with PTYs (pseudo-terminals) in the sandbox.

#### Constructors

```ts
new Pty(transport: Transport, connectionConfig: ConnectionConfig): Pty
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Pty`

#### Methods

### create()

```ts
create(opts: PtyCreateOpts): Promise<CommandHandle>
```

Create a new PTY (pseudo-terminal).

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts` | `PtyCreateOpts` | options for creating the PTY. |

###### Returns

`Promise`\<`CommandHandle`\>

handle to interact with the PTY.

### kill()

```ts
kill(pid: number, opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Kill a running PTY specified by process ID.
It uses `SIGKILL` signal to kill the PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the PTY was killed, `false` if the PTY was not found.

### resize()

```ts
resize(
   pid: number, 
   size: object, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Resize PTY.
Call this when the terminal window is resized and the number of columns and rows has changed.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `size` | `object` | new size of the PTY. |
| `size.cols` | `number` | - |
| `size.rows`? | `number` | - |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### sendInput()

```ts
sendInput(
   pid: number, 
   data: Uint8Array, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Send input to a PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `data` | `Uint8Array` | input data to send to the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### CommandRequestOpts

Options for sending a command request.

#### Extended by

- `CommandStartOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### CommandStartOpts

Options for starting a new command.

#### Properties

### background?

```ts
optional background: boolean;
```

If true, starts command in the background and the method returns immediately.
You can use CommandHandle.wait to wait for the command to finish.

### cwd?

```ts
optional cwd: string;
```

Working directory for the command.

###### Default

```ts
// home directory of the user used to start the command
```

### envs?

```ts
optional envs: Record<string, string>;
```

Environment variables used for the command.

This overrides the default environment variables from `Sandbox` constructor.

###### Default

`{}`

### onStderr()?

```ts
optional onStderr: (data: string) => void | Promise<void>;
```

Callback for command stderr output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### onStdout()?

```ts
optional onStdout: (data: string) => void | Promise<void>;
```

Callback for command stdout output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the command in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to run the command as.

###### Default

`user`

***

### ProcessInfo

Information about a command, PTY session or start command running in the sandbox as process.

#### Properties

### args

```ts
args: string[];
```

Command arguments.

### cmd

```ts
cmd: string;
```

Command that was executed.

### cwd?

```ts
optional cwd: string;
```

Executed command working directory.

### envs

```ts
envs: Record<string, string>;
```

Environment variables used for the command.

### pid

```ts
pid: number;
```

Process ID.

### tag?

```ts
optional tag: string;
```

Custom tag used for identifying special commands like start command in the custom template.

## Type Aliases

### CommandConnectOpts

```ts
type CommandConnectOpts: Pick<CommandStartOpts, "onStderr" | "onStdout" | "timeoutMs"> & CommandRequestOpts;
```

Options for connecting to a command.


### AuthenticationError

Thrown when authentication fails.

#### Constructors

```ts
new AuthenticationError(message: any): AuthenticationError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`AuthenticationError`

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

```ts
new InvalidArgumentError(message: string): InvalidArgumentError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`InvalidArgumentError`

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

```ts
new NotEnoughSpaceError(message: string): NotEnoughSpaceError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotEnoughSpaceError`

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

```ts
new NotFoundError(message: string): NotFoundError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotFoundError`

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

```ts
new RateLimitError(message: any): RateLimitError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`RateLimitError`

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

```ts
new SandboxError(message: any): SandboxError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`SandboxError`

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

```ts
new TemplateError(message: string): TemplateError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TemplateError`

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

```ts
new TimeoutError(message: string): TimeoutError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TimeoutError`

## Functions

### formatSandboxTimeoutError()

```ts
function formatSandboxTimeoutError(message: string): TimeoutError
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

#### Returns

`TimeoutError`


### FileType

Sandbox filesystem object type.

#### Enumeration Members

| Enumeration Member | Value | Description |
| ------ | ------ | ------ |
| `DIR` | `"dir"` | Filesystem object is a directory. |
| `FILE` | `"file"` | Filesystem object is a file. |

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

```ts
new Filesystem(
   transport: Transport, 
   envdApi: EnvdApiClient, 
   connectionConfig: ConnectionConfig): Filesystem
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `envdApi` | `EnvdApiClient` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Filesystem`

#### Methods

### exists()

```ts
exists(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Check if a file or a directory exists.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or a directory |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

### list()

```ts
list(path: string, opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

List entries in a directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

### makeDir()

```ts
makeDir(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a new directory. For example '/dirA/dirB' when creating 'dirB'. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

### read()

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<string>
```

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`string`\>

file content as string

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Uint8Array>
```

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Blob>
```

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<ReadableStream<Uint8Array>>
```

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

### remove()

```ts
remove(path: string, opts?: FilesystemRequestOpts): Promise<void>
```

Remove a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

### rename()

```ts
rename(
   oldPath: string, 
   newPath: string, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Rename a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `oldPath` | `string` | path to the file or directory to rename. |
| `newPath` | `string` | new path for the file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

### watchDir()

```ts
watchDir(
   path: string, 
   onEvent: (event: FilesystemEvent) => void | Promise<void>, 
opts?: WatchOpts): Promise<WatchHandle>
```

Start watching a directory for filesystem events.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to directory to watch. |
| `onEvent` | (`event`: `FilesystemEvent`) => `void` \| `Promise`\<`void`\> | callback to call when an event in the directory occurs. |
| `opts`? | `WatchOpts` | connection options. |

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

### write()

```ts
write(
   path: string, 
   data: string | ArrayBuffer | Blob | ReadableStream<any>, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to file. |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\> | data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

### name

```ts
name: string;
```

Name of the filesystem object.

### path

```ts
path: string;
```

Path to the filesystem object.

### type?

```ts
optional type: FileType;
```

Type of the filesystem object.

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

***

### WatchOpts

Options for watching a directory.

#### Properties

### onExit()?

```ts
optional onExit: (err?: Error) => void | Promise<void>;
```

Callback to call when the watch operation stops.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `err`? | `Error` |

###### Returns

`void` \| `Promise`\<`void`\>

### recursive?

```ts
optional recursive: boolean;
```

Watch the directory recursively

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `commands` | `readonly` | `Commands` | Module for running commands in the sandbox |
| `files` | `readonly` | `Filesystem` | Module for interacting with the sandbox filesystem |
| `pty` | `readonly` | `Pty` | Module for interacting with the sandbox pseudo-terminals |
| `sandboxId` | `readonly` | `string` | Unique identifier of the sandbox. |

#### Methods

### downloadUrl()

```ts
downloadUrl(path: string): string
```

Get the URL to download a file from the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file to download. |

###### Returns

`string`

URL for downloading file.

### getHost()

```ts
getHost(port: number): string
```

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `port` | `number` | number of the port in the sandbox. |

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
```

### isRunning()

```ts
isRunning(opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Check if the sandbox is running.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

### kill()

```ts
kill(opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Kill the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### setTimeout()

```ts
setTimeout(timeoutMs: number, opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### uploadUrl()

```ts
uploadUrl(path?: string): string
```

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path`? | `string` | the directory where to upload the file, defaults to user's home directory. |

###### Returns

`string`

URL for uploading file.

### connect()

```ts
static connect<S>(
   this: S, 
   sandboxId: string, 
opts?: Omit<SandboxOpts, "timeoutMs" | "metadata" | "envs">): Promise<InstanceType<S>>
```

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\> | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

### kill()

```ts
static kill(sandboxId: string, opts?: SandboxApiOpts): Promise<boolean>
```

Kill the sandbox specified by sandbox ID.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

### list()

```ts
static list(opts?: SandboxApiOpts): Promise<SandboxInfo[]>
```

List all running sandboxes.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

### setTimeout()

```ts
static setTimeout(
   sandboxId: string, 
   timeoutMs: number, 
opts?: SandboxApiOpts): Promise<void>
```

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

### accessToken?

```ts
optional accessToken: string;
```

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

### apiKey?

```ts
optional apiKey: string;
```

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

### debug?

```ts
optional debug: boolean;
```

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

### domain?

```ts
optional domain: string;
```

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

### logger?

```ts
optional logger: Logger;
```

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

### metadata?

```ts
optional metadata: Record<string, string>;
```

Custom metadata for the sandbox.

###### Default

```ts
{}
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```


### Commands

Module for starting and interacting with commands in the sandbox.

#### Constructors

```ts
new Commands(transport: Transport, connectionConfig: ConnectionConfig): Commands
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Commands`

#### Methods

### connect()

```ts
connect(pid: number, opts?: CommandConnectOpts): Promise<CommandHandle>
```

Connect to a running command.
You can use CommandHandle.wait to wait for the command to finish and get execution results.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command to connect to. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandConnectOpts` | connection options. |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### kill()

```ts
kill(pid: number, opts?: CommandRequestOpts): Promise<boolean>
```

Kill a running command specified by its process ID.
It uses `SIGKILL` signal to kill the command.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the command was killed, `false` if the command was not found.

### list()

```ts
list(opts?: CommandRequestOpts): Promise<ProcessInfo[]>
```

List all running commands and PTY sessions.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`ProcessInfo`[]\>

list of running commands and PTY sessions.

### run()

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandResult>
```

Start a new command and wait until it finishes executing.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command. |

###### Returns

`Promise`\<`CommandResult`\>

`CommandResult` result of the command execution.

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandHandle>
```

Start a new command in the background.
You can use CommandHandle.wait to wait for the command to finish and get its result.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### sendStdin()

```ts
sendStdin(
   pid: number, 
   data: string, 
opts?: CommandRequestOpts): Promise<void>
```

Send data to command stdin.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `data` | `string` | data to send to the command. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

***

### Pty

Module for interacting with PTYs (pseudo-terminals) in the sandbox.

#### Constructors

```ts
new Pty(transport: Transport, connectionConfig: ConnectionConfig): Pty
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Pty`

#### Methods

### create()

```ts
create(opts: PtyCreateOpts): Promise<CommandHandle>
```

Create a new PTY (pseudo-terminal).

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts` | `PtyCreateOpts` | options for creating the PTY. |

###### Returns

`Promise`\<`CommandHandle`\>

handle to interact with the PTY.

### kill()

```ts
kill(pid: number, opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Kill a running PTY specified by process ID.
It uses `SIGKILL` signal to kill the PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the PTY was killed, `false` if the PTY was not found.

### resize()

```ts
resize(
   pid: number, 
   size: object, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Resize PTY.
Call this when the terminal window is resized and the number of columns and rows has changed.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `size` | `object` | new size of the PTY. |
| `size.cols` | `number` | - |
| `size.rows`? | `number` | - |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### sendInput()

```ts
sendInput(
   pid: number, 
   data: Uint8Array, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Send input to a PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `data` | `Uint8Array` | input data to send to the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### CommandRequestOpts

Options for sending a command request.

#### Extended by

- `CommandStartOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### CommandStartOpts

Options for starting a new command.

#### Properties

### background?

```ts
optional background: boolean;
```

If true, starts command in the background and the method returns immediately.
You can use CommandHandle.wait to wait for the command to finish.

### cwd?

```ts
optional cwd: string;
```

Working directory for the command.

###### Default

```ts
// home directory of the user used to start the command
```

### envs?

```ts
optional envs: Record<string, string>;
```

Environment variables used for the command.

This overrides the default environment variables from `Sandbox` constructor.

###### Default

`{}`

### onStderr()?

```ts
optional onStderr: (data: string) => void | Promise<void>;
```

Callback for command stderr output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### onStdout()?

```ts
optional onStdout: (data: string) => void | Promise<void>;
```

Callback for command stdout output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the command in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to run the command as.

###### Default

`user`

***

### ProcessInfo

Information about a command, PTY session or start command running in the sandbox as process.

#### Properties

### args

```ts
args: string[];
```

Command arguments.

### cmd

```ts
cmd: string;
```

Command that was executed.

### cwd?

```ts
optional cwd: string;
```

Executed command working directory.

### envs

```ts
envs: Record<string, string>;
```

Environment variables used for the command.

### pid

```ts
pid: number;
```

Process ID.

### tag?

```ts
optional tag: string;
```

Custom tag used for identifying special commands like start command in the custom template.

## Type Aliases

### CommandConnectOpts

```ts
type CommandConnectOpts: Pick<CommandStartOpts, "onStderr" | "onStdout" | "timeoutMs"> & CommandRequestOpts;
```

Options for connecting to a command.


### AuthenticationError

Thrown when authentication fails.

#### Constructors

```ts
new AuthenticationError(message: any): AuthenticationError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`AuthenticationError`

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

```ts
new InvalidArgumentError(message: string): InvalidArgumentError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`InvalidArgumentError`

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

```ts
new NotEnoughSpaceError(message: string): NotEnoughSpaceError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotEnoughSpaceError`

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

```ts
new NotFoundError(message: string): NotFoundError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotFoundError`

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

```ts
new RateLimitError(message: any): RateLimitError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`RateLimitError`

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

```ts
new SandboxError(message: any): SandboxError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`SandboxError`

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

```ts
new TemplateError(message: string): TemplateError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TemplateError`

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

```ts
new TimeoutError(message: string): TimeoutError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TimeoutError`

## Functions

### formatSandboxTimeoutError()

```ts
function formatSandboxTimeoutError(message: string): TimeoutError
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

#### Returns

`TimeoutError`


### FileType

Sandbox filesystem object type.

#### Enumeration Members

| Enumeration Member | Value | Description |
| ------ | ------ | ------ |
| `DIR` | `"dir"` | Filesystem object is a directory. |
| `FILE` | `"file"` | Filesystem object is a file. |

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

```ts
new Filesystem(
   transport: Transport, 
   envdApi: EnvdApiClient, 
   connectionConfig: ConnectionConfig): Filesystem
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `envdApi` | `EnvdApiClient` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Filesystem`

#### Methods

### exists()

```ts
exists(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Check if a file or a directory exists.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or a directory |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

### list()

```ts
list(path: string, opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

List entries in a directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

### makeDir()

```ts
makeDir(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a new directory. For example '/dirA/dirB' when creating 'dirB'. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

### read()

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<string>
```

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`string`\>

file content as string

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Uint8Array>
```

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Blob>
```

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<ReadableStream<Uint8Array>>
```

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

### remove()

```ts
remove(path: string, opts?: FilesystemRequestOpts): Promise<void>
```

Remove a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

### rename()

```ts
rename(
   oldPath: string, 
   newPath: string, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Rename a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `oldPath` | `string` | path to the file or directory to rename. |
| `newPath` | `string` | new path for the file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

### watchDir()

```ts
watchDir(
   path: string, 
   onEvent: (event: FilesystemEvent) => void | Promise<void>, 
opts?: WatchOpts): Promise<WatchHandle>
```

Start watching a directory for filesystem events.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to directory to watch. |
| `onEvent` | (`event`: `FilesystemEvent`) => `void` \| `Promise`\<`void`\> | callback to call when an event in the directory occurs. |
| `opts`? | `WatchOpts` | connection options. |

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

### write()

```ts
write(
   path: string, 
   data: string | ArrayBuffer | Blob | ReadableStream<any>, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to file. |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\> | data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

### name

```ts
name: string;
```

Name of the filesystem object.

### path

```ts
path: string;
```

Path to the filesystem object.

### type?

```ts
optional type: FileType;
```

Type of the filesystem object.

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

***

### WatchOpts

Options for watching a directory.

#### Properties

### onExit()?

```ts
optional onExit: (err?: Error) => void | Promise<void>;
```

Callback to call when the watch operation stops.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `err`? | `Error` |

###### Returns

`void` \| `Promise`\<`void`\>

### recursive?

```ts
optional recursive: boolean;
```

Watch the directory recursively

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `commands` | `readonly` | `Commands` | Module for running commands in the sandbox |
| `files` | `readonly` | `Filesystem` | Module for interacting with the sandbox filesystem |
| `pty` | `readonly` | `Pty` | Module for interacting with the sandbox pseudo-terminals |
| `sandboxId` | `readonly` | `string` | Unique identifier of the sandbox. |

#### Methods

### downloadUrl()

```ts
downloadUrl(path: string): string
```

Get the URL to download a file from the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file to download. |

###### Returns

`string`

URL for downloading file.

### getHost()

```ts
getHost(port: number): string
```

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `port` | `number` | number of the port in the sandbox. |

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
```

### isRunning()

```ts
isRunning(opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Check if the sandbox is running.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

### kill()

```ts
kill(opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Kill the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### setTimeout()

```ts
setTimeout(timeoutMs: number, opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### uploadUrl()

```ts
uploadUrl(path?: string): string
```

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path`? | `string` | the directory where to upload the file, defaults to user's home directory. |

###### Returns

`string`

URL for uploading file.

### connect()

```ts
static connect<S>(
   this: S, 
   sandboxId: string, 
opts?: Omit<SandboxOpts, "timeoutMs" | "metadata" | "envs">): Promise<InstanceType<S>>
```

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\> | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

### kill()

```ts
static kill(sandboxId: string, opts?: SandboxApiOpts): Promise<boolean>
```

Kill the sandbox specified by sandbox ID.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

### list()

```ts
static list(opts?: SandboxApiOpts): Promise<SandboxInfo[]>
```

List all running sandboxes.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

### setTimeout()

```ts
static setTimeout(
   sandboxId: string, 
   timeoutMs: number, 
opts?: SandboxApiOpts): Promise<void>
```

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

### accessToken?

```ts
optional accessToken: string;
```

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

### apiKey?

```ts
optional apiKey: string;
```

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

### debug?

```ts
optional debug: boolean;
```

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

### domain?

```ts
optional domain: string;
```

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

### logger?

```ts
optional logger: Logger;
```

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

### metadata?

```ts
optional metadata: Record<string, string>;
```

Custom metadata for the sandbox.

###### Default

```ts
{}
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```


### Commands

Module for starting and interacting with commands in the sandbox.

#### Constructors

```ts
new Commands(transport: Transport, connectionConfig: ConnectionConfig): Commands
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Commands`

#### Methods

### connect()

```ts
connect(pid: number, opts?: CommandConnectOpts): Promise<CommandHandle>
```

Connect to a running command.
You can use CommandHandle.wait to wait for the command to finish and get execution results.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command to connect to. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandConnectOpts` | connection options. |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### kill()

```ts
kill(pid: number, opts?: CommandRequestOpts): Promise<boolean>
```

Kill a running command specified by its process ID.
It uses `SIGKILL` signal to kill the command.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the command was killed, `false` if the command was not found.

### list()

```ts
list(opts?: CommandRequestOpts): Promise<ProcessInfo[]>
```

List all running commands and PTY sessions.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`ProcessInfo`[]\>

list of running commands and PTY sessions.

### run()

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandResult>
```

Start a new command and wait until it finishes executing.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command. |

###### Returns

`Promise`\<`CommandResult`\>

`CommandResult` result of the command execution.

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandHandle>
```

Start a new command in the background.
You can use CommandHandle.wait to wait for the command to finish and get its result.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### sendStdin()

```ts
sendStdin(
   pid: number, 
   data: string, 
opts?: CommandRequestOpts): Promise<void>
```

Send data to command stdin.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `data` | `string` | data to send to the command. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

***

### Pty

Module for interacting with PTYs (pseudo-terminals) in the sandbox.

#### Constructors

```ts
new Pty(transport: Transport, connectionConfig: ConnectionConfig): Pty
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Pty`

#### Methods

### create()

```ts
create(opts: PtyCreateOpts): Promise<CommandHandle>
```

Create a new PTY (pseudo-terminal).

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts` | `PtyCreateOpts` | options for creating the PTY. |

###### Returns

`Promise`\<`CommandHandle`\>

handle to interact with the PTY.

### kill()

```ts
kill(pid: number, opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Kill a running PTY specified by process ID.
It uses `SIGKILL` signal to kill the PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the PTY was killed, `false` if the PTY was not found.

### resize()

```ts
resize(
   pid: number, 
   size: object, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Resize PTY.
Call this when the terminal window is resized and the number of columns and rows has changed.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `size` | `object` | new size of the PTY. |
| `size.cols` | `number` | - |
| `size.rows`? | `number` | - |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### sendInput()

```ts
sendInput(
   pid: number, 
   data: Uint8Array, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Send input to a PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `data` | `Uint8Array` | input data to send to the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### CommandRequestOpts

Options for sending a command request.

#### Extended by

- `CommandStartOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### CommandStartOpts

Options for starting a new command.

#### Properties

### background?

```ts
optional background: boolean;
```

If true, starts command in the background and the method returns immediately.
You can use CommandHandle.wait to wait for the command to finish.

### cwd?

```ts
optional cwd: string;
```

Working directory for the command.

###### Default

```ts
// home directory of the user used to start the command
```

### envs?

```ts
optional envs: Record<string, string>;
```

Environment variables used for the command.

This overrides the default environment variables from `Sandbox` constructor.

###### Default

`{}`

### onStderr()?

```ts
optional onStderr: (data: string) => void | Promise<void>;
```

Callback for command stderr output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### onStdout()?

```ts
optional onStdout: (data: string) => void | Promise<void>;
```

Callback for command stdout output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the command in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to run the command as.

###### Default

`user`

***

### ProcessInfo

Information about a command, PTY session or start command running in the sandbox as process.

#### Properties

### args

```ts
args: string[];
```

Command arguments.

### cmd

```ts
cmd: string;
```

Command that was executed.

### cwd?

```ts
optional cwd: string;
```

Executed command working directory.

### envs

```ts
envs: Record<string, string>;
```

Environment variables used for the command.

### pid

```ts
pid: number;
```

Process ID.

### tag?

```ts
optional tag: string;
```

Custom tag used for identifying special commands like start command in the custom template.

## Type Aliases

### CommandConnectOpts

```ts
type CommandConnectOpts: Pick<CommandStartOpts, "onStderr" | "onStdout" | "timeoutMs"> & CommandRequestOpts;
```

Options for connecting to a command.


### AuthenticationError

Thrown when authentication fails.

#### Constructors

```ts
new AuthenticationError(message: any): AuthenticationError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`AuthenticationError`

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

```ts
new InvalidArgumentError(message: string): InvalidArgumentError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`InvalidArgumentError`

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

```ts
new NotEnoughSpaceError(message: string): NotEnoughSpaceError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotEnoughSpaceError`

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

```ts
new NotFoundError(message: string): NotFoundError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotFoundError`

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

```ts
new RateLimitError(message: any): RateLimitError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`RateLimitError`

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

```ts
new SandboxError(message: any): SandboxError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`SandboxError`

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

```ts
new TemplateError(message: string): TemplateError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TemplateError`

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

```ts
new TimeoutError(message: string): TimeoutError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TimeoutError`

## Functions

### formatSandboxTimeoutError()

```ts
function formatSandboxTimeoutError(message: string): TimeoutError
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

#### Returns

`TimeoutError`


### FileType

Sandbox filesystem object type.

#### Enumeration Members

| Enumeration Member | Value | Description |
| ------ | ------ | ------ |
| `DIR` | `"dir"` | Filesystem object is a directory. |
| `FILE` | `"file"` | Filesystem object is a file. |

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

```ts
new Filesystem(
   transport: Transport, 
   envdApi: EnvdApiClient, 
   connectionConfig: ConnectionConfig): Filesystem
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `envdApi` | `EnvdApiClient` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Filesystem`

#### Methods

### exists()

```ts
exists(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Check if a file or a directory exists.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or a directory |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

### list()

```ts
list(path: string, opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

List entries in a directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

### makeDir()

```ts
makeDir(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a new directory. For example '/dirA/dirB' when creating 'dirB'. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

### read()

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<string>
```

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`string`\>

file content as string

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Uint8Array>
```

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Blob>
```

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<ReadableStream<Uint8Array>>
```

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

### remove()

```ts
remove(path: string, opts?: FilesystemRequestOpts): Promise<void>
```

Remove a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

### rename()

```ts
rename(
   oldPath: string, 
   newPath: string, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Rename a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `oldPath` | `string` | path to the file or directory to rename. |
| `newPath` | `string` | new path for the file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

### watchDir()

```ts
watchDir(
   path: string, 
   onEvent: (event: FilesystemEvent) => void | Promise<void>, 
opts?: WatchOpts & object): Promise<WatchHandle>
```

Start watching a directory for filesystem events.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to directory to watch. |
| `onEvent` | (`event`: `FilesystemEvent`) => `void` \| `Promise`\<`void`\> | callback to call when an event in the directory occurs. |
| `opts`? | `WatchOpts` & `object` | connection options. |

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

### write()

###### write(path, data, opts)

```ts
write(
   path: string, 
   data: string | ArrayBuffer | Blob | ReadableStream<any>, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to file. |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\> | data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### write(files, opts)

```ts
write(files: WriteEntry[], opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `files` | `WriteEntry`[] |
| `opts`? | `FilesystemRequestOpts` |

###### Returns

`Promise`\<`EntryInfo`[]\>

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

### name

```ts
name: string;
```

Name of the filesystem object.

### path

```ts
path: string;
```

Path to the filesystem object.

### type?

```ts
optional type: FileType;
```

Type of the filesystem object.

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

***

### WatchOpts

Options for watching a directory.

#### Properties

### onExit()?

```ts
optional onExit: (err?: Error) => void | Promise<void>;
```

Callback to call when the watch operation stops.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `err`? | `Error` |

###### Returns

`void` \| `Promise`\<`void`\>

### recursive?

```ts
optional recursive: boolean;
```

Watch the directory recursively

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

## Type Aliases

### WriteEntry

```ts
type WriteEntry: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream` |
| `path` | `string` |


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `commands` | `readonly` | `Commands` | Module for running commands in the sandbox |
| `files` | `readonly` | `Filesystem` | Module for interacting with the sandbox filesystem |
| `pty` | `readonly` | `Pty` | Module for interacting with the sandbox pseudo-terminals |
| `sandboxId` | `readonly` | `string` | Unique identifier of the sandbox. |

#### Methods

### downloadUrl()

```ts
downloadUrl(path: string): string
```

Get the URL to download a file from the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file to download. |

###### Returns

`string`

URL for downloading file.

### getHost()

```ts
getHost(port: number): string
```

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `port` | `number` | number of the port in the sandbox. |

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
```

### isRunning()

```ts
isRunning(opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Check if the sandbox is running.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

### kill()

```ts
kill(opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Kill the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### setTimeout()

```ts
setTimeout(timeoutMs: number, opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### uploadUrl()

```ts
uploadUrl(path?: string): string
```

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path`? | `string` | the directory where to upload the file, defaults to user's home directory. |

###### Returns

`string`

URL for uploading file.

### connect()

```ts
static connect<S>(
   this: S, 
   sandboxId: string, 
opts?: Omit<SandboxOpts, "timeoutMs" | "metadata" | "envs">): Promise<InstanceType<S>>
```

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\> | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

### kill()

```ts
static kill(sandboxId: string, opts?: SandboxApiOpts): Promise<boolean>
```

Kill the sandbox specified by sandbox ID.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

### list()

```ts
static list(opts?: SandboxApiOpts): Promise<SandboxInfo[]>
```

List all running sandboxes.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

### setTimeout()

```ts
static setTimeout(
   sandboxId: string, 
   timeoutMs: number, 
opts?: SandboxApiOpts): Promise<void>
```

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

### accessToken?

```ts
optional accessToken: string;
```

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

### apiKey?

```ts
optional apiKey: string;
```

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

### debug?

```ts
optional debug: boolean;
```

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

### domain?

```ts
optional domain: string;
```

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

### logger?

```ts
optional logger: Logger;
```

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

### metadata?

```ts
optional metadata: Record<string, string>;
```

Custom metadata for the sandbox.

###### Default

```ts
{}
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```


### Commands

Module for starting and interacting with commands in the sandbox.

#### Constructors

```ts
new Commands(transport: Transport, connectionConfig: ConnectionConfig): Commands
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Commands`

#### Methods

### connect()

```ts
connect(pid: number, opts?: CommandConnectOpts): Promise<CommandHandle>
```

Connect to a running command.
You can use CommandHandle.wait to wait for the command to finish and get execution results.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command to connect to. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandConnectOpts` | connection options. |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### kill()

```ts
kill(pid: number, opts?: CommandRequestOpts): Promise<boolean>
```

Kill a running command specified by its process ID.
It uses `SIGKILL` signal to kill the command.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the command was killed, `false` if the command was not found.

### list()

```ts
list(opts?: CommandRequestOpts): Promise<ProcessInfo[]>
```

List all running commands and PTY sessions.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`ProcessInfo`[]\>

list of running commands and PTY sessions.

### run()

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandResult>
```

Start a new command and wait until it finishes executing.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command. |

###### Returns

`Promise`\<`CommandResult`\>

`CommandResult` result of the command execution.

###### run(cmd, opts)

```ts
run(cmd: string, opts?: CommandStartOpts & object): Promise<CommandHandle>
```

Start a new command in the background.
You can use CommandHandle.wait to wait for the command to finish and get its result.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `cmd` | `string` | command to execute. |
| `opts`? | `CommandStartOpts` & `object` | options for starting the command |

###### Returns

`Promise`\<`CommandHandle`\>

`CommandHandle` handle to interact with the running command.

### sendStdin()

```ts
sendStdin(
   pid: number, 
   data: string, 
opts?: CommandRequestOpts): Promise<void>
```

Send data to command stdin.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the command. You can get the list of running commands using Commands.list. |
| `data` | `string` | data to send to the command. |
| `opts`? | `CommandRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

***

### Pty

Module for interacting with PTYs (pseudo-terminals) in the sandbox.

#### Constructors

```ts
new Pty(transport: Transport, connectionConfig: ConnectionConfig): Pty
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Pty`

#### Methods

### create()

```ts
create(opts: PtyCreateOpts): Promise<CommandHandle>
```

Create a new PTY (pseudo-terminal).

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts` | `PtyCreateOpts` | options for creating the PTY. |

###### Returns

`Promise`\<`CommandHandle`\>

handle to interact with the PTY.

### kill()

```ts
kill(pid: number, opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Kill a running PTY specified by process ID.
It uses `SIGKILL` signal to kill the PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the PTY was killed, `false` if the PTY was not found.

### resize()

```ts
resize(
   pid: number, 
   size: object, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Resize PTY.
Call this when the terminal window is resized and the number of columns and rows has changed.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `size` | `object` | new size of the PTY. |
| `size.cols` | `number` | - |
| `size.rows`? | `number` | - |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### sendInput()

```ts
sendInput(
   pid: number, 
   data: Uint8Array, 
opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<void>
```

Send input to a PTY.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pid` | `number` | process ID of the PTY. |
| `data` | `Uint8Array` | input data to send to the PTY. |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### CommandRequestOpts

Options for sending a command request.

#### Extended by

- `CommandStartOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

***

### CommandStartOpts

Options for starting a new command.

#### Properties

### background?

```ts
optional background: boolean;
```

If true, starts command in the background and the method returns immediately.
You can use CommandHandle.wait to wait for the command to finish.

### cwd?

```ts
optional cwd: string;
```

Working directory for the command.

###### Default

```ts
// home directory of the user used to start the command
```

### envs?

```ts
optional envs: Record<string, string>;
```

Environment variables used for the command.

This overrides the default environment variables from `Sandbox` constructor.

###### Default

`{}`

### onStderr()?

```ts
optional onStderr: (data: string) => void | Promise<void>;
```

Callback for command stderr output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### onStdout()?

```ts
optional onStdout: (data: string) => void | Promise<void>;
```

Callback for command stdout output.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `data` | `string` |

###### Returns

`void` \| `Promise`\<`void`\>

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the command in **milliseconds**.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to run the command as.

###### Default

`user`

***

### ProcessInfo

Information about a command, PTY session or start command running in the sandbox as process.

#### Properties

### args

```ts
args: string[];
```

Command arguments.

### cmd

```ts
cmd: string;
```

Command that was executed.

### cwd?

```ts
optional cwd: string;
```

Executed command working directory.

### envs

```ts
envs: Record<string, string>;
```

Environment variables used for the command.

### pid

```ts
pid: number;
```

Process ID.

### tag?

```ts
optional tag: string;
```

Custom tag used for identifying special commands like start command in the custom template.

## Type Aliases

### CommandConnectOpts

```ts
type CommandConnectOpts: Pick<CommandStartOpts, "onStderr" | "onStdout" | "timeoutMs"> & CommandRequestOpts;
```

Options for connecting to a command.


### AuthenticationError

Thrown when authentication fails.

#### Constructors

```ts
new AuthenticationError(message: any): AuthenticationError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`AuthenticationError`

***

### InvalidArgumentError

Thrown when an invalid argument is provided.

#### Constructors

```ts
new InvalidArgumentError(message: string): InvalidArgumentError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`InvalidArgumentError`

***

### NotEnoughSpaceError

Thrown when there is not enough disk space.

#### Constructors

```ts
new NotEnoughSpaceError(message: string): NotEnoughSpaceError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotEnoughSpaceError`

***

### NotFoundError

Thrown when a resource is not found.

#### Constructors

```ts
new NotFoundError(message: string): NotFoundError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`NotFoundError`

***

### RateLimitError

Thrown when the API rate limit is exceeded.

#### Constructors

```ts
new RateLimitError(message: any): RateLimitError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`RateLimitError`

***

### SandboxError

Base class for all sandbox errors.

Thrown when general sandbox errors occur.

#### Extended by

- `TimeoutError`
- `InvalidArgumentError`
- `NotEnoughSpaceError`
- `NotFoundError`
- `AuthenticationError`
- `TemplateError`
- `RateLimitError`

#### Constructors

```ts
new SandboxError(message: any): SandboxError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `any` |

###### Returns

`SandboxError`

***

### TemplateError

Thrown when the template uses old envd version. It isn't compatible with the new SDK.

#### Constructors

```ts
new TemplateError(message: string): TemplateError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TemplateError`

***

### TimeoutError

Thrown when a timeout error occurs.

The [unavailable] error type is caused by sandbox timeout.

The [canceled] error type is caused by exceeding request timeout.

The [deadline_exceeded] error type is caused by exceeding the timeout for command execution, watch, etc.

The [unknown] error type is sometimes caused by the sandbox timeout when the request is not processed correctly.

#### Constructors

```ts
new TimeoutError(message: string): TimeoutError
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

###### Returns

`TimeoutError`

## Functions

### formatSandboxTimeoutError()

```ts
function formatSandboxTimeoutError(message: string): TimeoutError
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `message` | `string` |

#### Returns

`TimeoutError`


### FileType

Sandbox filesystem object type.

#### Enumeration Members

| Enumeration Member | Value | Description |
| ------ | ------ | ------ |
| `DIR` | `"dir"` | Filesystem object is a directory. |
| `FILE` | `"file"` | Filesystem object is a file. |

## Classes

### Filesystem

Module for interacting with the sandbox filesystem.

#### Constructors

```ts
new Filesystem(
   transport: Transport, 
   envdApi: EnvdApiClient, 
   connectionConfig: ConnectionConfig): Filesystem
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `transport` | `Transport` |
| `envdApi` | `EnvdApiClient` |
| `connectionConfig` | `ConnectionConfig` |

###### Returns

`Filesystem`

#### Methods

### exists()

```ts
exists(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Check if a file or a directory exists.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or a directory |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the file or directory exists, `false` otherwise

### list()

```ts
list(path: string, opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

List entries in a directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`[]\>

list of entries in the sandbox filesystem directory.

### makeDir()

```ts
makeDir(path: string, opts?: FilesystemRequestOpts): Promise<boolean>
```

Create a new directory and all directories along the way if needed on the specified path.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a new directory. For example '/dirA/dirB' when creating 'dirB'. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the directory was created, `false` if it already exists.

### read()

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<string>
```

Read file content as a `string`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`string`\>

file content as string

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Uint8Array>
```

Read file content as a `Uint8Array`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Uint8Array`\>

file content as `Uint8Array`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<Blob>
```

Read file content as a `Blob`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`Blob`\>

file content as `Blob`

###### read(path, opts)

```ts
read(path: string, opts?: FilesystemRequestOpts & object): Promise<ReadableStream<Uint8Array>>
```

Read file content as a `ReadableStream`.

You can pass `text`, `bytes`, `blob`, or `stream` to `opts.format` to change the return type.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file. |
| `opts`? | `FilesystemRequestOpts` & `object` | connection options. |

###### Returns

`Promise`\<`ReadableStream`\<`Uint8Array`\>\>

file content as `ReadableStream`

### remove()

```ts
remove(path: string, opts?: FilesystemRequestOpts): Promise<void>
```

Remove a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to a file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

### rename()

```ts
rename(
   oldPath: string, 
   newPath: string, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Rename a file or directory.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `oldPath` | `string` | path to the file or directory to rename. |
| `newPath` | `string` | new path for the file or directory. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about renamed file or directory.

### watchDir()

```ts
watchDir(
   path: string, 
   onEvent: (event: FilesystemEvent) => void | Promise<void>, 
opts?: WatchOpts & object): Promise<WatchHandle>
```

Start watching a directory for filesystem events.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to directory to watch. |
| `onEvent` | (`event`: `FilesystemEvent`) => `void` \| `Promise`\<`void`\> | callback to call when an event in the directory occurs. |
| `opts`? | `WatchOpts` & `object` | connection options. |

###### Returns

`Promise`\<`WatchHandle`\>

`WatchHandle` object for stopping watching directory.

### write()

###### write(path, data, opts)

```ts
write(
   path: string, 
   data: string | ArrayBuffer | Blob | ReadableStream<any>, 
opts?: FilesystemRequestOpts): Promise<EntryInfo>
```

Write content to a file.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to file. |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream`\<`any`\> | data to write to the file. Data can be a string, `ArrayBuffer`, `Blob`, or `ReadableStream`. |
| `opts`? | `FilesystemRequestOpts` | connection options. |

###### Returns

`Promise`\<`EntryInfo`\>

information about the written file

###### write(files, opts)

```ts
write(files: WriteEntry[], opts?: FilesystemRequestOpts): Promise<EntryInfo[]>
```

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `files` | `WriteEntry`[] |
| `opts`? | `FilesystemRequestOpts` |

###### Returns

`Promise`\<`EntryInfo`[]\>

## Interfaces

### EntryInfo

Sandbox filesystem object information.

#### Properties

### name

```ts
name: string;
```

Name of the filesystem object.

### path

```ts
path: string;
```

Path to the filesystem object.

### type?

```ts
optional type: FileType;
```

Type of the filesystem object.

***

### FilesystemRequestOpts

Options for the sandbox filesystem operations.

#### Extended by

- `WatchOpts`

#### Properties

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

***

### WatchOpts

Options for watching a directory.

#### Properties

### onExit()?

```ts
optional onExit: (err?: Error) => void | Promise<void>;
```

Callback to call when the watch operation stops.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `err`? | `Error` |

###### Returns

`void` \| `Promise`\<`void`\>

### recursive?

```ts
optional recursive: boolean;
```

Watch the directory recursively

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the watch operation in **milliseconds**.
You can pass `0` to disable the timeout.

###### Default

```ts
60_000 // 60 seconds
```

### user?

```ts
optional user: Username;
```

User to use for the operation in the sandbox.
This affects the resolution of relative paths and ownership of the created filesystem objects.

## Type Aliases

### WriteEntry

```ts
type WriteEntry: object;
```

#### Type declaration

| Name | Type |
| ------ | ------ |
| `data` | `string` \| `ArrayBuffer` \| `Blob` \| `ReadableStream` |
| `path` | `string` |


### Sandbox

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs here.

Use Sandbox.create to create a new sandbox.

#### Example

```ts
import { Sandbox } from 'e2b'

const sandbox = await Sandbox.create()
```

#### Properties

| Property | Modifier | Type | Description |
| ------ | ------ | ------ | ------ |
| `commands` | `readonly` | `Commands` | Module for running commands in the sandbox |
| `files` | `readonly` | `Filesystem` | Module for interacting with the sandbox filesystem |
| `pty` | `readonly` | `Pty` | Module for interacting with the sandbox pseudo-terminals |
| `sandboxId` | `readonly` | `string` | Unique identifier of the sandbox. |

#### Methods

### downloadUrl()

```ts
downloadUrl(path: string): string
```

Get the URL to download a file from the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path` | `string` | path to the file to download. |

###### Returns

`string`

URL for downloading file.

### getHost()

```ts
getHost(port: number): string
```

Get the host address for the specified sandbox port.
You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `port` | `number` | number of the port in the sandbox. |

###### Returns

`string`

host address of the sandbox port.

###### Example

```ts
const sandbox = await Sandbox.create()
// Start an HTTP server
await sandbox.commands.exec('python3 -m http.server 3000')
// Get the hostname of the HTTP server
const serverURL = sandbox.getHost(3000)
```

### isRunning()

```ts
isRunning(opts?: Pick<ConnectionOpts, "requestTimeoutMs">): Promise<boolean>
```

Check if the sandbox is running.

###### Parameters

| Parameter | Type |
| ------ | ------ |
| `opts`? | `Pick`\<`ConnectionOpts`, `"requestTimeoutMs"`\> |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox is running, `false` otherwise.

###### Example

```ts
const sandbox = await Sandbox.create()
await sandbox.isRunning() // Returns true

await sandbox.kill()
await sandbox.isRunning() // Returns false
```

### kill()

```ts
kill(opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Kill the sandbox.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### setTimeout()

```ts
setTimeout(timeoutMs: number, opts?: Pick<SandboxOpts, "requestTimeoutMs">): Promise<void>
```

Set the timeout of the sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `Pick`\<`SandboxOpts`, `"requestTimeoutMs"`\> | connection options. |

###### Returns

`Promise`\<`void`\>

### uploadUrl()

```ts
uploadUrl(path?: string): string
```

Get the URL to upload a file to the sandbox.

You have to send a POST request to this URL with the file as multipart/form-data.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `path`? | `string` | the directory where to upload the file, defaults to user's home directory. |

###### Returns

`string`

URL for uploading file.

### connect()

```ts
static connect<S>(
   this: S, 
   sandboxId: string, 
opts?: Omit<SandboxOpts, "timeoutMs" | "metadata" | "envs">): Promise<InstanceType<S>>
```

Connect to an existing sandbox.
With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `Omit`\<`SandboxOpts`, `"timeoutMs"` \| `"metadata"` \| `"envs"`\> | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the existing sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
const sandboxId = sandbox.sandboxId

// Connect to the same sandbox.
const sameSandbox = await Sandbox.connect(sandboxId)
```

### create()

###### create(this, opts)

```ts
static create<S>(this: S, opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the default `base` sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create()
```

###### Constructs

Sandbox

###### create(this, template, opts)

```ts
static create<S>(
   this: S, 
   template: string, 
opts?: SandboxOpts): Promise<InstanceType<S>>
```

Create a new sandbox from the specified sandbox template.

###### Type Parameters

| Type Parameter |
| ------ |
| `S` *extends* *typeof* `Sandbox` |

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `this` | `S` | - |
| `template` | `string` | sandbox template name or ID. |
| `opts`? | `SandboxOpts` | connection options. |

###### Returns

`Promise`\<`InstanceType`\<`S`\>\>

sandbox instance for the new sandbox.

###### Example

```ts
const sandbox = await Sandbox.create('<template-name-or-id>')
```

###### Constructs

Sandbox

### kill()

```ts
static kill(sandboxId: string, opts?: SandboxApiOpts): Promise<boolean>
```

Kill the sandbox specified by sandbox ID.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`boolean`\>

`true` if the sandbox was found and killed, `false` otherwise.

### list()

```ts
static list(opts?: SandboxListOpts): Promise<SandboxInfo[]>
```

List all running sandboxes.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `opts`? | `SandboxListOpts` | connection options. |

###### Returns

`Promise`\<`SandboxInfo`[]\>

list of running sandboxes.

### setTimeout()

```ts
static setTimeout(
   sandboxId: string, 
   timeoutMs: number, 
opts?: SandboxApiOpts): Promise<void>
```

Set the timeout of the specified sandbox.
After the timeout expires the sandbox will be automatically killed.

This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to Sandbox.setTimeout.

Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `sandboxId` | `string` | sandbox ID. |
| `timeoutMs` | `number` | timeout in **milliseconds**. |
| `opts`? | `SandboxApiOpts` | connection options. |

###### Returns

`Promise`\<`void`\>

## Interfaces

### SandboxOpts

Options for creating a new Sandbox.

#### Properties

### accessToken?

```ts
optional accessToken: string;
```

E2B access token to use for authentication.

###### Default

```ts
E2B_ACCESS_TOKEN // environment variable
```

### apiKey?

```ts
optional apiKey: string;
```

E2B API key to use for authentication.

###### Default

```ts
E2B_API_KEY // environment variable
```

### debug?

```ts
optional debug: boolean;
```

**`Internal`**

If true the SDK starts in the debug mode and connects to the local envd API server.

###### Default

E2B_DEBUG // environment variable or `false`

### domain?

```ts
optional domain: string;
```

Domain to use for the API.

###### Default

E2B_DOMAIN // environment variable or `e2b.dev`

### envs?

```ts
optional envs: Record<string, string>;
```

Custom environment variables for the sandbox.

Used when executing commands and code in the sandbox.
Can be overridden with the `envs` argument when executing commands or code.

###### Default

```ts
{}
```

### logger?

```ts
optional logger: Logger;
```

Logger to use for logging messages. It can accept any object that implements `Logger` interface—for example, console.

### metadata?

```ts
optional metadata: Record<string, string>;
```

Custom metadata for the sandbox.

###### Default

```ts
{}
```

### requestTimeoutMs?

```ts
optional requestTimeoutMs: number;
```

Timeout for requests to the API in **milliseconds**.

###### Default

```ts
30_000 // 30 seconds
```

### timeoutMs?

```ts
optional timeoutMs: number;
```

Timeout for the sandbox in **milliseconds**.
Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.

###### Default

```ts
300_000 // 5 minutes
```


# SDK Reference

This is the SDK reference for the [E2B CLI & Core SDK](https://github.com/e2b-dev/e2b), [Code Interpreter SDK](https://github.com/e2b-dev/code-interpreter), and [Desktop Sandbox SDK](https://github.com/e2b-dev/desktop).

The reference is intended to be limited to low-level descriptions of various programmatic functionality. If you’re just getting started with E2B, we would instead recommend looking at the [documentation](/docs) first or to get started quickly with an example.





## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes






## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


#### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


#### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


#### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


#### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


#### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


#### stop

```python
async def stop()
```

Stop watching the directory.




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


#### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


#### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### stdout

```python
@property
def stdout()
```

Command stdout output.


#### stderr

```python
@property
def stderr()
```

Command stderr output.


#### error

```python
@property
def error()
```

Command execution error message.


#### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


#### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


#### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


#### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


#### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


#### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


#### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


#### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


#### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


#### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


#### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


#### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


#### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.






## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


#### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### stdout

```python
@property
def stdout()
```

Command stdout output.


#### stderr

```python
@property
def stderr()
```

Command stderr output.


#### error

```python
@property
def error()
```

Command execution error message.


#### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


#### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


#### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


#### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


#### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


#### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


#### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


#### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


#### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


#### stop

```python
async def stop()
```

Stop watching the directory.






## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


#### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


#### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


#### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


#### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


#### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


#### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


#### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


#### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


#### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


#### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.






## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


#### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### stdout

```python
@property
def stdout()
```

Command stdout output.


#### stderr

```python
@property
def stderr()
```

Command stderr output.


#### error

```python
@property
def error()
```

Command execution error message.


#### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


#### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


#### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


#### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


#### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


#### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


#### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


#### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


#### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


#### stop

```python
async def stop()
```

Stop watching the directory.






## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


#### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


#### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



#### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


#### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


#### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


#### pid

```python
@property
def pid()
```

Command process ID.


#### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


#### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


#### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


#### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


#### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


#### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


#### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


#### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


#### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


#### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


#### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


#### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


#### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


#### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


#### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


#### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


#### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


#### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


#### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


#### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


#### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


#### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


#### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


#### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


#### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


#### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


#### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


#### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes






## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.








## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes






## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.








## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes






## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60,
                    recursive: bool = False) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time
- `recursive`: Watch directory recursively

**Returns**:

`AsyncWatchHandle` object for stopping watching directory






## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**






## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None,
              recursive: bool = False) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `recursive`: Watch directory recursively

**Returns**:

`WatchHandle` object for stopping watching directory




## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)
```


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The [unavailable] exception type is caused by sandbox timeout.

The [canceled] exception type is caused by exceeding request timeout.

The [deadline_exceeded] exception type is caused by exceeding the timeout for process, watch, etc.

The [unknown] exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.






## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60,
                    recursive: bool = False) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time
- `recursive`: Watch directory recursively

**Returns**:

`AsyncWatchHandle` object for stopping watching directory




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes








## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)
```


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None,
              recursive: bool = False) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `recursive`: Watch directory recursively

**Returns**:

`WatchHandle` object for stopping watching directory




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The `unavailable` exception type is caused by sandbox timeout.

The `canceled` exception type is caused by exceeding request timeout.

The `deadline_exceeded` exception type is caused by exceeding the timeout for process, watch, etc.

The `unknown` exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.








## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
@overload
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### write

```python
@overload
async def write(files: List[WriteEntry],
                user: Optional[Username] = "user",
                request_timeout: Optional[float] = None) -> List[EntryInfo]
```

Writes multiple files.

**Arguments**:

- `files`: list of files to write
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

Information about the written files


### write

```python
async def write(
    path_or_files: Union[str, List[WriteEntry]],
    data_or_user: Union[str, bytes, IO, Username] = "user",
    user_or_request_timeout: Optional[Union[float, Username]] = None,
    request_timeout_or_none: Optional[float] = None
) -> Union[EntryInfo, List[EntryInfo]]
```

Writes content to a file on the path.
When writing to a file that doesn't exist, the file will get created.
When writing to a file that already exists, the file will get overwritten.
When writing to a file that's in a directory that doesn't exist, you'll get an error.


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60,
                    recursive: bool = False) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time
- `recursive`: Watch directory recursively

**Returns**:

`AsyncWatchHandle` object for stopping watching directory






## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of sandbox info




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)
```


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
@overload
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### write

```python
@overload
def write(files: List[WriteEntry],
          user: Optional[Username] = "user",
          request_timeout: Optional[float] = None) -> List[EntryInfo]
```

Writes a list of files to the filesystem.

When writing to a file that doesn't exist, the file will get created.
When writing to a file that already exists, the file will get overwritten.
When writing to a file that's in a directory that doesn't exist, you'll get an error.

**Arguments**:

- `files`: list of files to write
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

Information about the written files


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None,
              recursive: bool = False) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `recursive`: Watch directory recursively

**Returns**:

`WatchHandle` object for stopping watching directory






## SandboxException

```python
class SandboxException(Exception)
```

Base class for all sandbox errors.

Raised when a general sandbox exception occurs.


## TimeoutException

```python
class TimeoutException(SandboxException)
```

Raised when a timeout occurs.

The `unavailable` exception type is caused by sandbox timeout.

The `canceled` exception type is caused by exceeding request timeout.

The `deadline_exceeded` exception type is caused by exceeding the timeout for process, watch, etc.

The `unknown` exception type is sometimes caused by the sandbox timeout when the request is not processed correctly.


## InvalidArgumentException

```python
class InvalidArgumentException(SandboxException)
```

Raised when an invalid argument is provided.


## NotEnoughSpaceException

```python
class NotEnoughSpaceException(SandboxException)
```

Raised when there is not enough disk space.


## NotFoundException

```python
class NotFoundException(SandboxException)
```

Raised when a resource is not found.


## AuthenticationException

```python
class AuthenticationException(SandboxException)
```

Raised when authentication fails.


## TemplateException

```python
class TemplateException(SandboxException)
```

Exception raised when the template uses old envd version. It isn't compatible with the new SDK.


## RateLimitException

```python
class RateLimitException(SandboxException)
```

Raised when the API rate limit is exceeded.








## AsyncCommandHandle

```python
class AsyncCommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### stdout

```python
@property
def stdout()
```

Command stdout output.


### stderr

```python
@property
def stderr()
```

Command stderr output.


### error

```python
@property
def error()
```

Command execution error message.


### exit\_code

```python
@property
def exit_code()
```

Command execution exit code.

`0` if the command finished successfully.

It is `None` if the command is still running.


### disconnect

```python
async def disconnect() -> None
```

Disconnects from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
async def wait() -> CommandResult
```

Wait for the command to finish and return the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Returns**:

`CommandResult` result of command execution


### kill

```python
async def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command

**Returns**:

`True` if the command was killed successfully, `False` if the command was not found




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: bytes,
                     request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
async def create(
        size: PtySize,
        on_data: OutputHandler[PtyOutput],
        user: Username = "user",
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `on_data`: Callback to handle PTY data
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
async def resize(pid: int,
                 size: PtySize,
                 request_timeout: Optional[float] = None)
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
async def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
async def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
async def send_stdin(pid: int,
                     data: str,
                     request_timeout: Optional[float] = None) -> None
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
async def run(cmd: str,
              background: Union[Literal[False], None] = None,
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
async def run(cmd: str,
              background: Literal[True],
              envs: Optional[Dict[str, str]] = None,
              user: Username = "user",
              cwd: Optional[str] = None,
              on_stdout: Optional[OutputHandler[Stdout]] = None,
              on_stderr: Optional[OutputHandler[Stderr]] = None,
              timeout: Optional[float] = 60,
              request_timeout: Optional[float] = None) -> AsyncCommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`AsyncCommandHandle` handle to interact with the running command


### connect

```python
async def connect(
        pid: int,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None,
        on_stdout: Optional[OutputHandler[Stdout]] = None,
        on_stderr: Optional[OutputHandler[Stderr]] = None
) -> AsyncCommandHandle
```

Connects to a running command.

You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Request timeout in **seconds**
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output

**Returns**:

`AsyncCommandHandle` handle to interact with the running command




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
async def list(cls,
               api_key: Optional[str] = None,
               query: Optional[SandboxQuery] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `query`: Filter the list of sandboxes, e.g. by metadata `SandboxQuery(metadata={"key": "value"})`, if there are multiple filters they are combined with AND.
- `domain`: Domain to use for the request, only relevant for self-hosted environments
- `debug`: Enable debug mode, all requested are then sent to localhost
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## AsyncSandbox

```python
class AsyncSandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `AsyncSandbox.create()` to create a new sandbox.

**Example**:

```python
from e2b import AsyncSandbox

sandbox = await AsyncSandbox.create()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox.


### \_\_init\_\_

```python
def __init__(**opts: Unpack[AsyncSandboxOpts])
```

Use `AsyncSandbox.create()` to create a new sandbox instead.


### is\_running

```python
async def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = await AsyncSandbox.create()
await sandbox.is_running() # Returns True

await sandbox.kill()
await sandbox.is_running() # Returns False
```


### create

```python
@classmethod
async def create(cls,
                 template: Optional[str] = None,
                 timeout: Optional[int] = None,
                 metadata: Optional[Dict[str, str]] = None,
                 envs: Optional[Dict[str, str]] = None,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None,
                 debug: Optional[bool] = None,
                 request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox
Use this method instead of using the constructor to create a new sandbox.


### connect

```python
@classmethod
async def connect(cls,
                  sandbox_id: str,
                  api_key: Optional[str] = None,
                  domain: Optional[str] = None,
                  debug: Optional[bool] = None)
```

Connect to an existing sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = await AsyncSandbox.create()
sandbox_id = sandbox.sandbox_id

same_sandbox = await AsyncSandbox.connect(sandbox_id)


### kill

```python
@overload
async def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
async def kill(sandbox_id: str,
               api_key: Optional[str] = None,
               domain: Optional[str] = None,
               debug: Optional[bool] = None,
               request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
async def set_timeout(timeout: int,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
async def set_timeout(sandbox_id: str,
                      timeout: int,
                      api_key: Optional[str] = None,
                      domain: Optional[str] = None,
                      debug: Optional[bool] = None,
                      request_timeout: Optional[float] = None) -> None
```

Set the timeout of the specified sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**




## AsyncWatchHandle

```python
class AsyncWatchHandle()
```

Handle for watching a directory in the sandbox filesystem.

Use `.stop()` to stop watching the directory.


### stop

```python
async def stop()
```

Stop watching the directory.




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
async def read(path: str,
               format: Literal["text"] = "text",
               user: Username = "user",
               request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
async def read(path: str,
               format: Literal["bytes"],
               user: Username = "user",
               request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
async def read(
        path: str,
        format: Literal["stream"],
        user: Username = "user",
        request_timeout: Optional[float] = None) -> AsyncIterator[bytes]
```

Read file content as a `AsyncIterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `AsyncIterator[bytes]`


### write

```python
@overload
async def write(path: str,
                data: Union[str, bytes, IO],
                user: Username = "user",
                request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### write

```python
@overload
async def write(files: List[WriteEntry],
                user: Optional[Username] = "user",
                request_timeout: Optional[float] = None) -> List[EntryInfo]
```

Writes multiple files.

**Arguments**:

- `files`: list of files to write
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

Information about the written files


### write

```python
async def write(
    path_or_files: Union[str, List[WriteEntry]],
    data_or_user: Union[str, bytes, IO, Username] = "user",
    user_or_request_timeout: Optional[Union[float, Username]] = None,
    request_timeout_or_none: Optional[float] = None
) -> Union[EntryInfo, List[EntryInfo]]
```

Writes content to a file on the path.
When writing to a file that doesn't exist, the file will get created.
When writing to a file that already exists, the file will get overwritten.
When writing to a file that's in a directory that doesn't exist, you'll get an error.


### list

```python
async def list(path: str,
               user: Username = "user",
               request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
async def exists(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
async def remove(path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
async def rename(old_path: str,
                 new_path: str,
                 user: Username = "user",
                 request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
async def make_dir(path: str,
                   user: Username = "user",
                   request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
async def watch_dir(path: str,
                    on_event: OutputHandler[FilesystemEvent],
                    on_exit: Optional[OutputHandler[Exception]] = None,
                    user: Username = "user",
                    request_timeout: Optional[float] = None,
                    timeout: Optional[float] = 60,
                    recursive: bool = False) -> AsyncWatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `on_event`: Callback to call on each event in the directory
- `on_exit`: Callback to call when the watching ends
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `timeout`: Timeout for the watch operation in **seconds**. Using `0` will not limit the watch time
- `recursive`: Watch directory recursively

**Returns**:

`AsyncWatchHandle` object for stopping watching directory






## CommandHandle

```python
class CommandHandle()
```

Command execution handle.

It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.


### pid

```python
@property
def pid()
```

Command process ID.


### \_\_iter\_\_

```python
def __iter__()
```

Iterate over the command output.

**Returns**:

Generator of command outputs


### disconnect

```python
def disconnect() -> None
```

Disconnect from the command.

The command is not killed, but SDK stops receiving events from the command.
You can reconnect to the command using `sandbox.commands.connect` method.


### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> CommandResult
```

Wait for the command to finish and returns the result.

If the command exits with a non-zero exit code, it throws a `CommandExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

`CommandResult` result of command execution


### kill

```python
def kill() -> bool
```

Kills the command.

It uses `SIGKILL` signal to kill the command.

**Returns**:

Whether the command was killed successfully




## Pty

```python
class Pty()
```

Module for interacting with PTYs (pseudo-terminals) in the sandbox.


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kill PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`true` if the PTY was killed, `false` if the PTY was not found


### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Send input to a PTY.

**Arguments**:

- `pid`: Process ID of the PTY
- `data`: Input data to send
- `request_timeout`: Timeout for the request in **seconds**


### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to use for the PTY
- `cwd`: Working directory for the PTY
- `envs`: Environment variables for the PTY
- `timeout`: Timeout for the PTY in **seconds**
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Handle to interact with the PTY


### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resize PTY.

Call this when the terminal window is resized and the number of columns and rows has changed.

**Arguments**:

- `pid`: Process ID of the PTY
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request in **seconds**s




## Commands

```python
class Commands()
```

Module for executing commands in the sandbox.


### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running commands and PTY sessions.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running commands and PTY sessions


### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a running command specified by its process ID.

It uses `SIGKILL` signal to kill the command.

**Arguments**:

- `pid`: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the command was killed, `False` if the command was not found


### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Send data to command stdin.

:param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the command
:param request_timeout: Timeout for the request in **seconds**



### run

```python
@overload
def run(cmd: str,
        background: Union[Literal[False], None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandResult
```

Start a new command and wait until it finishes executing.

**Arguments**:

- `cmd`: Command to execute
- `background`: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `on_stdout`: Callback for command stdout output
- `on_stderr`: Callback for command stderr output
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandResult` result of the command execution


### run

```python
@overload
def run(cmd: str,
        background: Literal[True],
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: None = None,
        on_stderr: None = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None) -> CommandHandle
```

Start a new command and return a handle to interact with it.

**Arguments**:

- `cmd`: Command to execute
- `background`: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
- `envs`: Environment variables used for the command
- `user`: User to run the command as
- `cwd`: Working directory to run the command
- `timeout`: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command


### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to a running command.

You can use `CommandHandle.wait()` to wait for the command to finish and get execution results.

**Arguments**:

- `pid`: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
- `timeout`: Timeout for the connection in **seconds**. Using `0` will not limit the connection time
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`CommandHandle` handle to interact with the running command




## SandboxApi

```python
class SandboxApi(SandboxApiBase)
```


### list

```python
@classmethod
def list(cls,
         api_key: Optional[str] = None,
         query: Optional[SandboxQuery] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> List[SandboxInfo]
```

List all running sandboxes.

**Arguments**:

- `api_key`: API key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `query`: Filter the list of sandboxes, e.g. by metadata `SandboxQuery(metadata={"key": "value"})`, if there are multiple filters they are combined with AND.
- `domain`: Domain to use for the request, only relevant for self-hosted environments
- `debug`: Enable debug mode, all requested are then sent to localhost
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of running sandboxes




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox is a secure and isolated cloud environment.

The sandbox allows you to:
- Access Linux OS
- Create, list, and delete files and directories
- Run commands
- Run isolated code
- Access the internet

Check docs [here](https://e2b.dev/docs).

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
from e2b import Sandbox

sandbox = Sandbox()
```


### files

```python
@property
def files() -> Filesystem
```

Module for interacting with the sandbox filesystem.


### commands

```python
@property
def commands() -> Commands
```

Module for running commands in the sandbox.


### pty

```python
@property
def pty() -> Pty
```

Module for interacting with the sandbox pseudo-terminal.


### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Create a new sandbox.

By default, the sandbox is created from the default `base` sandbox template.

**Arguments**:

- `template`: Sandbox template name or ID
- `timeout`: Timeout for the sandbox in **seconds**, default to 300 seconds. Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users
- `metadata`: Custom metadata for the sandbox
- `envs`: Custom environment variables for the sandbox
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

sandbox instance for the new sandbox


### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable

**Returns**:

sandbox instance for the existing sandbox
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)
```


### kill

```python
@overload
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@overload
@staticmethod
def kill(sandbox_id: str,
         api_key: Optional[str] = None,
         domain: Optional[str] = None,
         debug: Optional[bool] = None,
         request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox specified by sandbox ID.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


### set\_timeout

```python
@overload
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `timeout`: Timeout for the sandbox in **seconds**
- `request_timeout`: Timeout for the request in **seconds**


### set\_timeout

```python
@overload
@staticmethod
def set_timeout(sandbox_id: str,
                timeout: int,
                api_key: Optional[str] = None,
                domain: Optional[str] = None,
                debug: Optional[bool] = None,
                request_timeout: Optional[float] = None) -> None
```

Set the timeout of the sandbox specified by sandbox ID.

After the timeout expires the sandbox will be automatically killed.
This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.set_timeout`.

Maximum time a sandbox can be kept alive is 24 hours (86_400 seconds) for Pro users and 1 hour (3_600 seconds) for Hobby users.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `timeout`: Timeout for the sandbox in **seconds**
- `api_key`: E2B API Key to use for authentication, defaults to `E2B_API_KEY` environment variable
- `request_timeout`: Timeout for the request in **seconds**




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events.
It is used to get the latest events that have occurred in the watched directory.

Use `.stop()` to stop watching the directory.


### stop

```python
def stop()
```

Stop watching the directory.
After you stop the watcher you won't be able to get the events anymore.


### get\_new\_events

```python
def get_new_events() -> List[FilesystemEvent]
```

Get the latest events that have occurred in the watched directory since the last call, or from the beginning of the watching, up until now.

**Returns**:

List of filesystem events




## Filesystem

```python
class Filesystem()
```

Module for interacting with the filesystem in the sandbox.


### read

```python
@overload
def read(path: str,
         format: Literal["text"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None) -> str
```

Read file content as a `str`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`text` by default
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `str`


### read

```python
@overload
def read(path: str,
         format: Literal["bytes"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> bytearray
```

Read file content as a `bytearray`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`bytes`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as a `bytearray`


### read

```python
@overload
def read(path: str,
         format: Literal["stream"],
         user: Username = "user",
         request_timeout: Optional[float] = None) -> Iterator[bytes]
```

Read file content as a `Iterator[bytes]`.

**Arguments**:

- `path`: Path to the file
- `user`: Run the operation as this user
- `format`: Format of the file content—`stream`
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

File content as an `Iterator[bytes]`


### write

```python
@overload
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Write content to a file on the path.

Writing to a file that doesn't exist creates the file.

Writing to a file that already exists overwrites the file.

Writing to a file at path that doesn't exist creates the necessary directories.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file, can be a `str`, `bytes`, or `IO`.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the written file


### write

```python
@overload
def write(files: List[WriteEntry],
          user: Optional[Username] = "user",
          request_timeout: Optional[float] = None) -> List[EntryInfo]
```

Writes a list of files to the filesystem.

When writing to a file that doesn't exist, the file will get created.
When writing to a file that already exists, the file will get overwritten.
When writing to a file that's in a directory that doesn't exist, you'll get an error.

**Arguments**:

- `files`: list of files to write
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

Information about the written files


### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

List entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

List of entries in the directory


### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Check if a file or a directory exists.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the file or directory exists, `False` otherwise


### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Remove a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**


### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Rename a file or directory.

**Arguments**:

- `old_path`: Path to the file or directory to rename
- `new_path`: New path to the file or directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

Information about the renamed file or directory


### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Create a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**

**Returns**:

`True` if the directory was created, `False` if the directory already exists


### watch\_dir

```python
def watch_dir(path: str,
              user: Username = "user",
              request_timeout: Optional[float] = None,
              recursive: bool = False) -> WatchHandle
```

Watch directory for filesystem events.

**Arguments**:

- `path`: Path to a directory to watch
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request in **seconds**
- `recursive`: Watch directory recursively

**Returns**:

`WatchHandle` object for stopping watching directory



import { Support } from './Support'

# Need help?

Join our Discord community, open GitHub issues, or send us an email if you have any questions or request.

<Support />



# Vercel Edge Runtime and Cloudflare Workers

The E2B JavaScript SDK currently lacks support for Vercel Edge Runtime and Cloudflare Workers due to transport layer package incompatibility used for Sandbox communication. We recommend using supported runtimes like Node, Bun, or Deno instead.


# Docker push authentication error

When the CLI tries to push a Docker image to the registry, you might encounter an authentication error. This error sometimes occurs for users when Docker doesn't send any credentials to the registry.
To resolve this issue, you can use the following steps:

## MacOS

1. Open Docker Desktop.
2. Go to Settings.
3. Go to Docker Engine.
4. Add the following line to the json configuration:

```json
{
  "insecure-registries": ["host.docker.internal:49984"]
}
```

It may look like this:

```json
{
  "builder": {
    "gc": {
      "defaultKeepStorage": "20GB",
      "enabled": true
    }
  },
  "features": {
    "buildkit": true
  },
  "insecure-registries": [
    "host.docker.internal:49984"
  ]
}
```
This allows Docker to send requests to local proxy, which handles the authentication.

5. Click Apply & Restart.


## Linux

1. Edit the Docker configuration file (usually `/etc/docker/daemon.json`) and add the following line, if the file doesn't exist, create it:
```json
{
  "insecure-registries": ["localhost:49984"]
}
```

2. Restart Docker:

```bash
sudo systemctl restart docker
```

## Windows

1. Open Docker Desktop.
2. Go to Settings.
3. Go to Docker Engine.
4. Add the following line to the json configuration:

```json
{
  "insecure-registries": ["host.docker.internal:49984"]
}
```
5. Click Apply & Restart.


